<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vidwo系列 -- 性能优化方案调研</title>
    <link href="/2025/01/11/Video-PerformanceOptimize-Solution/"/>
    <url>/2025/01/11/Video-PerformanceOptimize-Solution/</url>
    
    <content type="html"><![CDATA[<h1 id="整体方案思路"><a href="#整体方案思路" class="headerlink" title="整体方案思路"></a>整体方案思路</h1><h2 id="vlc调研"><a href="#vlc调研" class="headerlink" title="vlc调研"></a>vlc调研</h2><p>vlc组件支持两种视频播放模式：渲染至窗口，渲染至图片。</p><ul><li>渲染至窗口：<ul><li>对于windows原生开发来说，《渲染至窗口》的整体流程更简洁。同时，也丧失了一定的灵活性。比如：视频帧的后处理。</li><li>对于qt开发来说，《渲染至窗口》需要获取qt空间的窗口句柄winId。但是，winId会导致窗口继承链中的事件处理中断。</li></ul></li><li>渲染至图片：<ul><li>相对比较灵活，通用的方式，它不受具体开发框架的限制。</li></ul></li></ul><h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul><li>原生控件 – 单纹理绘制：既支持 <span style="color:red">渲染至窗口</span>，也支持渲染至图片</li><li>原生控件 – 多纹理绘制：需要与指定的视频帧进行alpha混合（其它纹理即蒙层等）， <span style="color:red">“不支持渲染至窗口”</span></li><li>原生控件 – qml 绘制：需要提供视频帧， <span style="color:red">“不支持渲染至窗口”</span></li><li>H5控件 – 单纹理绘制： 无需额外解码，仅视频帧渲染流程需要优化</li></ul><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>桌面应用开发基本上会涉及音视频播放：原生视频播放，H5视频播放。</p><h1 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h1><ul><li>原生：视频帧渲染环节，视频解码环节</li><li>H5: 视频帧渲染环节</li></ul><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>方向1：Qt 开发框架下，有三种图片渲染：QWidget::paint, QML::Image, QOpenGLWidget。其中，QOpenGLWidget提供了多种方式。我们采用它的opengl渲染流程 <b>（原生+H5）</b></p><p><del><span style="color:red">方向2（V1）：使用第三方组件库vlc，重构端内的视频解码+渲染流程，即：直接将视频帧渲染至指定窗口  <b>（仅原生）</b></span></del></p><p><del><span style="color:red">方向2（V2）: 使用第三方组件库vlc，重构端内的视频解码流程，即：vlc作为独立进程负责解码并输出纹理texture2d。最终的渲染操作依赖方向1的实现 <b>（仅原生）</b></span></del></p><p>方向2（终版）：使用第三方组件库vlc，重构端内的视频解码实现，即：vlc作为库形式嵌入应用。通过vlc回调实时刷新视频帧，并由方向1的渲染流程负责最终显示 <b>（仅原生）</b></span></p><p><img src="/2025/01/11/Video-PerformanceOptimize-Solution/Video_PerformanceOpt.drawio.png"></p><p><del><span style="color:red">向3：现有CEF3采用OSR渲染模式, 除了方向1提及的opengl渲染外，我们可选CEF提供的非OSR渲染模式。即：子窗口和弹窗模式<b>（仅H5）方案不可行</b><span></del></p><h1 id="实现（方向2）"><a href="#实现（方向2）" class="headerlink" title="实现（方向2）"></a>实现（方向2）</h1><p>从播放器的角度，音视频仅需仅需1份ffmpeg解码，1份视频帧渲染。具体如下：<br><img src="/2025/01/11/Video-PerformanceOptimize-Solution/Video_PlaybackFramework.drawio.png"></p><h1 id="业务相关"><a href="#业务相关" class="headerlink" title="业务相关"></a>业务相关</h1><p>桌面应用开发中，音视频播放流程基本上要兼顾通用播放器的大部分功能：</p><ul><li>音视频控制逻辑：支持暂停，继续，销毁</li><li>音视频切换逻辑：需要支持不同视频的切换等</li></ul>]]></content>
    
    
    <categories>
      
      <category>Video</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【杂项】Windows 异形窗体改造</title>
    <link href="/2024/09/17/Windows-HeteroTypeWindow/"/>
    <url>/2024/09/17/Windows-HeteroTypeWindow/</url>
    
    <content type="html"><![CDATA[<h1 id="一、需求背景"><a href="#一、需求背景" class="headerlink" title="一、需求背景"></a>一、需求背景</h1><p>Windows 客户端需要支持非规则窗体的视觉效果。同时，需要保留窗口的缩放、鼠标穿透、跨屏拖放等交互效果。</p><h1 id="二、技术点"><a href="#二、技术点" class="headerlink" title="二、技术点"></a>二、技术点</h1><h3 id="技术点1：异形窗体"><a href="#技术点1：异形窗体" class="headerlink" title="技术点1：异形窗体"></a>技术点1：异形窗体</h3><p>使用透明控件扩充主窗口四周，以达到不规则图形超出客户区而不被裁剪的目的。同时，能保证窗口不受因缩放造成的抖动或闪烁。</p><h3 id="技术点2：鼠标穿透至桌面"><a href="#技术点2：鼠标穿透至桌面" class="headerlink" title="技术点2：鼠标穿透至桌面"></a>技术点2：鼠标穿透至桌面</h3><p>鼠标穿透可借助透明区域裁剪操作。其中，区域计算涉及布尔运算，图片掩码等图形学操作。</p><h3 id="技术点3：-窗体缩放"><a href="#技术点3：-窗体缩放" class="headerlink" title="技术点3： 窗体缩放"></a>技术点3： 窗体缩放</h3><ul><li>窗体样式： WS_OVERLAPPED | WS_MAXIMIZEBOX | WS_MINIMIZEBOX</li><li>鼠标输入通知： WM_NCHITTEST 是鼠标时间的入口。其返回值：HTCAPTION, HTTOP, HTTOPRIGHT…</li><li>窗体通知： WM_SIZING | WM_MOVING | WM_ENTERSIZEMVOE | WM_EXITSIZEMOVE | WM_GETMINMAXINFO | WM_NCLBUTTONDBLCLK | WM_NCCALCSIZE</li></ul><p>注：本部分仅列出实现功能所涉及的 window style, window notifications 和 window messages.</p><h1 id="三、-疑难点"><a href="#三、-疑难点" class="headerlink" title="三、 疑难点"></a>三、 疑难点</h1><h3 id="疑难点1：-桌面顶部停靠"><a href="#疑难点1：-桌面顶部停靠" class="headerlink" title="疑难点1： 桌面顶部停靠"></a>疑难点1： 桌面顶部停靠</h3><p>当窗口移动时，顶部透明区域需要被裁剪：WM_MOVING, WM_EXITSIZEMOVE</p><h3 id="疑难点2：-裁剪与缩放的冲突"><a href="#疑难点2：-裁剪与缩放的冲突" class="headerlink" title="疑难点2： 裁剪与缩放的冲突"></a>疑难点2： 裁剪与缩放的冲突</h3><p>当窗体缩放时，需要取消裁剪操作以避免窗体抖动：WM_SIZING | WM_NCCALCSIZE | WM_NCHITTEST </p><h3 id="疑难点3：-跨屏窗体异常"><a href="#疑难点3：-跨屏窗体异常" class="headerlink" title="疑难点3： 跨屏窗体异常"></a>疑难点3： 跨屏窗体异常</h3><p>当拖动窗体跨越具有不同 DPI 的屏幕时，需要刷新窗口：WM_ENTERSIZEMOVE | WM_EXITSIZEMOVE | QWindow::screenChanged</p><p>注：本部分仅列出解决问题需要的 window notifications 和 一些接口。</p><h1 id="四、剖析"><a href="#四、剖析" class="headerlink" title="四、剖析"></a>四、剖析</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本部分仅对 1 例疑难点处理作简要分析，其它同理。</p><h3 id="基本常识"><a href="#基本常识" class="headerlink" title="基本常识"></a>基本常识</h3><p>windows 桌面窗口控制着所有顶层窗口的行为。本部分不再重复介绍，有以下链接可参考</p><ul><li><a href="https://blog.csdn.net/tonglin12138/article/details/103967711">https://blog.csdn.net/tonglin12138/article/details/103967711</a></li><li><a href="https://www.cnblogs.com/staring-hxs/p/3202219.html">https://www.cnblogs.com/staring-hxs/p/3202219.html</a></li></ul><p>注：上述链接对于顶层窗口，子窗口等术语的定义会存在出入，一切以 Windows App Development 为准。</p><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>to be continued…</p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【杂项】Aria2- 基础应用（持续更新）</title>
    <link href="/2024/09/16/Aria2-CommonSence-1/"/>
    <url>/2024/09/16/Aria2-CommonSence-1/</url>
    
    <content type="html"><![CDATA[<h1 id="1、Aria-基础设施"><a href="#1、Aria-基础设施" class="headerlink" title="1、Aria 基础设施"></a>1、Aria 基础设施</h1><h3 id="Aria2-下载器"><a href="#Aria2-下载器" class="headerlink" title="Aria2 下载器"></a>Aria2 下载器</h3><p>Aria2 下载器支持多种 IPC 通信模式： JSON-RPC, XML-RPC。</p><h3 id="IPC-机制"><a href="#IPC-机制" class="headerlink" title="IPC 机制"></a>IPC 机制</h3><p>基于 Aria2 提供的 RPC 机制， 我们选择了 xmlrpc 作为进程间通信方式。xmlrpc 开源库多种多样， 比如：libmaia, timxmlrpc。</p><ul><li>libmaia: <a href="https://github.com/wiedi/libmaia">https://github.com/wiedi/libmaia</a><br>一款为 Qt 定制的 XML-RPC 库。</li><li>timxmprpc: <a href="https://github.com/drtimcooper/XmlRpc4Win">https://github.com/drtimcooper/XmlRpc4Win</a><br>一款轻量的基于 C&#x2F;C++ 的 XML-RPC 库。</li></ul><h1 id="2、Aria-通信机制"><a href="#2、Aria-通信机制" class="headerlink" title="2、Aria 通信机制"></a>2、Aria 通信机制</h1><p>Aria2 下载器具有较灵活的配置：全局配置，单文件配置。<br>其中，全局配置会覆盖默认参数并影响所有下载资源；单文件配置仅对指定文件生效。</p><ul><li>–continue: 当下载中断时，支持继续下载（append and then check）</li><li>–auto-file-renaming&#x3D;false: 不支持重命名，即：相同文件会被覆盖</li><li>–allow-override&#x3D;true: 当缺少控制文件时，重新下载</li></ul><p>同时，Aria2 支持通过 command-line 进行初始化，也支持通过 rpc 进行下载过程中的交互。</p><ul><li>aria2.tellStatus: 信息或状态查询</li><li>aria2.addUri: 添加下载文件</li><li>aria2.pasueAll: 暂停操作，比如：下载，校验等</li><li>aria2.unpauseAll: 取消暂停操作</li><li>aria2.getVersion: 获取 aria 版本</li></ul><h1 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h1><ul><li>IPC通信：多文件下载时，略显鸡肋。需要主动查询并统计，还要控制好频率。同时，需要注意 aria2 的 初始化状态（借助 aria2.getVersion 探测）</li><li>下载进度：各种原因会造成进度回退，需要针对性处理（更新文件，继续上次下载等情况）</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows系列 -- 设备IO</title>
    <link href="/2024/04/07/Windows-DeviceIO/"/>
    <url>/2024/04/07/Windows-DeviceIO/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本篇索引大致分为以下内容：设备、接口、同步设备I&#x2F;O、异步设备I&#x2F;O。 该篇非入门，可止步。</p><h1 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h1><p>本节以图示形式列出，供随时索引。更详细节可参考 Windows via C&#x2F;C++ (第五版)。<br><img src="/2024/04/07/Windows-DeviceIO/deviceio.png"></p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows 系列 -- 规划</title>
    <link href="/2024/04/07/Windows-OpenTopic/"/>
    <url>/2024/04/07/Windows-OpenTopic/</url>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>该系列将作为 Windows via C&#x2F;C++ (第五版)的索引，大致可分为以下几类：</p><ul><li>Windows 内核对象：重中之重。</li><li>Windows 开发通识: 一些常识，比如: 进程，线程，设备等。</li><li>Windows 技术设施: 一些便捷接口，比如：可提醒 IO 提供的 QueueForAPC 机制。</li></ul><h1 id="二、规划"><a href="#二、规划" class="headerlink" title="二、规划"></a>二、规划</h1><ul><li>设备IO</li><li>Windows 消息</li><li>…</li></ul><h1 id="三、体会"><a href="#三、体会" class="headerlink" title="三、体会"></a>三、体会</h1><p>Windows Job: 管理，监听当前 Process 及其 Child Process。无论是业务开发，还是日常 Debug (配合IOCP)，真好用。<br>Windows Message: 便捷的 IPC 通信小助手。借助冗余字段，可轻易搭建 Process 间的双向通信。<br>…</p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SDK 系列 -- Crashes</title>
    <link href="/2024/02/27/SDK-Crashes/"/>
    <url>/2024/02/27/SDK-Crashes/</url>
    
    <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>应用开发时，难免遇到崩溃问题：常识用于缩小检索范围；检索能力要靠经验积累喽。</p><h1 id="二、SDK-崩溃："><a href="#二、SDK-崩溃：" class="headerlink" title="二、SDK 崩溃："></a>二、SDK 崩溃：</h1><ul><li>spdlog: 开源日志库<br>当日志路径存在 utf16 字符时，构造函数传入的路径参数会造成崩溃。此时，需要单独构建支持 utf16 的库版本。</li><li>zmq: 开源IPC库<br>zmq 会在当前用户目录下的某个路径写入一些临时数据。如果当前用户的账户名存在 utf16 字符时，zmq 创建 socket 时，会导致进程强制退出（quit）。zmq 4.3.5 版本已修复。</li><li>cef: 开源webview库<br>如果 cef 运行目录和安装目录中存在 utf16 字符，页面渲染会出现黑屏现象。博主当时的解决方式是更新 cef 的版本（95 –&gt; 109）。</li><li>bit7z: 开源解压缩库<br>当有解压缩文件需求时，我们可选地有 7z.exe 或者 集成 bit7z。<br>对于使用bit7z的应用，有两个版本可选：V3, V4。V3 版本的 bit7z 不支持解压缩途中退出。V4 版本的 bit7z 借助业务回调接口的返回值（0 or 非0）达到了中途退出的目的。然而，V4.0.0 版本的异常捕获机制存在崩溃Bug(空间不足时崩溃)。<br>截至 2024年2月27日，bit7z 已更新至 V4.0.5 版本。不确定后来的版本是否修复上述问题哦。</li></ul>]]></content>
    
    
    <categories>
      
      <category>SDK</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SDK 系列 -- CEF -- 构建流程(Current Branches &amp; Legacy Branches)</title>
    <link href="/2024/02/26/CEF-Build/"/>
    <url>/2024/02/26/CEF-Build/</url>
    
    <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>桌面端开发中，会有使用到 Webview 的场景。当有视频播放需求时，需要本地构建带有自定义开关的 CEF。由于版权限制，CEF官方提供的库文件并不支持该动能。如果桌面客户端使用的时 Qt, Qt WebEngine 也是不支持的哦。相较于 QWebEngine，我们通常会选择灵活性更大的 CEF。<br>截至 2024年2月26日，CEF 的最新 Release 大版本号是 122。对于 CEF 的所有版本号，博主通常有两种划分方式：</p><h6 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h6><ul><li>Supported Branches: 官方维护的构建工具支持构建的分支。</li><li>Unsupported Branches: 官方维护的构建工具不支持构建的分支。注意：<a href="https://bitbucket.org/chromiumembedded/cef/wiki/BranchesAndBuilding">官方文档</a>中的部分 Legacy Release Branches 也可直接完成构建哦。博主曾傻瓜式构建的最近大版本号是 117。</li></ul><h6 id="方式二：system-requirement"><a href="#方式二：system-requirement" class="headerlink" title="方式二：system requirement"></a>方式二：system requirement</h6><ul><li>Win10 and upper: 大版本号为 110 或更高的版本，仅支持 Win10, Win11系统。</li><li>Win7 and upper： 支持 Win7, Win8, Win10, Win11 的最新版本号为 109, 对应分支是 5414。</li></ul><h1 id="二、构建库"><a href="#二、构建库" class="headerlink" title="二、构建库"></a>二、构建库</h1><p>两种构建方式，大致命名为：Current Release Build, Legacy Release Build。</p><h4 id="Current-Release-Build"><a href="#Current-Release-Build" class="headerlink" title="Current Release Build"></a>Current Release Build</h4><p>构建流程可参考上述官方文档。部分配置参数:</p><ul><li>is_official_build&#x3D;true</li><li>proprietary_codecs&#x3D;true</li><li>ffmpeg_branding&#x3D;Chrome</li><li>chrome_pgo_phase&#x3D;0</li></ul><h4 id="Legacy-Release-Build"><a href="#Legacy-Release-Build" class="headerlink" title="Legacy Release Build"></a>Legacy Release Build</h4><p>构建流程及构建参数同上。在较低版本的构建中，会遇到两次错误：</p><ul><li><p>Error 1：git_dependencies配置不兼容，需要修改<a href="https://source.chromium.org/chromium/_/chromium/chromium/tools/depot_tools.git/+/b6eaed26fce285228743f626ccd8de1b5a26a6dd">打包脚本</a>（gclient.py, gclient_eval.py）</p></li><li><p>Error 2: python 解析相对路径失败, 需要修改<a href="https://github.com/chromiumembedded/cef/issues/3506">模块脚本</a>（mojom_js_generator.py 或者 mojom_ts_generator.py）<br>需要全局搜索文件，匹配字符串：”path &#x3D;&#x3D; ‘&#x2F;‘“。</p></li></ul><h1 id="三、系统配置"><a href="#三、系统配置" class="headerlink" title="三、系统配置"></a>三、系统配置</h1><ul><li>CPU：CPU 逻辑核心数强有关，即可并发执行的数量。(建议 i7 12700k)</li><li>磁盘：读写速度强相关，链接阶段持续较久。(建议固态1T)</li></ul>]]></content>
    
    
    <categories>
      
      <category>SDK</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>下载器 -- IPC 调研(备忘) -- 2024.09.15 旧稿发布</title>
    <link href="/2023/09/16/SDK-Downlaoder-part2/"/>
    <url>/2023/09/16/SDK-Downlaoder-part2/</url>
    
    <content type="html"><![CDATA[<h1 id="一、需求"><a href="#一、需求" class="headerlink" title="一、需求"></a>一、需求</h1><p>对于自研下载器，我们可以直接复用 Aria2c 模块中的 XML-RPC 或者调研新的 IPC 通信。</p><h1 id="二、现状"><a href="#二、现状" class="headerlink" title="二、现状"></a>二、现状</h1><p>端内集成的 Aria2c 下载器使用定制的 MaiaIPC 进行通信：http post。会存在一些问题：</p><ul><li>Http 链接：N 组资源下载，需要在业务层维持 N 个 Http链接</li><li>状态查询：定时主动轮询，会存在 60% 以上的无效查询。</li><li>异常同步：强依赖状态查询。若不查询，则无法获取异常信息。</li></ul><p><img src="/2023/09/16/SDK-Downlaoder-part2/maia_ipc.png"></p><h1 id="三、预期"><a href="#三、预期" class="headerlink" title="三、预期"></a>三、预期</h1><p>新版 IPC 要能做到按需同步信息，主要是状态信息。按照现有的资源下载机制，新版 IPC 流程大致如下：</p><p><img src="/2023/09/16/SDK-Downlaoder-part2/ipc_wrapper.png"></p><p>一些针对性改进：</p><ul><li>在业务层面，client只需要提前简历两个链接；downloader 也只需跟对应的两个链接通信</li><li>client 可以主动给 downlaoder 下发命令（暂停，继续等）; downloader 也可以主动上报（状态，异常等）</li></ul><h1 id="四、调研"><a href="#四、调研" class="headerlink" title="四、调研"></a>四、调研</h1><p>1、gRPC<br>库过于庞大，存在过多无用功能。暂不考虑应用在 IPC 通信。</p><p>2、Microsoft IPC<br>C++ 模板库。但提供的功能单一，仅支持了同步的 REQ&#x2F;REP 机制。后续持续跟进，并验证可用性。</p><p>3、ZeroMQ<br>轻量的嵌入式IPC库。具有相对灵活的可定制性。非 Win10 或者 Win10（17063 以下）系统，只能使用 socket。不过，unix domain socket 挺香。<br>(注：RabbitMQ, RocketMQ, Kafka 各有其用，不在本文考虑范围内)</p><h1 id="五、实现"><a href="#五、实现" class="headerlink" title="五、实现"></a>五、实现</h1><p>使用 ZeroMQ 实现 IPC 通信功能。PUB&#x2F;SUB 通信模式如下：</p><p><img src="/2023/09/16/SDK-Downlaoder-part2/fanin_fanout.png"></p><h1 id="六、建议"><a href="#六、建议" class="headerlink" title="六、建议"></a>六、建议</h1><ul><li>win 10 (17063) 以下系统，只能使用 socket 进行 IPC 通信。</li><li>在 windows 环境下，zmq 使用 wepoll 开源库支持 epoll。经线上实践，wepoll 存在问题。因此， windows 环境下的 polling 机制建议选择 select。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>下载器 -- 调试工具(备忘)</title>
    <link href="/2023/09/15/SDK-Downloader-part1/"/>
    <url>/2023/09/15/SDK-Downloader-part1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>桌面客户端开发会涉及到文件更新：大文件的局部更新。通常情况下，我们可以使用了 Aria2c 作为辅助下载工具(非 libaria)。文件局部更新的需求，实现主流的更新下载方案很重要。</p><h1 id="二、现状"><a href="#二、现状" class="headerlink" title="二、现状"></a>二、现状</h1><p>自研下载器是采用 Golang 语言开发，并以库的形式供平台集成。开发前期存在以下问题：</p><ul><li>Golang 只能提供 Windows 平台的动态链接库，且缺少 *.lib 符号文件</li><li>自研库的开发同学资历尚浅，且库未作 Windows 平台下的功能性验证</li></ul><p>因此，要作一些准备工作以提高开发效率：</p><ul><li>lib 生成工具：以应对 SDK 接入前期频繁更换库文件的情况</li><li>C++ 测试环境：以用于 SDK 接入前期的频繁验证工作</li></ul><h1 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h1><p>本节内容将以列表形式提供: lib 工具生成、VSCode 测试环境</p><h2 id="1、lib-生成（手动）"><a href="#1、lib-生成（手动）" class="headerlink" title="1、lib 生成（手动）"></a>1、lib 生成（手动）</h2><p>动态库的使用方式分为：动态调用，静态调用。SDK 导出库只给到了 *.h 和 *.dll 文件。要想以静态调用的方式使用，我们需要通过 *.dll 生成对应的 *.lib 符号文件。大致步骤如下：</p><ul><li><strong>导出 dump.txt</strong><br>使用 Developer Command Prompt for VS 20XX 工具，通过命令行 <code>dumpbin /EXPORTS *.dll &gt; dump.txt</code> 导出：<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tap">Dump of file 7z.dll<br><br>File Type: DLL<br><br>  Section contains the following exports for 7z.dll<br><br>   <span class="hljs-number"> 00000000 </span>characteristics<br>    62D16FC1 time date stamp Fri Jul<span class="hljs-number"> 15 </span>21:46:41 2022<br>        0.00 version<br>          <span class="hljs-number"> 1 </span>ordinal base<br>         <span class="hljs-number"> 13 </span>number of functions<br>         <span class="hljs-number"> 13 </span>number of names<br><br>    ordinal hint RVA      name<br>         <span class="hljs-number"> 1 </span>  <span class="hljs-number"> 0 </span>0010D6E0 CreateDecoder<br>          .<br>  Summary<br>       <span class="hljs-number"> 9000 </span>.data<span class="hljs-number"> 13000 </span>.pdata<span class="hljs-number"> 55000 </span>.rdata<span class="hljs-number"> 4000 </span>.reloc<span class="hljs-number"> 19000 </span>.rsrc<span class="hljs-number"> 137000 </span>.text<br></code></pre></td></tr></table></figure>导出信息相当丰富，但我们只需要 Section 段落中的导出函数名, 比如：CreateDecoder 等…</li><li><strong>生成 .def</strong><br>DEF 文件格式详见<a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/moduledefinition-dot-def-files?view=msvc-170">官方介绍</a>。本着最简原则，我们只需要用到：LIBRARY、EXPORTS。为了简化操作步骤，我们需要一个辅助工具: 根据 dump 信息生成 .def 文件 <strong>(导出接口变化时，才需要重新导出 DEF)</strong> 。辅助工具逻辑大致如下：<ul><li>读取 dump 文件: <code>dump.txt</code></li><li>定位 Section 段落：<ul><li>begin with： <code>original hint RVA</code> </li><li>end with: <code>Summary</code></li></ul></li><li>搜索符号并写入 .DEF 文件</li></ul></li><li><strong>生成 .lib</strong> ：<br>使用 Developer Command Prompt for VS 工具，通过命令行: <code>lib /def:example.def /machine:x64 /out:example.lib</code></li></ul><h2 id="2、lib-生成工具"><a href="#2、lib-生成工具" class="headerlink" title="2、lib 生成工具"></a>2、lib 生成工具</h2><p>现成的开源工具 <a href="https://digitalmars.com/ctg/implib.html">IMPLIB</a>，可以根据 DLL 文件或者 DEF 文件生成对应的导出文件 LIB。使用教程可参考官方文件，大致命令如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">implib [switches] libfile [ dllfile | deffile ]<br></code></pre></td></tr></table></figure><h2 id="3、测试环境搭建：VSCode-with-C"><a href="#3、测试环境搭建：VSCode-with-C" class="headerlink" title="3、测试环境搭建：VSCode with C++"></a>3、测试环境搭建：VSCode with C++</h2><p>当 DLL 接口更新时，涉及到的工作流大致如下：</p><ul><li>测试环境：快速生成 EXE、快速步进 DEBUG。</li><li>测试链路： 生成 .lib –&gt; 生成 EXE –&gt; DEBUG。</li></ul><p>VSCode 谁用谁知道，开发利器。因此，博主就将 VSCode 作为我们的测试环境。 关于 VSCode C++ 环境的搭建，网上教程一大把。因此，博主只对一些必要的配置做介绍。</p><ul><li><strong>mingw64</strong>: 提供 Windows 下软件构建所需的工具，如：gcc, g++ 等</li><li><strong>launch.json</strong>: vscode 启动程序的配置文件<ul><li>program: EXE 的全路径</li><li>miDebuggerPath: GDB 的全路径</li><li>preLaunchTask: EXE 运行的前置工作，如：编译工作。</li></ul></li><li><strong>task.json</strong>: 协助 launch.json 的前置工作<ul><li>label: 任务提示词，执行构建时供用户选用的提示</li><li>command: 执行命令</li><li>args: 构建参数，比如：源文件、包含路径、依赖路径等</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CEF3 系列 -- 实践汇总（持续更新）</title>
    <link href="/2023/09/02/CEF-Pratice-Summary/"/>
    <url>/2023/09/02/CEF-Pratice-Summary/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首次半年绩效考核，挺好的绩效。输出一些技术相关的汇总, 比如：Cef。</p><ul><li>20 年 7 月，应届入职。博主首次接触 Web 相关开发：Electron &amp; VueJS 桌面客户端。</li><li>22 年 11 月，博主入职新公司，并再次接触 Web 相关的开发：Qt &amp; QCefView 桌面客户端。</li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>汇总主要关注应用开发中的技术问题、技术 <strong>‘难点’</strong> 。因此，后续部分将以列表形式给出。</p><h2 id="1、Input-Method-Editor-IME"><a href="#1、Input-Method-Editor-IME" class="headerlink" title="1、Input Method Editor (IME)"></a>1、Input Method Editor (IME)</h2><p>详见 <a href="/2023/03/08/QCef-Ime-JSInject/" title="[杂项] CEF3 -- IME Behavior">[杂项] CEF3 -- IME Behavior</a>。</p><h2 id="2、QCefView-输入法组合键：小语种（葡萄牙语）"><a href="#2、QCefView-输入法组合键：小语种（葡萄牙语）" class="headerlink" title="2、QCefView 输入法组合键：小语种（葡萄牙语）"></a>2、QCefView 输入法组合键：小语种（葡萄牙语）</h2><p>KeyBoardUtils 作为插件的辅助工具，主要用于 Qt 事件 –&gt; CEF3 事件的参数转换。其中的 <code>winGetKeyBoardModifiers</code> 接口，负责解析虚拟组合按键。</p><ul><li>问题代码段<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span></span><br><span class="hljs-function"><span class="hljs-title">winGetKeyboardModifiers</span><span class="hljs-params">(QKeyEvent* qe)</span></span>&#123;<br>    ...<br>    <span class="hljs-keyword">if</span>(!qe-&gt;<span class="hljs-built_in">text</span>().<span class="hljs-built_in">isEmpty</span>() &amp;&amp; (::<span class="hljs-built_in">GetKeyState</span>(VK_RMENU) &amp; <span class="hljs-number">0x8000</span>))&#123;<br>        HKL current_layout = ::<span class="hljs-built_in">GetKeyBoardLayout</span>(<span class="hljs-number">0</span>);<br>        SHORT scan_res = ::<span class="hljs-built_in">VkKeyScanExW</span>(vk, current_layout);<br>        <span class="hljs-keyword">if</span>(((scan_res &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>) == (<span class="hljs-number">2</span> | <span class="hljs-number">4</span>))&#123;<br>            cm &amp;= ~(EVENTFLAG_CONTROL_DOWN | EVENTFLAG_ALT_DOWN);<br>            cm |= EVENTFLAG_ALTGR_DOWN<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cm;<br>&#125;<br></code></pre></td></tr></table></figure>首先，从代码风格可见 <strong>QCefView</strong> 作者具备深厚的 Window 开发功底。问题代码意图：<ul><li>判断小语种键盘：<code>::GetKeyState(VK_RMENU) &amp; 0x8000</code></li><li>获取键盘布局：<code>::GetKeyBoardLayout(0)</code></li><li>通过 VirtualKey 和 物理键盘布局获取扫描码：<code>VkKeyScanExW(vk, current_layout)</code></li><li>匹配 Control + ALT 组合键：位运算见上述代码。</li></ul></li><li>修复代码段<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span></span><br><span class="hljs-function"><span class="hljs-title">winGetKeyboardModifiers</span><span class="hljs-params">(QKeyEvent* qe)</span></span>&#123;<br>    ...<br>    <span class="hljs-keyword">if</span>(!qe-&gt;<span class="hljs-built_in">text</span>().<span class="hljs-built_in">isEmpty</span>())&#123;<br>        <span class="hljs-keyword">if</span>((m &amp; Qt::ControlModifier) &amp;&amp; (m &amp; Qt::ALtModifier))&#123;<br>            cm &amp;= ~(EVENTFLAG_CONTROL_DOWN | EVENTFLAG_ALT_DOWN);<br>            cm |= EVENTFLAG_ALTGR_DOWN<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cm;<br>&#125;<br></code></pre></td></tr></table></figure>OSR 渲染模式下，我们无法获取正确的窗口句柄及其 Window 消息。所以，上述操作有点多此一举：只需要匹配 CONTROL + ALT 即可。</li></ul><h2 id="3、QCefView-Hover-Event-HoverIn-amp-HoverOut"><a href="#3、QCefView-Hover-Event-HoverIn-amp-HoverOut" class="headerlink" title="3、QCefView Hover Event: HoverIn &amp; HoverOut"></a>3、QCefView Hover Event: HoverIn &amp; HoverOut</h2><p><strong>CEF3 三种鼠标事件</strong> ：cef_browser_capi</p><ul><li>send_mouse_click_event: 处理鼠标点击</li><li>send_mouse_move_event：处理鼠标移动</li><li>send_mouse_wheel_event：处理鼠标滚轮</li></ul><p><strong>Qt 鼠标事件</strong> ：</p><ul><li>mouseMoveEvent: 鼠标移动</li><li>mousePressEvent：鼠标按下</li><li>mouseReleaseEvent：鼠标释放</li><li>wheelEvent：鼠标滚轮</li><li><strong>enterEvent</strong> &amp; <strong>leaveEvent</strong>: 鼠标移入 &amp; 移出</li></ul><p><strong>问题描述</strong> ：<br>QCefView 插件完美适配了 Qt 的前四种事件，即：mouseMove、mousePress、mouseRelease、wheelEvent。通过字面义，可以很清晰地将 CEF3 和 QCefView 事件映射。 然而，<code>enterEvent</code> 和 <code>leaveEvent</code> 并没有找到合适的选择。当窗口边缘属于可滚动区域时，边缘的滚动条的交互效果会出现 Bug: 缺少 HoverIn、HoverOut 效果。<br><strong>问题解决</strong> ：<br>通过测试，CEF3 的 send_mouse_move_event 接口兼具 moveMouse、mouseEnter 和 mouseLeave 的功能。因此，只需要按照 QCefView 接口规范，补充并转发 Qt 对应的 <strong>enterEvent</strong> 和 <strong>leaveEvent</strong> 即可。</p>]]></content>
    
    
    <categories>
      
      <category>Cef</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并发系列 -- 汇总（持续更新）</title>
    <link href="/2023/08/06/MultiThread-Pratice-4/"/>
    <url>/2023/08/06/MultiThread-Pratice-4/</url>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>本文摘自 C++ Concurrency IN  ACTION，一本基于 C++11 标准的并发和多线程编程深度指南。内容包括 std::thread、std::mutex、和 std::async 等基础类的使用，内存模型和原子操作、基于锁和无锁数据结构的构建，以及并行算法和线程管理。同时，会在部分章节附加 Qt 提供的便利工具。</p><ul><li>基础类<br><img src="/2023/08/06/MultiThread-Pratice-4/related_interfaces.png"><br>图中涉及 C++ 标准库 和 Qt 提供的一些工具类。它们足以满足 99.9% 的应用开发需求。你见过多少呢？又对它们的应用场景了解多少？（哎，难以想象共事的多位 10 多年工龄的互联网员工竟然对线程毫无感觉。博主心好累~）</li><li><del>内存模型</del></li><li><del>数据结构</del></li><li><del>并行算法</del></li><li><del>线程管理</del></li></ul><h1 id="二、并发编程实践"><a href="#二、并发编程实践" class="headerlink" title="二、并发编程实践"></a>二、并发编程实践</h1><p>该章节会结合博主 3 年多来在前端、后端、客户端方向的粗浅经验，对 C++ 并发编程作简要汇总。</p><h2 id="1、管理线程"><a href="#1、管理线程" class="headerlink" title="1、管理线程"></a>1、管理线程</h2><p>C++ 标准库让大多数线程管理变得相对简单，通过与给定线程关联的 std::thread 对象就可以管理所有事情。对于不直观的任务，标准库也提供了从基本构造快进行按需构建的可扩展性。</p><h3 id="基本线程管理"><a href="#基本线程管理" class="headerlink" title="基本线程管理"></a>基本线程管理</h3><h2 id="2、在线程间管理数据"><a href="#2、在线程间管理数据" class="headerlink" title="2、在线程间管理数据"></a><del>2、在线程间管理数据</del></h2><h2 id="3、同步并发操作"><a href="#3、同步并发操作" class="headerlink" title="3、同步并发操作"></a><del>3、同步并发操作</del></h2><h2 id="4、C-内存模型和原子类型操作"><a href="#4、C-内存模型和原子类型操作" class="headerlink" title="4、C++ 内存模型和原子类型操作"></a><del>4、C++ 内存模型和原子类型操作</del></h2><h2 id="5、数据结构：基于锁的并发数据结构，无锁的并发数据结构"><a href="#5、数据结构：基于锁的并发数据结构，无锁的并发数据结构" class="headerlink" title="5、数据结构：基于锁的并发数据结构，无锁的并发数据结构"></a><del>5、数据结构：基于锁的并发数据结构，无锁的并发数据结构</del></h2><h2 id="6、高级线程管理"><a href="#6、高级线程管理" class="headerlink" title="6、高级线程管理"></a><del>6、高级线程管理</del></h2>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并发系列 -- 实践 -- 直播推流之帧率控制（1080p59.94, 1080p50）</title>
    <link href="/2023/05/12/MultiThread-Pratice-1/"/>
    <url>/2023/05/12/MultiThread-Pratice-1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、项目背景"><a href="#一、项目背景" class="headerlink" title="一、项目背景"></a>一、项目背景</h1><p>博主在职期间，负责赛事直播项目的 Windows 桌面端开发工作：  </p><p><strong>(1) AR 后台系统</strong><br>AR后端充分利用 <code>Qt Designer</code> 提供的能力 (Custom Widget), 设计出一套能够快速集成各个算法模块的 <strong>标准化组件</strong> 。<br><img src="/2023/05/12/MultiThread-Pratice-1/arsystem_brief.png">  </p><p>上图是由 QT 构建的实时处理系统，可划分为两大组成部分：</p><ul><li>主框架（EXE）：为各算法模块的运作提供了一致的行为规范，包括：加载、运行、状态监测、异常捕获（不完善）</li><li>算法模块(DLL)：<strong>功能完备</strong> 的DLL，包括：<span style="color:red"><b>界面 UI</b></span>、算法处理、状态上报</li></ul><p>相信 99% 的 QT 码农看到功能完备时，会一脸懵。 碍于本文主题，组件的标准化流程会在 Qt 系列文章中介绍。本文仅对 <strong>对齐模块</strong> 中涉及到的一些并发考虑作简要介绍。</p><p><strong>(2) AR 前端渲染</strong><br>AR Render 是使用 Unity 游戏引擎开发的赛事直播专用软件，3D 增强现实效果直达观众（用户）。<br><img src="/2023/05/12/MultiThread-Pratice-1/arrender_brief.png"></p><p>上图是赛事直播软件的基本构成。</p><p>图中<span style="color:chocolate"><b>橙色高亮</b></span>部分不在本文讨论范围，可参考<a href="/2023/03/22/AR-FrontAndRearScene-Overview/" title="[杂项] AR -- 前后景处理">AR前后景概述</a>。<br>图中<span style="color:red"><b>红色高亮</b></span>部分涉及强相关的两部分内容，包括：GPU 异步纹理请求，BMD SDK 纹理接收。BMD SDK 部分不在本文的讨论范围，因此，本文仅对 GPU 异步纹理请求的一些考虑作简要介绍。</p><h1 id="二、并发细节考虑"><a href="#二、并发细节考虑" class="headerlink" title="二、并发细节考虑"></a>二、并发细节考虑</h1><p>并发实践的考虑，要么是为了达到性能指标、要么是为了将关注点分离。本文挑选上述 AR 直播系统中比较有挑战性的两个环节，展开对并发性能的一些论述。</p><p><strong>(1) 数据对齐之帧率控制</strong><br>1080p59.94 制式直播推流的帧间隔是 16.6ms。在整个数据处理链路中，某个环节需要进行数据收发，数据对齐，数据拼接等操作。</p><ul><li>数据接收：会进行 ms 级别的 copy 操作</li><li>数据对齐环节: 会存在 ms 级的等待操作; 会存在 ms 级的数据copy (1080p BGR 大约占 3ms，跟CPU 频率强相关)</li><li>数据拼接环节：会存在 ms 级别的 格式转换（uyvy to bgra）</li><li>数据发送：会存在 ms 级别的阻塞（sdk 内部 copy 耗时）</li></ul><p>上述的 wait, copy, format 操作远远超过了有限的 16.6ms 的帧间隔。为了保证稳定的 16.6ms 稳定输出，可以将数据处理划分为两个阶段：  </p><ul><li>阶段1：负责数据接收，数据对齐相关工作</li><li>阶段2：在发送环节，再进行相应的数据拼接操作</li></ul><p>对整个实时系统来说，时延是最不可接受的。为了稳帧率，将单个阶段划分为两个阶段：不仅增加了线程间同步的负担，还需要一定的 buffer 作为缓冲，以减少帧率波动。调整后的数据处理流程，如下图所示：<br><img src="/2023/05/12/MultiThread-Pratice-1/arsystem_aligndata.png"></p><p><strong>(2) GPU 图像获取之帧率控制</strong><br>直播项目的应用场景涉及到的软硬件条件：Unity 渲染引擎、C++ SDK、BMD 采集卡。但本小节的前半部分不拘泥于特定的渲染引擎 (Unity， UE)，特定的推流方案。我们只讨论并发相关的技术细节：GPU Request，Memory location</p><ul><li>Method 1：同步操作 + 同步操作<ul><li>Step 1: [Update]同步操作获取 GPU 纹理</li><li>Step 2: [Update]将纹理数据 copy 至 SDK 内所维护的 <strong>数据结构</strong></li></ul></li><li>Method 2: 异步操作 + 同步操作<ul><li>Step 1: [Update]异步获取 GPU 纹理（AsyncGPUReadback::Request），数据结构 frameQueue 维护纹理句柄；</li><li>Step 2: [Update]遍历 frameQueue, 将所有就绪状态的纹理数据 Copy 至 SDK 内部 <strong>数据结构</strong></li></ul></li><li><span style="color:red"><b>Method 3: 异步操作 + 异步操作</b></span><ul><li>Step 1: [Update]异步获取 GPU 纹理，frameQueue 维护异步纹理</li><li>Step 2: [Update]遍历 frameQueue, 将所有就绪状态的纹理 <strong>句柄</strong> 传至 SDK 内部 <strong>无锁数据结构</strong></li><li>Step 3: [WaitForEndOfFrame]同步 SDK 内纹理句柄的无效状态，以告知 SDK 丢弃 <strong>未及时处理</strong> 的纹理句柄</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>[杂项] QSS</title>
    <link href="/2023/04/25/QWidget-QSS-Overview/"/>
    <url>/2023/04/25/QWidget-QSS-Overview/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经过博主近期一个月在 <code>QML &amp; Quick</code> 方面的预研，部门线上产品已经可以看到 <code>QML</code> 相关内容。现阶段，组内正在使用 <code>QML</code> 开发 IM 需求。<br>组内技术栈转型是个很大挑战。所以，决定这么做是有前提的：</p><ul><li>对于博主来说，常规业务开发涉及的 QWidget 相关技术已没有任何挑战性；</li><li>对新技术的预研，有相当的成果：利用业余时间，博主使用 QML 把 QWidget 相关业务已实现 80%（低代码，且效果更好）。</li><li>组内成员对 <code>QWidget</code> 掌握程度没那么高，比如：<strong>QSS</strong> 很容易被滥用。</li></ul><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>QSS 就是 QWidget 会用到的样式表。只有 QWidget 会用到 QSS 。QML 是脚本语言啦，它依赖 Quick 提供的可视化组件。而 Item 系列的可视化组件是 JSEngine 负责渲染的。所以，QWidget 和 QuickItem 是属于两个完全不想干的领域（QObject 是唯一共性）。<br>以博主对 QSS 的认识，其大致可分为：</p><ul><li>CSS 部分: 仅限 2.0 版本。QSS 处于维护状态，应该永远支持不了 CSS3 了；</li><li>Subcontrol 部分：QWidget 独有，也是本文介绍的重点;</li><li>QProperty 部分：扩展样式表功能, 以达到出其不意的效果；</li></ul><h1 id="技术分析"><a href="#技术分析" class="headerlink" title="技术分析"></a>技术分析</h1><p>本节对以上文中的 CSS，Subcontrol 以及 QProperty 部分进行简要介绍。</p><h2 id="CSS-部分"><a href="#CSS-部分" class="headerlink" title="CSS 部分"></a>CSS 部分</h2><p>CSS 部分就不展开讨论了，也就那么点知识。博主在 <strong>DJI</strong> 就职时，负责开发的 Electron 桌面客户端涉及到大量的 CSS 技术。  </p><h2 id="Subcontrol-部分"><a href="#Subcontrol-部分" class="headerlink" title="Subcontrol 部分"></a>Subcontrol 部分</h2><p>玩转 QWidget 的重要组成部分。Subcontrol 依赖于 CSS 的 <strong>盒模型</strong> ，以控制子控件绘制的位置：Subcontrol-Origin, Subcontrol-position, 以及起到微调作用 Top 和 Left 属性。</p><ul><li>Subcontrol-Origin<br>subcontrol-origin 定义 children widget 在 parent widget 中绘制的包围盒，默认在 padding 的矩形中绘制。如下：<ul><li>subcontrol-origin: margin</li><li>subcontrol-origin: border</li><li>subcontrol-origin: padding</li><li>subcontrol-origin: content</li></ul></li><li>Subcontrol-Position<br>由 subcontrol-origin 定义了在 parent widget 上的绘制区域后，如：padding 包围区。那这么大的范围，具体绘制在哪里呢？ subcontrol-position 进一步限制绘制方向。<ul><li>subcontrol-origin: left</li><li>subcontrol-origin: right</li><li>subcontrol-origin: center</li><li>subcontrol-origin: top</li><li>subcontrol-origin: bottom</li></ul></li><li>Top &amp; Left<br>top 和 left 属性用于微调 subcontrol位置, 比如： 在 ::hover 和 ::pressed 状态时，通过微调达到视觉上的动画效果。</li></ul><h2 id="QProperty-部分"><a href="#QProperty-部分" class="headerlink" title="QProperty 部分"></a>QProperty 部分</h2><p>一个属性的行为就像一个类的数据成员，它有通过元对象系统访问的附加功能。本文仅介绍 QProperty 在 QSS 方面发挥的作用，也即各种 pseudo-classes，如：enabled, hover, pressed, checked。</p><p>但是呢，博主不打算介绍 Qt 在各个 QWidget 派生类中内置的各种状态属性。 本节仅举一例，来凸显 QProperty 在样式表功能扩展方面的能力。</p><p>对于 QCheckBox 控件，checked 状态 与 enabled 状态 存在交叉的场景，即：enable 和 disable 状态下，checked 样式需要具有不同的 UI 显示。这个时候，单凭 CSS 提供的能力是比较难办到的。借助于 Property 属性，我们可以通过几行简单的 QSS 语句就能对齐进行区分：</p><ul><li>QSS 配置<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">QCheckBox::disabled[check=true]&#123;image: <span class="hljs-string">&quot;qrc://cat.png&quot;</span>&#125;<br>QCheckBox::disabled[check=false]&#123;image: <span class="hljs-string">&quot;qrc://dog.png&quot;</span>&#125;<br></code></pre></td></tr></table></figure></li><li>Logic 控制<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">control-&gt;<span class="hljs-built_in">setProperty</span>(<span class="hljs-string">&quot;check&quot;</span>, <span class="hljs-literal">true</span>);<br>control-&gt;<span class="hljs-built_in">style</span>()-&gt;<span class="hljs-built_in">polish</span>();<br></code></pre></td></tr></table></figure></li></ul><h1 id="附记"><a href="#附记" class="headerlink" title="附记"></a>附记</h1><p>在上文中，我们看到 <code>style()-&gt;polish()</code>语句。本小节就附上一些心得：</p><ul><li>polish: 在程序运行时，QWidget 的样式发生变化需要配合 <code>polish</code> 才能生效；</li><li>updateGeometry: 当 QWidget 的 Size，Geometry 相关策略发生变化时，需要配合 <code>updateGeometry</code> 才能生效。比如：sizeHint 变化，maximumHeight 变化等；</li><li>update：当 UI 以任何形式变化时，有些情况会存在无法实时刷新，此时就需要配合 <code>update</code> 才能生效。比如：当 hover 状态下，通过修改 style-sheet 方式更改 QPushButton 的背景图片时。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>初探 QML 系列 -- 工程实践汇总（持续更新）</title>
    <link href="/2023/04/05/QML-Quick-framework/"/>
    <url>/2023/04/05/QML-Quick-framework/</url>
    
    <content type="html"><![CDATA[<h1 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a>一、预备知识</h1><p>Windows 支持两种类型的应用程序： GUI 程序和 CUI 程序。本文介绍的对象当然是 GUI 程序。Windows 应用程序必须有一个入口点函数，应用程序运行时，这个函数将被调用。C&#x2F;C++ 开发人员可以使用以下两种入口点函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Int WINAPI _tWinMain(<br>    HINSTANCE hInstanceExe,<br>    HINSTANCE,<br>    PTSTR pszCmdLine,<br>    <span class="hljs-type">int</span> nCmdShow);<br><br><span class="hljs-type">int</span> _tmain(<br>    <span class="hljs-type">int</span> argc,<br>    TCHAR *argv[],<br>    TCHAR *envp[]);<br></code></pre></td></tr></table></figure><p>实际上，操作系统并不调用我们所写入口点函数。相反，它会调用由 C&#x2F;C++ 运行库实现并在链接时使用 <strong>-entry:</strong> 命令行选项设置的一个 C&#x2F;C++ 运行时启动函数。<strong>这些</strong> 启动函数的用途简单总结如下：</p><ul><li>获取指向新进程的完整命令行的一个指针</li><li>获取指向新进程的环境变量的一个指针</li><li>初始化 C&#x2F;C++ 运行库的全局变量</li><li>初始化 C 运行库内存分配函数（ <strong>malloc</strong> 和 <strong>calloc</strong> ）以及其他底层 I&#x2F;O 例程使用的堆（heap）</li><li>调用所有全局和静态 C++ 类对象的构造函数</li></ul><p>完成所有这些初始化工作之后，C&#x2F;C++ 启动函数就会调用应用程序的入口点函数（后文简称 <code>main</code>）。一个精心设计的应用程序框架，会在 <code>main</code> 入口点做一些有条理的工作：</p><ul><li>解析命令行参数：判断运行目录，判断唤起方式，及其他业务</li><li>初始化环境：以共享内存的维护的单实例判断、日志系统初始化、多语言初始化、样式表初始化</li><li>初始化 UI：主窗口的初始化, 如：QMainWindow（qwidget）, Window（qml）</li><li>开启事件循环：阻塞型 exec 的执行，但不阻塞 <strong>交互</strong> 和 <strong>UI</strong> 。exec 可被其他事件循环暂时挂起，比如：模态对话框，<code>QEventLoop</code> 同步业务逻辑</li></ul><p>由于涉及知识点较广泛，本文仅从某一侧面梳理 quick 工程应有的模样。</p><h1 id="二、Qucik-工程调研"><a href="#二、Qucik-工程调研" class="headerlink" title="二、Qucik 工程调研"></a>二、Qucik 工程调研</h1><p><img src="/2023/04/05/QML-Quick-framework/qtquick_bp.png"></p><h1 id="三、Coding-规范及要求"><a href="#三、Coding-规范及要求" class="headerlink" title="三、Coding 规范及要求"></a>三、Coding 规范及要求</h1><p>对于采用 MVVM 框架的 QWidget 工程，嵌入 Quick UI 需要尽量保持：模块独立、链路清晰。</p><h2 id="1、协议命名规范"><a href="#1、协议命名规范" class="headerlink" title="1、协议命名规范"></a>1、协议命名规范</h2><ul><li>QML:<ul><li>事件请求：以 request 开头（requestXXX）</li><li>事件响应：以 Ack 结尾（XXXAck）</li></ul></li><li>Model:<ul><li>事件处理：不作限制，保持以往习惯</li><li>双向转发：<ul><li>QML to C++: 以 sig 开头， Req 结尾（sigXXXReq）</li><li>C++ to QML: 以 sig 开头， Ack 结尾（sigXXXAck）</li></ul></li></ul></li><li>Thread:<ul><li>Slots: 以 on 开头，Req 结尾（onXXXReq）</li></ul></li></ul><h2 id="2、QML-与-C-通信"><a href="#2、QML-与-C-通信" class="headerlink" title="2、QML 与 C++ 通信"></a>2、QML 与 C++ 通信</h2><p><img src="/2023/04/05/QML-Quick-framework/qml_cpp_comm.png"></p><h2 id="3、QML-与-C-线程划分"><a href="#3、QML-与-C-线程划分" class="headerlink" title="3、QML 与 C++ 线程划分"></a>3、QML 与 C++ 线程划分</h2><ul><li>模块接口描述<ul><li>QML CallBridge: QML 与 C++ 通信的媒介，属于 QWidget UI 线程<ul><li>requestXXX：用于 QML 内部发起请求，接口实际上只是触发一个事件（emit sigXXXReq）</li><li>XXXAck: 用于 QML 内部接收对应的事件，接口实际上用于响应 requestXXX， 可通过参数携带数据</li></ul></li><li>XXX Model: 常规 MVVM 框架中的 Model 层，属于 QWidget UI 线程<ul><li>XXX: 业务接口，用于 Http 请求服务端数据和状态</li><li>sigXXXReq: 用于中转事件请求，UI 线程 —-&gt; 非 UI 线程</li><li>sigXXXAck: 用于中转事件响应，非 UI 线程 —-&gt; UI 线程</li></ul></li><li>XXX Manager: 本质上属于 MVVM 框架中的 Model, 属于非 UI 线程。其主要用于数据相关业务的处理<ul><li>onXXXReq: 用于调用业务接口 XXX, 保证该接口、数据处理、回调等均在非 UI 线程处理</li></ul></li></ul></li><li>交互流程<br><img src="/2023/04/05/QML-Quick-framework/qml_cpp_thread.png"></li></ul>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>初探 QML 系列 -- 重构 QWidget 组件</title>
    <link href="/2023/03/28/QML-ImageSlider-Reconstruct/"/>
    <url>/2023/03/28/QML-ImageSlider-Reconstruct/</url>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>Qt 客户端开发入门容易，进阶难哦。举个例子：同事 A 开发耗时30d (15d 开发 + 15d 优化)，而且一堆烂代码。同事 B 开发耗时 3d 已达到最优化状态。虚线带人好难哦~~~<br><img src="/2023/03/28/QML-ImageSlider-Reconstruct/saodemo.gif"></p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p><strong>ImageSlider</strong> 组件涉及到的知识点比较广。因此，博主把一些需要强调的非组件知识放在 <strong>预备知识</strong> 环节。</p><h3 id="ImageProvider"><a href="#ImageProvider" class="headerlink" title="ImageProvider"></a>ImageProvider</h3><blockquote><p>The QQuickImageProvider class provides an interface for supporting pixmaps and threaded image requests in QML.<br>The QQuickAsyncImageProvider class provides an interface for asynchronous control of QML image request.  </p></blockquote><p>有官方定义可知，该类接口用户返回所需图片。至于图片从哪里来，完全由用户重载的接口实现决定：网络图片、本地图片、自定义图片。本文不再详细讲解接口使用方法（网上一大堆）。</p><h3 id="Object-Fit-Cover"><a href="#Object-Fit-Cover" class="headerlink" title="Object Fit: Cover"></a>Object Fit: Cover</h3><ul><li>definitions from <strong>CSS</strong><blockquote><p>The CSS object-fit property is used to specify how an <code>&lt;img&gt;</code> or <code>&lt;video&gt;</code> should be resized to fit its container.  </p></blockquote><ul><li>fill: the image is resized to fill the given dimension. if nessary, the image will be stretched or squished to fit</li><li>contain: the image keeps its aspect ratio, but is resized to fit within the given dimension</li><li><strong>cover</strong> : the image keeps its aspect ratio and fills the given dimension. The image will be clipped to fit</li><li>none: the image is not resized</li><li>scale-down: the image is scaled down to the smallest version of non or contain</li></ul></li><li>definitions from <strong>QML</strong><ul><li>Image.Stretch: the image is scaled to fit</li><li>Image.PreserveAspectFit: the image is scaled uniformly to fit without cropping</li><li><strong>Image.PreserveAspectCrop</strong> : the image is scaled uniformly to fill, cropping if nessary</li><li>Image.Tile：the image is duplicated horizontally and vertically</li><li>Image.TileVertically: the image is stretched horizontally and tiled vertically</li><li>Image.TileHorizontally: the image is stretched vertically and tiled horizontally</li><li>Image.Pad: the image is not transformed</li></ul></li><li>definitions from <strong>QWidget</strong><ul><li>Qt::IgnoreAspectRatio: the size is scaled freely. the aspect ratio is not preserved.</li><li>Qt::KeepAspectRatio: the size is scaled to a rectangle as large as possible inside a given rectangle, preserving the aspect ratio.</li><li>Qt::KeepAspectRatioByExpanding: the size is scaled to a rectangle as small as possible outside a given rectangle, preserving the aspect ratio.</li></ul></li></ul><p>通常，设计人员具备的是 Html 相关的技术术语：这也是该小节标题 <code>Cover</code>的由来。同时考虑到本系列与 Qt 强相关，所以同时把 QWidget 和 QML 中相关定义也拿来做对比。</p><h3 id="GraphicalEffects"><a href="#GraphicalEffects" class="headerlink" title="GraphicalEffects"></a>GraphicalEffects</h3><ul><li>LinearGradient<blockquote><p>Linear gradients interpolate colors between start and end points in Shape items. Outside these points the gradient is either padded, reflected or repeated depending on the spread type.</p></blockquote></li><li>OpacityMask<br>与 <code>layer.effect</code> 结合，可用于控制区域的可见区域：圆角矩形、椭圆、原型等。</li></ul><p>由于 Qt6 不再支持 QtGraphicalEffects 相关功能。使用 Qt6 时，需导入 <code>import Qt5Compat.GraphicalEffects</code>；使用 Qt5 时，需导入 <code>import QtGraphicalEffects 1.15</code>。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>QML 预研的出发点是：解决问题, 个人能力成长。 解决问题为先，所以博主把项目中最难啃的组件 ImageSlider 放在 QML 重构系列的第一篇。需要解决问题如下：</p><ul><li>组件圆角问题：需要对容器施加圆角，需要用到 <strong>预备知识</strong> 中提及的 <code>OpcityMask</code> 组件</li><li>圆角锯齿问题：需要考虑屏幕 dpi 的影响</li><li>填充模式问题：即 <strong>预备知识</strong> 中提及的 <code>Cover</code> 模式</li><li>琐碎样式问题：渐变、Indicator 等</li></ul><p>注：QWidget 也能解决上述问题，只是同事已经投入过多工时。赶上好时候，看看 QML 是否更好用。</p><h1 id="组件拆解"><a href="#组件拆解" class="headerlink" title="组件拆解"></a>组件拆解</h1><p>根据背景介绍的 GIF 动画，可以把组件拆解为如下几个部分：</p><ul><li>容器圆角：全局控制整个组件外观，即：8px 圆角</li><li>渐变区域：水平渐变。当鼠标移入组件内部时，两侧出现 80px 宽度的可交互区域</li><li>指示器：水平居中排列。当鼠标移入时，可切换至指示器对应的画面</li><li><del>图片显示：SwipeView 官方组件：提供可视化，可交互区域</del></li><li>图片加载与更新： Repeater 官方组件：通过 <code>model</code> 和 <code>delegate</code> 属性绑定，实时按需更新和加载数据</li></ul><h1 id="功能实现："><a href="#功能实现：" class="headerlink" title="功能实现："></a>功能实现：</h1><p>本节不作描述，直接给出比较难实现的局部功能。</p><ul><li><p><strong>容器圆角</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">QtGraphicalEffects</span> <span class="hljs-number">1.15</span>         <span class="hljs-comment">// Qt5</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Qt5Compat</span>.<span class="hljs-property">GraphicalEffects</span>      <span class="hljs-comment">// Qt6</span><br><br><span class="hljs-title class_">UserComponent</span>.<span class="hljs-property">SlideView</span>&#123;               <span class="hljs-comment">// this is the user-defined ImageSlider</span><br>    <span class="hljs-attr">id</span>: slider<br><br>    <span class="hljs-title class_">Layout</span>.<span class="hljs-property">alignment</span>: ...<br>    <span class="hljs-title class_">Layout</span>.<span class="hljs-property">minimumWidth</span>: ...<br>    <span class="hljs-title class_">Layout</span>.<span class="hljs-property">minimumHeight</span>: ...<br><br>    <span class="hljs-comment">// control the rounded area</span><br>    layer.<span class="hljs-property">enabled</span>: <span class="hljs-literal">true</span><br>    layer.<span class="hljs-property">effect</span>: <span class="hljs-title class_">OpacityMask</span>&#123;<br>        <span class="hljs-attr">maskSource</span>: mask<br>    &#125;<br><br>    <span class="hljs-title class_">Rectangle</span>&#123;<br>        <span class="hljs-attr">id</span>: mask<br>        <span class="hljs-attr">width</span>: parent.<span class="hljs-property">width</span><br>        <span class="hljs-attr">height</span>: parent.<span class="hljs-property">height</span><br>        <span class="hljs-attr">radius</span>: <span class="hljs-number">8</span><br>        <span class="hljs-attr">visible</span>: <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>侧边区域</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">QtGraphicalEffects</span> <span class="hljs-number">1.15</span>        <span class="hljs-comment">// Qt5</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Qt5Compat</span>.<span class="hljs-property">GraphicalEffects</span>     <span class="hljs-comment">// Qt6</span><br><br><span class="hljs-title class_">Rectangle</span>&#123;<span class="hljs-comment">// linear gradient area</span><br>    <span class="hljs-attr">id</span>: leftarea                      <br>    <span class="hljs-attr">z</span>: <span class="hljs-number">1</span>                              <span class="hljs-comment">// topest</span><br>    anchors.<span class="hljs-property">left</span>: parent.<span class="hljs-property">left</span><br>    anchors.<span class="hljs-property">verticalCenter</span>: parent.<span class="hljs-property">verticalCenter</span><br>    <span class="hljs-attr">width</span>: <span class="hljs-number">80</span>                         <span class="hljs-comment">// 80px</span><br>    <span class="hljs-title class_">LinearGradient</span>&#123;<br>        anchors.<span class="hljs-property">fill</span>: parent<br>        <span class="hljs-attr">start</span>: <span class="hljs-title class_">Qt</span>.<span class="hljs-title function_">point</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>        <span class="hljs-attr">end</span>: <span class="hljs-title class_">Qt</span>.<span class="hljs-title function_">point</span>(parent.<span class="hljs-property">width</span>, <span class="hljs-number">0</span>)<br><br>        <span class="hljs-attr">gradient</span>: <span class="hljs-title class_">Gradient</span>&#123;<br>            <span class="hljs-title class_">GradientStop</span>&#123;<span class="hljs-attr">position</span>: <span class="hljs-number">0.0</span>; <span class="hljs-attr">color</span>: <span class="hljs-title class_">Qt</span>.<span class="hljs-title function_">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.3</span>)&#125;<br>            <span class="hljs-title class_">GradientStop</span>&#123;<span class="hljs-attr">position</span>: <span class="hljs-number">1.0</span>; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;transparent&quot;</span>&#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p><strong>指示器</strong>: Indicator</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">PageIndicator</span>&#123;<br>    <span class="hljs-attr">id</span>: indicator<br>    <span class="hljs-attr">count</span>: imgSwipe.<span class="hljs-property">count</span>              <span class="hljs-comment">// property binding</span><br>    <span class="hljs-attr">currentIndex</span>: imgSwipe.<span class="hljs-property">currentIndex</span><br>    <br>    anchors.<span class="hljs-property">bottom</span>: imgSwipe.<span class="hljs-property">bottom</span><br>    anchors.<span class="hljs-property">horizontalCenter</span>: parent.<span class="hljs-property">horizontalCenter</span><br><br>    <span class="hljs-attr">interactive</span>: <span class="hljs-literal">true</span><br><br>    <span class="hljs-attr">delegate</span>: <span class="hljs-title class_">Rectangle</span>&#123;<br>        <span class="hljs-attr">implicitWidth</span>: <span class="hljs-number">24</span><br>        <span class="hljs-attr">implicitHeight</span>: <span class="hljs-number">2</span><br><br>        <span class="hljs-attr">radius</span>: height / <span class="hljs-number">2</span>             <span class="hljs-comment">// notice here, max to half height</span><br>        <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;white&quot;</span><br>        <span class="hljs-attr">opacity</span>: index === indicator.<span class="hljs-property">currentIndex</span> ? <span class="hljs-number">1.0</span>: <span class="hljs-number">0.5</span><br><br>        <span class="hljs-title class_">Behavior</span> on opcity&#123;<br>            <span class="hljs-title class_">OpacityAnimator</span>&#123;<br>                <span class="hljs-attr">duration</span>: <span class="hljs-number">100</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-title class_">MouseArea</span>&#123;<br>            <span class="hljs-attr">hoverEnabled</span>: <span class="hljs-literal">true</span><br>            anchors.<span class="hljs-property">fill</span>: parent<br>            <span class="hljs-attr">onEntered</span>: &#123;<br>                ...<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>图片加载与更新</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Repeater</span>&#123;<br>    <span class="hljs-attr">model</span>: sliderData.<span class="hljs-property">length</span>            <span class="hljs-comment">// sliderData: user-defined property expose to c++</span><br>    <span class="hljs-attr">delegate</span>: <span class="hljs-title class_">Rectangle</span>&#123;<br>        <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;transparent&quot;</span><br>        <span class="hljs-title class_">Image</span>&#123;<br>            anchors.<span class="hljs-property">fill</span>: parent<br>            <span class="hljs-attr">source</span>: <span class="hljs-string">&quot;image://netimgprovider&quot;</span> + sliderData[index]<br>            sourceSize.<span class="hljs-property">height</span>: parent.<span class="hljs-property">height</span><br>            sourceSize.<span class="hljs-property">width</span>: parent.<span class="hljs-property">width</span><br>            <span class="hljs-attr">fillMode</span>: <span class="hljs-title class_">Image</span>.<span class="hljs-property">PreserveAspectCrop</span>          <span class="hljs-comment">// Cover mode</span><br><br>            <span class="hljs-attr">cache</span>: <span class="hljs-literal">true</span><br>        &#125;<br><br>        <span class="hljs-title class_">MouseArea</span>&#123;<br>            anchors.<span class="hljs-property">fill</span>: parent<br>            <span class="hljs-attr">hoverEnabled</span>: <span class="hljs-literal">true</span><br>            <span class="hljs-attr">onExited</span>: &#123;<br>                <span class="hljs-comment">// control linear gradient area to hide</span><br>            &#125;<br>            <span class="hljs-attr">onEntered</span>:&#123;<br>                <span class="hljs-comment">// ... to show</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="附记"><a href="#附记" class="headerlink" title="附记"></a>附记</h1><p>此系列文章专注于 UI 及交互实现，会忽略数据加载和处理部分的细节，如：”image:&#x2F;&#x2F;netimgprovider” 是预备知识中 <code>ImageProvider</code> 专用匹配模式。感兴趣可查看 Qt Assistant~</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>初探 QML 系列 -- 规划</title>
    <link href="/2023/03/22/QML-Series-OpenTopic/"/>
    <url>/2023/03/22/QML-Series-OpenTopic/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于桌面软件开发，常用的 UI 库包括：MFC、 QT、 wxWidget、FLTK 等。如果项目立项初期选择 Qt 的话，有两个大的方向可供选择：QWidget, QML。 在性能方面，两者基本上没有太大差距。 但对于 C++ 开发人员，两种选择都有不小的挑战。对于桌面 App 涉及到的技术点，博主将其分为两类：<strong>布局系统</strong> 和 <strong>其它</strong> 。 </p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>对比 QWidget 和 QML 的布局方式，以对 QT 开发中不可避免的 UI 开发具有基本认识。</p><ul><li>QWidget: 相对布局和绝对布局 <ul><li>相对布局：Layout相关，Alignment相关，Stretch相关，WindowType相关</li><li>绝对布局：一个良好设计的 Qt 桌面应用程序，会有 15% 左右的 UI 及交互会通过绝对定位的方式实现</li></ul></li><li>QML: 更高层次的抽象。结合相关技术，QML 将庞大的布局系统大致分为：<ul><li>绝对定位：同 QWidget 中的绝对布局。</li><li>坐标绑定：相对于绝对定位，增加了动态绑定的功能（性能成本）</li><li>锚定位：在各种渲染引擎的 UI 开发中，这种方式被称为 <strong>锚点</strong> 或 <strong>锚框</strong> 。博主有两年的 Unity 引擎开发经验~</li><li>定位器：通常用于排列，有：Column，Flow，Grid，Row 等</li><li>布局管理器：相对于定位器，它可以进行更细致的控制。包括：ColumnLayout，GridLayout，RowLayout，StackLayout 等</li></ul></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>目前，博主负责的项目是使用 QWidget，兼顾整理组内的技术积累：<strong>生硬</strong> 的布局；<strong>东拼西凑</strong> 的 UI 还原；</p><h4 id="为什么不使用-QML"><a href="#为什么不使用-QML" class="headerlink" title="为什么不使用 QML?"></a>为什么不使用 QML?</h4><p>答案是：资源组内的同学都没有接触过 QML，更没有接触过 QML 强依赖的 JavaScript 脚本语言。</p><h4 id="为什么选择写-QML-系列？"><a href="#为什么选择写-QML-系列？" class="headerlink" title="为什么选择写 QML 系列？"></a>为什么选择写 QML 系列？</h4><ul><li>个人原因<ul><li>记录学习过程，保证进度和质量</li><li>推进组内进度，争取尽快替换现有的 QWidget 技术栈：QWidget 容易被滥用，博主有时也是有心无力~</li></ul></li><li>其它原因<ul><li>由于业务需求的增长及其它原因，资源组规模越来越大。这么大的资源组，总要有一些新技术的积累。</li><li>对于一些 C++ 开发人员来说， 企业级（像素级）的 QWidget 开发比较难, 且不好约束。</li><li>相对来说，QML 更能做到前后端分离，更能提高开发效率（如果同时掌握 QWidget 和掌握 QML，QML 开发能节省 50% 以上的开发时间）</li></ul></li></ul><h1 id="系列规划"><a href="#系列规划" class="headerlink" title="系列规划"></a>系列规划</h1><p>事实上，博主利用周末和空闲时间已经做了些准备工作，且初具成效。后续会针对现有项目开发过程中遇到的未解问题，使用 QML 逐个攻破。近期安排如下：</p><h4 id="像素级还原-重构-系列"><a href="#像素级还原-重构-系列" class="headerlink" title="像素级还原(重构)系列"></a>像素级还原(重构)系列</h4><p>当你看到这篇文章时，该系列进度已经完成了 60%。至于详细的技术讲解，会有相应的文章陆续放出~</p><ul><li>重构 <code>QWidget</code> 组件： <code>ImageSlider</code><br><code>ImageSlider</code> 组件经过先后两次的重构后，仍没有解决已知问题。记得，最近一次重构耗时 2w，但实现不尽如人意。</li><li>重构 <code>QWidget</code> 组件： <code>TitleDock</code><br><code>TitleDock</code> 组件的布局 <strong>生硬</strong> ，导致功能扩展受限。随着需求的增长，它的问题越来越严重。</li><li>重构 <code>QWidget</code> 组件： <code>Size-Adaptable Area</code><br>博主实现的 <code>Adaptable Area</code> 组件本身没有什么问题。在项目中，这种组件应用十分广泛.</li><li>…</li></ul><h4 id="专项攻破系列"><a href="#专项攻破系列" class="headerlink" title="专项攻破系列"></a>专项攻破系列</h4><ul><li>QML 数据处理：Model, Delegate</li><li>Quick 框架设计：MVVM 设计模式</li><li>…</li></ul>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>[杂项] AR -- 前后景处理</title>
    <link href="/2023/03/22/AR-FrontAndRearScene-Overview/"/>
    <url>/2023/03/22/AR-FrontAndRearScene-Overview/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文着重梳理两年来博主在 AR 直播领域（渲染、推流、数据处理）的技术积累. 由下文的预备知识可知, 其中的每项都可以作为单独的专题展开讲解. 碍于全职工作, 近期不可能对所有的内容展开详尽讨论. 为避免遗忘这些宝贵的经验和方法, 才有了这篇文章.</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="GPU-流水线"><a href="#GPU-流水线" class="headerlink" title="GPU 流水线"></a>GPU 流水线</h2><ul><li>顶点数据: 模型通常由三角面 (或四边面) 组成. 在 GPU 渲染流程中，三角面片的顶点数据则是顶点着色器的输入，包括：位置, 法线, 切线, N 个纹理坐标以及颜色<ul><li>坐标系: 空间位置都是相对的.<br>  日常技术沟通时，我们常说：A 坐标系在 B 坐标系下的表示; 点在某个坐标系下的表示;<ul><li>A 类： 左手系, 右手系</li><li>B 类：模型坐标系, 相机坐标系, 世界坐标系</li></ul></li></ul></li><li>集合阶段: <ul><li><strong>顶点着色器</strong>: 顶点&#x2F;片元着色器的第一个函数<ul><li>必要动作：完成顶点坐标从模型空间转换到齐次裁剪空间(<code>mul(UNITY_MVP, v.position)</code>)</li><li>应用: 顶点动画, 低质量光照计算</li></ul></li><li>曲面细分着色器: 可忽略哈, 99.9% 的技美不会接触到这里</li><li>集合着色器: 同上可忽略, 如果感兴趣 google 一下</li><li><strong>裁剪</strong>: 至关重要, 跟投影矩阵直接相关(正交投影, 透视投影)</li><li><strong>屏幕映射</strong>: 至关重要, 3D –&gt; 2D</li></ul></li><li>光栅化阶段<ul><li>三角形设置: 固定函数阶段</li><li>三角形遍历: 固定函数阶段</li><li>片元着色器: 进行逐片元的着色操作. 顶点&#x2F;片元着色器的第二个函数</li><li>逐片元操作: 主要完成颜色, 深度缓冲, 混合等操作. 非可编程阶段, 开发人员 <strong>不可直接介入</strong></li></ul></li><li>屏幕图像</li></ul><h2 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h2><ul><li>Shading Language: 列出几种常见的高级语言—可视为 <strong>中间语言</strong> (Intermediate Language, IL). 这里的高级是相对于汇编语言来讲的, 并不是像 C# 相对于 C 的高级那种.<ul><li>HLSL: DirectX 专用</li><li>GLSL: OpenGL 专用</li><li>CG: NVIDA 专用, 也即 <code>C for Graphic</code>. 在单个 <code>Pass</code> 通道, C 风格的代码通常被包围在 <code>CGPROGRAM</code> 和 <code>ENDCG</code> 之间。</li></ul></li><li>Unity Shader: Unity 开发中, 有三种形式来编写 Unity Shader<ul><li>表面着色器 (Surface Shader): 噢噢噢噢，Unity 的宠儿. 使用这种着色器, 开发人员无需过多关注光照的处理细节</li><li>顶点&#x2F;片元着色器 (Vertex&#x2F;Fragment Shader): 更加复杂, 灵活度更高. 博主全权负责开发的 AR 直播项目 100% 采用这种形式</li><li>固定函数着色器 (Fixed Function Shader): 已经被抛弃, 也可以稍稍了解下</li></ul></li></ul><h2 id="3D-空间变换-投影，坐标变换"><a href="#3D-空间变换-投影，坐标变换" class="headerlink" title="3D 空间变换: 投影，坐标变换"></a>3D 空间变换: 投影，坐标变换</h2><ul><li>坐标投影: 也即 3D —&gt; 2D, 从世界坐标系 —&gt; 投影平面的变换<ul><li>坐标变换: 依赖相机外参进行世界坐标到相机坐标的变换; 依赖内参进行进一步到投影平面的操作<ul><li>相机外参: 世界坐标系到相机坐标系的变换 (<strong>必须</strong>)</li><li>相机内参: 进一步变换到投影屏幕 (<strong>可选</strong>) (物理相机的畸变在大多数情况下可忽略, 但直播画面必须要进行处理)</li></ul></li><li>3D 点投影: 即消除系数 <code>Z</code> 的作用 (透视投影下, 平行线会在无穷远处相交. <code>Z</code> 可理解为深度信息或距离)<ul><li>齐次坐标系: <code>pos_2d = world2Proj * pos_3d</code></li><li>笛卡尔坐标系: <code>pos_2d = pos_2d / pos_2d.z</code></li></ul></li></ul></li></ul><h2 id="3D-模型：点云处理-模型拼接"><a href="#3D-模型：点云处理-模型拼接" class="headerlink" title="3D 模型：点云处理, 模型拼接"></a>3D 模型：点云处理, 模型拼接</h2><p>AR 字面义为 <strong>增强现实</strong>. 说白了, AR 也就是在现实世界的基础上增加些 <strong>点缀</strong>. 点缀容易, 但要点缀地恰到好处：</p><ul><li>视觉上: 让用户感到 <strong>恰到好处</strong>, 也即视野范围内的径向位置合适, 径向深度合适</li><li>听觉上：让用户感受到那种 <strong>由远及近的鸣笛声</strong></li></ul><p>本文重点讲解视觉上的效果处理 (后续有机会的话, 再对声音的多普勒效应模拟展开介绍). AR 增强现实要做到上述的效果, 离不开对现实世界的 <strong>建模</strong> 和 <strong>标定</strong>. 对于不同的 AR 应用, 建模的方式有多种. 拿 LPL 直播效果, 盲猜他们会选择如下几种方式 (或者完全不需要, LPL 不需要对整个直播场地毫无遗漏的高精度要求)</p><ul><li>点云扫描：扫描精度不够, 尤其是边角处. 需要专业人员对从点云的导出模型进行修模 (如: 减面), 否侧很容易到达数百万顶点的模型文件</li><li>设计模型：过于理想, 现场搭建的场地往往是组装起来的. 而组装的精度跟施工人员专业程度, 场地大小强相关</li><li>设计模型拼接：相对比较节省人力, 节省时间的方式. 它的精度足够满足 AR 呈现的需求<ul><li>设计模型分块：按照实际场地的组装形式，对整体的设计模型进行拆分.</li><li>场地标定：对搭建后的场地, 按需进行坐标点标定</li><li>模型拼接：需要专用的模型拼接软件进行拼接. 作为当年的预研项, 博主当时耗时三周完成了基本功能的开发<ul><li>模型动态导入: <a href="https://ricardoreis.net/trilib-a-unity-3d-file-loader-asset/">插件</a>可用, 很好用<ul><li>模型缩放问题：可选缩放系数</li><li>模型材质问题：需要遍历所有的 <code>material</code>, 有些模型会存在 submesh 的情况</li></ul></li><li>模型拼接并导出: Unity 官方插件可用, 依赖于 Editor 模式<ul><li>模型缩放问题：100:1 的问题</li><li>模型格式问题：导入和导出的格式会涉及 fbx, obj, 因为我们是需要给模型贴图的. 某些情况下会生成光秃秃的模型哈哈哈哈</li></ul></li><li>模型点拾取: 实际上拾取的是三角面, 然后计算出距离拾取点最近的模型顶点. 注: 会存在多个三角面共点的情况</li><li>刚体变换: 奇异值求解 T44 坐标变换矩阵; 然后对模型施加相应分量的旋转、平移、缩放. 不难哈哈哈哈</li></ul></li></ul></li></ul><h2 id="相机内外参"><a href="#相机内外参" class="headerlink" title="相机内外参"></a>相机内外参</h2><p>内外参完全描述了物理相机的所有信息, 包括：相对于世界坐标系的变换, 相机的物理参数</p><ul><li>外参: 描述了相机的 <strong>位姿</strong> 信息, 包括：旋转参数, 平移参数. 旋转通常由 <strong>Euler</strong> 角描述, 可表示为 (qx, qy, qz, qw) </li><li>内参: 描述了相机的 <strong>畸变</strong> 和相机参数信息, 包括: 内参矩阵, 畸变系数 <ul><li>内参系数: fx, fy, cx, cy</li><li>畸变系数: 径向畸变, 切向畸变<ul><li>径向畸变: 来自透镜形状不规则及建模方式, 导致镜头不同区域焦距不同. 光线远离透镜中心的地方偏折更大 (枕型畸变) 或更小 (桶形畸变). 通常由 k1, k2, k3 表示</li><li>切向畸变：来自整个相机的组装过程. 由于透镜制造上的缺陷, 使得透镜本身与图像平面不平行而产生的 通常由 p1, p2 表示</li></ul></li></ul></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>AR 呈现 (或者是 AR 直播) 本质上是多张纹理 (或者图片) 的叠加 (<code>Blend</code> 指令, <code>Blit</code> 函数, <code>lerp</code> 插值函数). 这些纹理可分为: 底图 (UYVY422), UI 层 (BGRA), 特效层1, 特效层2, 特效层3 等</p><ul><li><strong>最上层</strong> (UI 层): 常驻元素不随机位变化, 包括：2D UI, 2D 动画等</li><li><strong>中间层</strong> (特效层): 各种类型的特效, 这里的特效层划分不是随意定的哦.  前文所述的恰到好处的 <strong>点缀</strong> 侧重在深度上的体现, 而不同类型的特效在深度上会受到不同类型的 <strong>遮挡</strong>. 按遮挡需求, 很容易对不同类型的特效进行划分. 就拿 <strong>某某</strong> 赛事直播来说, 可进行如下划分<ul><li>UI 层: 是的, 就其呈现形式来讲, 有些 UI (依赖于相机视角, 所属物体的状态) 是要归类为特效</li><li>移动拖尾效果: 根据实时位置, 对粒子进行持续移动即可形成连续的轨迹. 实现方式有：ParticleSystem, TrailRender</li><li>粒子效果: 本质上是 2D 精灵, 借助于<a href="https://assetstore.unity.com/packages/tools/particles-effects/spritetoparticles-69765">插件</a>将其转换为具有 3D 效果的粒子特效</li></ul></li><li><strong>最底层</strong> (物理相机输出的底图): 物理相机无法避免会存在各种前述畸变.<ul><li>对上述特效层添加畸变效果, 以使特效跟底图完全吻合 (此时存在畸变)</li><li>对叠加后的畸变输出, 进行裁剪 (通常表现为四周存在黑边, 因此需要先裁剪后缩放至原始尺寸)</li></ul></li></ul><p>对于本文要介绍的前后景关, AR 呈现效果只是最后的表现. 而背后却需要硬件, 算法, 系统框架, 设计, 程序的支撑. 接下来将以 <strong>某某</strong> 直播为例, 简要概括前后景处理中涉及到的关键技术点 (注: 不涉及通用解决方案, 仅关注突破点)</p><ul><li>场地(官方场景): 针对场地, AR 要做的事情就是要进行场地对齐: 现实世界与虚拟世界的完全对齐. 然后, 对齐 (标定) 并不是本文的重点. 现在我们更关注如何提高虚拟世界的 <strong>精度</strong>.</li><li>道具(官方设备): 道具没有场地的固定位置, 但相对于玩家来说, 道具会在很长一段时间内具有固定的位置 (参数). 这就是对道具的定义, 针对不同的应用场景完全可以换个名词. 现在我们就关注世界坐标系到屏幕图像的 <strong>映射</strong> 及相关处理.</li><li>玩家(赛队机器人)：在 AR 直播领域, 玩家的深度处理相关比较复杂 (游戏的纯虚拟世界无法与其相提并论). 现在我们关注玩家与特效的前后景 <strong>互动</strong></li></ul><h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><p>本节开门见山, 直接针对简介中提出的三点作出相应的描述</p><ul><li><strong>场地精度</strong>: 由 <strong>预备知识</strong> 中对于 <strong>3D 模型</strong> 重点描述可知, <strong>模型拼接</strong> 可以相对提高对 AR 建模的精度</li><li><strong>道具映射</strong>: 涉及到 <strong>预备知识</strong> 中的 <strong>3D 空间变换</strong> 和 <strong>相机内外参</strong> 【前面的长篇陈述, 没有一句话是多余的】</li><li><strong>玩家互动</strong>: 涉及到玩家 <strong>Mask</strong> 不规则区域, 玩家的 <strong>3D 位置</strong></li></ul><h1 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h1><p>包括模型拼接，坐标映射，以及玩家互动。</p><h2 id="模型拼接"><a href="#模型拼接" class="headerlink" title="模型拼接"></a>模型拼接</h2><p>有很多前置条件不在本文讲解范围，后续有机会再分享。</p><ul><li><strong>模型分割</strong> ：即对整体的设计模型, 按照施工人员的组装方式进行分割。 这部分工作由相应的设计人员来完成, 但需要我们提出几点技术要求：<ul><li>坐标系: 统一为 AR 系统中采用的 <strong>左手系</strong> 或者 __右手系__。 <strong>预备知识</strong> 中对 <strong>GPU 流水线</strong> 的描述中有提及</li><li>坐标零点: 尽量保持处于模型的集合中心, 这样方便用户交互 (基于坐标零点)</li><li>模型缩放: 根据最终使用模型的引擎工具, 要对模型进行相应的缩放。比如： Unity 中导入的模型会存在 100:1 的关系</li><li>模型贴图：这点对于具有对称性的 AR 场地比较重要</li><li>模型减面: 比如, 可以在 Blender 中对模型添加 <code>Decimate Modifier</code>, 对不可见细节进行减面处理</li></ul></li><li><strong>模型动态导入</strong> ：Unity 开发中， 可以借助付费插件 <a href="https://assetstore.unity.com/packages/tools/modeling/trilib-2-model-loading-package-157548">Trilib</a> 来完成</li><li><strong>模型点拾取</strong> ：涉及到 <strong>3渲2</strong> 或 <strong>OSR</strong> ，即：用户看到的永远是 2D 图片, 用户的交互会被投影到不可见的 3D 场景</li><li><strong>模型定位</strong> ：即根据现实世界中测量的模型位置 (至少有 3 个不共面的模型顶点), 求解拾取点所需要的变换操作<ul><li>刚体变换求解：<ul><li>平移：消除偏移对拾取点的影响。如果模型本身的原点处于集合中心，则无需本步操作</li><li>旋转：通过奇异值分解的方式，计算 <strong>模型坐标系</strong> 下拾取点到 <strong>世界坐标系</strong> 下的标定点的旋转矩阵（3X3）</li><li>变换矩阵：通过前两步参数，得到 T44 变换矩阵</li></ul></li><li>施加变换：对于 Unity 开发，也就1个接口的调用而已</li></ul></li><li><strong>模型拼接并导出</strong> ：依赖于 Unity 官方插件 以及 Editor 模式。注意导出模型存在 <code>SubMesh</code> 的情况</li></ul><h2 id="坐标映射"><a href="#坐标映射" class="headerlink" title="坐标映射"></a>坐标映射</h2><p>官方设备外形固定且位姿参数相对稳定。针对这种情况，通常将它们的物理属性以配置参数的形式介入前端渲染流程：通过 <strong>3D 投影</strong> 可在二维成像平面的 <strong>裁剪</strong> 区域形成 <strong>BoundingBox</strong> ，再根据径向深度就可对 <strong>BoundingBox</strong> 内的像素点进行剔除 （<code>Clip</code>）。 从而，产生视觉上的视觉差：<em>特效被遮挡了</em>  </p><ul><li><strong>BoundingBox</strong> 意义: 矩形框。由 3D 空间中的测量点 (标定点)，根据当前相机的内外参进行成像平面的实时投影。 内外参包括相机的 <code>Focus</code>, <code>Zoom</code>, <code>Eular Angle</code>, 而这几个参数跟相机动态变化的姿态和视野范围强相关。因此，需要进行实时投影。  </li><li>变换步骤：世界坐标系 –&gt; 相机坐标系 –&gt; 2D投影<ul><li>生成包围体：可选六棱柱，可根据需要测量点（没必要）</li><li>投影：世界坐标系到 2D 投影<ul><li>数据准备：<ul><li>外参矩阵（View2World）： 相机外参，即旋转，平移。 Unity 接口为 Matrix4x4::SetTRS()</li><li>内参矩阵（View2Proj）: 相机内参，即 fx, fy, cx, cy</li></ul></li><li>实施变换：有两种方式供选：可实现算法接口，也可直接调用 Opencv 接口<ul><li><strong>自定义接口</strong> ：<ul><li>求解 world2Proj 矩阵： world2Proj &#x3D; view2Proj * world2View</li><li>进行 3D 点投影：<ul><li>齐次坐标系：pos_2d &#x3D; worldProj * pos_3d</li><li>笛卡尔坐标系：pos_2d &#x3D; pos_2d &#x2F; pos2d.z</li></ul></li><li>计算 BoundingBox: 从六棱柱对应的 12 个投影后的 2D 坐标中，选出最小包围盒</li></ul></li><li><strong>Opencv 接口</strong> ：<ul><li>接口介绍：<ul><li>Calib3D.Rogdrigues: 依赖 <strong>外参矩阵</strong> ，计算 <strong>旋转向量</strong></li><li>Calib3D.projectPoints: 依赖 <strong>旋转向量</strong> ，<strong>平移向量</strong> ，<strong>内参矩阵</strong> ，__畸变系数__（可选），计算投影点</li><li>Imgproc.boundingRect: 计算包围盒</li></ul></li><li>步骤：<ul><li>平移向量：取自 T44 矩阵的最后一列，即平移参数</li><li>旋转向量：通过 Rodrigues 计算出旋转向量</li><li>3D 投影：通过 projectPoints 直接投影</li><li>BoundingBox：通过 Imgproc.boundingRect 计算出投影点的最小包围盒</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="玩家互动"><a href="#玩家互动" class="headerlink" title="玩家互动:"></a>玩家互动:</h2><p>指真实世界中的 <em>玩家</em> 跟虚拟世界中特效的相互干涉。这里的互动涉及两个层面：屏幕投影，前后关系</p><ul><li><strong>不规则 Mask</strong> ：玩家不规则投影在相机可见范围的联通区。这些知识需要大量数据，来对模型训练已提供识别准确性。机器学习不在我的能力范围，故这里仅作简要介绍。<ul><li>数据传输：可以将场地上所有玩家的联通区，以 alpha 通道的形式跟底图一起传递给引擎</li><li>应用：根据不同玩家的联通区在 1080p 图片的位置，可以实时生成 中间层特效（UI 层）用于描述当前玩家的状态，如：血量，Buff, 等级等</li></ul></li><li><strong>径向深度</strong> : 借助于 <strong>Mask</strong> 联通区，可以深度信息实时判断当前像素点与对应玩家的前后关系。若玩家深度大小当前特效像素点的深度，则保留特效；若玩家深度小于当前像素点深度，则特效被剔除（Clip）。</li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>本文仅对 AR 直播中深度处理及相关技术作简要介绍，暂未涉及 Coding 相关的技术和性能要求。后续大致会对本文进行拆解，并增加以下专题：</p><ul><li>直播推流：硬件及方案选型，包括：BMD硬件采集卡，NDI 设备，本地局域网内传输方案等。 这里提及的推流追求最小延时和最少丢帧，不涉及通常所说的编解码工作。</li><li>AR 前端渲染：以往经历使用的是 Unity 引擎。 为向行业内的解决方案靠拢，后续会使用 Unreal 实现所有的技术点【手头没有 1 行代码】</li><li>AR 后端系统：后续会使用 Qt 再现最小直播系统：包括视频采集，数据对齐，NDI输出等功能【依赖天价设备和算法支撑，只能模拟最小系统】</li></ul>]]></content>
    
    
    <categories>
      
      <category>AR</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>[杂项] CEF3 -- IME Behavior</title>
    <link href="/2023/03/08/QCef-Ime-JSInject/"/>
    <url>/2023/03/08/QCef-Ime-JSInject/</url>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><ul><li><strong>Communications</strong> : between host and web<ul><li><a href="https://www.electronjs.org/docs/latest/tutorial/tutorial-preload"><strong>Preloading</strong></a>: supported by Electron only<blockquote><p>Preload scripts are injected <strong>BEFORE</strong> a web page loads in the renderer, similar to a Chrome extension’s content scripts. To add features to your renderer that require privileged access, you can define global objects through the contentBridge API.</p></blockquote><ul><li><strong>Guard current context</strong>: Embedding google login or facebook login page, for example, we need to isolate their content (global setting, global variables etc.). Otherwise, we may encounter various error info, for example, jquery related error or something else. And <code>Preload</code> is the only way to taskle this situation.</li></ul></li><li><a href="https://cefview.github.io/QCefView/zh/docs/reference/QCefView"><strong>Execute Javascript</strong></a>: supported by almost all framework<blockquote><p>Executes javascript code in specified frame at any time.</p></blockquote><ul><li><strong>Inject JS Code</strong>: In this way, we usually do something to adjust user interface, or fix some irregular behavior in our host. For example, constraint user to type chinese, japanese to <strong>INPUT</strong>, and this is the only way to fix this in OSR mode.</li></ul></li></ul></li><li><strong>Html</strong> :  <code>&lt;input/&gt;</code> event related<ul><li>Enter:<ul><li><code>keydown</code> -&gt; <code>keypress</code> -&gt; <code>change</code> -&gt; <code>keyup</code></li></ul></li><li>Alphabet: <ul><li><code>keydown</code> -&gt; <code>keypress</code> -&gt; <code>change</code> -&gt; <code>keyup</code></li></ul></li><li>Ime:<ul><li><code>compositionstart</code> -&gt; <code>compositionupdate</code> -&gt; <code>input</code> -&gt; … -&gt; <code>input</code> -&gt; <code>compositionend</code></li></ul></li><li>Ime: filter in <code>input</code> event<ul><li><code>compositionstart</code> -&gt; <code>compositionupdate</code> -&gt; <code>input</code> -&gt; … -&gt; <code>input</code> -&gt; <code>compositionend</code></li></ul></li></ul></li><li><strong>CEF</strong> : develop tools<ul><li>Mode:<ul><li>Popup Window: this is the only effective way if <strong>OSR</strong> enabled</li><li>Child Window: like all other browsers’ default behavior</li><li>Windowless: off-screen rendering</li></ul></li><li>Prerequisite:<ul><li>OnPreKeyEvent:<ul><li>CefViewBrowserClient: from CefViewBrowserClient_KeyboardHandler</li><li>CCefClientDelegate: from CCefCientDelegate_KeyboardHandler</li></ul></li></ul></li></ul></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>桌面端嵌入类 <code>webview</code> 的产品十分常见(开发周期极短, 开箱即用). 从某种程度上来讲，桌面软件扮演了浏览器的角色。对于常规 web 页面, 浏览器的行为在这种 Hybrid 模式的桌面软件中必定发生不符合预期的表现:  </p><ul><li>登录注册:<ul><li>Fackbook: 需要保证相对纯净的 jquery 上下文, 才能正常走完登录的流程</li><li>Google: 需要伪造合法的 User Agent, 才能通过页面的验证</li></ul></li><li>输入法: only <strong>IME</strong> introduced<ul><li>联想相关: 联想框弹出位置问题</li><li>IME: 中文输入法问题<ul><li>IE 浏览器: 可通过 属性 <code>ime-mode</code> 属性屏蔽 <code>composition</code> 相关动作</li><li>Chrone 系列： 不支持 <code>ime-mode</code><ul><li>屏蔽系统输入法 </li><li>JS 注入, 以改变 <strong>HTML</strong> 默认行为</li></ul></li></ul></li></ul></li></ul><p>本文主要介绍 web 页面内 <code>input</code> 标签屏蔽中文输入的相关方法. 考虑到 Cef 支持两种渲染模式(<strong>OSR</strong>, <strong>NON-OSR</strong>), 这里介绍两种不同的方式处理中文输入问题：屏蔽系统输入法, JS 注入改变默认行为.</p><h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><ul><li>双端通讯: 主进程与渲染进程间通信的方式，无外乎通过全局变量(window.XXXX). Electron 开发中就是直接的对 <code>window</code> 进行赋值. QCef 则提供了 <code>setBridgeObjectName</code> 接口. 二者本质上没有区别.<ul><li>进程通信:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QCefConfig::<span class="hljs-built_in">setBridgeObjectName</span>(<span class="hljs-string">&quot;CallBridge&quot;</span>);<br></code></pre></td></tr></table></figure></li><li>HTML 回调:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-string">R&quot;(</span><br><span class="hljs-string">    window.addEventListener(&#x27;load&#x27;, ()=&gt;&#123;</span><br><span class="hljs-string">        setTimeout(()=&gt;&#123;</span><br><span class="hljs-string">            var inputs = document.getElementsByClassName(&#x27;XXXXXX&#x27;); // or getElementById</span><br><span class="hljs-string">            if(inputs.length &gt; 0)&#123;</span><br><span class="hljs-string">                // method 1</span><br><span class="hljs-string">                inputs[0].addEventListener(&quot;XXXXX&quot;, (event)=&gt;&#123;</span><br><span class="hljs-string">                    // 改变 HTML 默认行为, 达到屏蔽中文的目的</span><br><span class="hljs-string">                &#125;);</span><br><span class="hljs-string">                // method 2</span><br><span class="hljs-string">                inputs[0].addEventListener(&quot;YYYYY&quot;, (event)=&gt;&#123;</span><br><span class="hljs-string">                    // 回调至主进程, 以屏蔽输入法</span><br><span class="hljs-string">                &#125;)</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;, 200); // delay 200ms in case too early to find no &lt;input/&gt;</span><br><span class="hljs-string">    &#125;);</span><br><span class="hljs-string">)&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li><li>屏蔽系统输入法: 这是相对比较合理的处理方式. 此处贴出相关逻辑处理 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">XXX::setImeEnabled</span><span class="hljs-params">(<span class="hljs-type">bool</span> enabled)</span></span><br><span class="hljs-function"></span>&#123;<br>    HWND wnd = <span class="hljs-built_in">getWindowHandle</span>(); <span class="hljs-comment">// user defined</span><br>    <span class="hljs-keyword">if</span>(enabled)<br>    &#123;<br>        m_himc = ::<span class="hljs-built_in">ImmGetContext</span>(wnd);<br>        <span class="hljs-keyword">if</span>(m_himc)<br>        &#123;<br>            <span class="hljs-built_in">ImmAssociateContext</span>(wnd, <span class="hljs-literal">nullptr</span>);<br>            <span class="hljs-built_in">ImmReleaseContext</span>(wnd, m_himc);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(m_himc)&#123;<br>            <span class="hljs-built_in">ImmDestroyContext</span>(m_himc);<br>            m_himc = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        m_himc = <span class="hljs-built_in">ImmCreateContext</span>();<br>        <span class="hljs-keyword">if</span>(m_himc)<br>        &#123;<br>            <span class="hljs-built_in">ImmAssociateContext</span>(wnd, m_himc);<br>            <span class="hljs-built_in">ImmReleaseContext</span>(wnd, m_himc);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>JS 注入: OSR 模式下, 业务层无法拿到当前输入法对应的窗口句柄(HWND). 为了保证 Web 页面多端行为一致性, 要求相应开发修改前端逻辑是不合适的.</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>两种方式可以屏蔽用户输入中文密码的问题:  </p><ul><li>屏蔽中文输入法:<br>通过注入代码的形式, 绑定 <code>&lt;input/&gt;</code> 焦点事件. 当获取焦点时, 通过捕获 <code>focus</code> 事件的方式间接通知 host 屏蔽当前窗口对应的输入法，即: 调用 <code>setImeEnabled</code>. 当失去焦点时, 则通知 host 恢复当前窗口的输入法状态.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">YYY::injectToLogin</span><span class="hljs-params">()</span></span>&#123;<br>    QString jsCode = <span class="hljs-string">R&quot;(</span><br><span class="hljs-string">        window.addEventListener(&#x27;load&#x27;, ()=&gt;&#123;</span><br><span class="hljs-string">            setTimeout(()=&gt;&#123;</span><br><span class="hljs-string">                var inputs = document.getElementsByClassName(&#x27;XXXXXX&#x27;); // or getElementById</span><br><span class="hljs-string">                if(inputs.length &gt; 0)&#123; // method 2</span><br><span class="hljs-string">                    inputs[0].addEventListener(&quot;focus&quot;, (event)=&gt;&#123;</span><br><span class="hljs-string">                        window.CallBridge.invokeMethod(&quot;inputFocus&quot;, &#x27;&#123;&quot;focus&quot;: true&#125;&#x27;);</span><br><span class="hljs-string">                    &#125;)</span><br><span class="hljs-string">                    inputs[0].addEventListener(&quot;focusout&quot;, (event)=&gt;&#123;</span><br><span class="hljs-string">                        window.CallBridge.invokeMethod(&quot;inputFocus&quot;, &#x27;&#123;&quot;focus&quot;: false&#125;&#x27;);</span><br><span class="hljs-string">                    &#125;)</span><br><span class="hljs-string">                &#125;</span><br><span class="hljs-string">            &#125;, 200); // delay 200ms in case too early to find no &lt;input/&gt;</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">    )&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>Js 注入:<br>当采用这种方式过滤中文字符时，会造成用户无法通过 ENTER 键触发登录的问题. 由 <strong>预备知识</strong> 可知, <code>keydown</code> 是最早触发的事件. 通过捕获 <code>keydown</code> 事件, 我们可以在用户输入完密码并按下 <strong>ENTER</strong> 键的第一时刻模拟登录按钮的单击事件.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">YYY::injectToLogin</span><span class="hljs-params">()</span></span>&#123;<br>    QString jsCode = <span class="hljs-string">R&quot;(</span><br><span class="hljs-string">        window.addEventListener(&#x27;load&#x27;, ()=&gt;&#123;</span><br><span class="hljs-string">            setTimeout(()=&gt;&#123;</span><br><span class="hljs-string">                var inputs = document.getElementsByClassName(&#x27;XXXXXX&#x27;); // or getElementById</span><br><span class="hljs-string">                if(inputs.length &gt; 0)&#123; // method 1</span><br><span class="hljs-string">                    inputs[0].addEventListener(&quot;keydown&quot;, (event)=&gt;&#123; // fix: simulate click event trigger by ENTER</span><br><span class="hljs-string">                        var key = event.which;</span><br><span class="hljs-string">                        if(key === 13)</span><br><span class="hljs-string">                        &#123;</span><br><span class="hljs-string">                            inputs[0].blur();</span><br><span class="hljs-string">                            var loginBtn = document.getElementById(&#x27;YYYYYY&#x27;)</span><br><span class="hljs-string">                            if(loginBtn)&#123;</span><br><span class="hljs-string">                                const event = new MouseEvent(&#x27;click&#x27;, &#123;</span><br><span class="hljs-string">                                    view: window,</span><br><span class="hljs-string">                                    bubbles: true,</span><br><span class="hljs-string">                                    cancelable: true</span><br><span class="hljs-string">                                &#125;);</span><br><span class="hljs-string">                                loginBtn.dispatchEvent(event);</span><br><span class="hljs-string">                            &#125;</span><br><span class="hljs-string">                        &#125;</span><br><span class="hljs-string">                    &#125;)</span><br><span class="hljs-string">                    inputs[0].addEventListener(&quot;input&quot;, (event)=&gt;&#123;</span><br><span class="hljs-string">                        event.target.value = event.target.value.replace(/[\u4e00-\u9fa5]/g, &#x27;&#x27;);</span><br><span class="hljs-string">                    &#125;)</span><br><span class="hljs-string">                &#125;</span><br><span class="hljs-string">            &#125;, 200); // delay 200ms in case too early to find no &lt;input/&gt;</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">    )&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="To-be-continued-…"><a href="#To-be-continued-…" class="headerlink" title="To be continued …"></a>To be continued …</h1>]]></content>
    
    
    <categories>
      
      <category>Cef</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>[杂项] rlottie</title>
    <link href="/2023/02/18/CPP-Animation-rlottie/"/>
    <url>/2023/02/18/CPP-Animation-rlottie/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面向用户的企业级产品，UI 和交互会直接影响到用户的体验：鼠标交互可以附加 UI 的 <code>hover</code>, <code>pressed</code> 状态； 对于持续的状态 (Download, Uninstall, Update), 则可以考虑在功能入口引入 <strong>GIF</strong> 。下图是博主随意截取的 <strong>GIF</strong> (Sam Smith)<br><img src="/2023/02/18/CPP-Animation-rlottie/samdemo.gif"></p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><ul><li><p>Concurrency In Action: <strong>single-producer, single-consumer</strong></p><ul><li><p>Lock-free concurrent data structure: </p><blockquote><p>lock-free data structures rely on the use of <strong>atomic operations</strong> and the associated <strong>memory-ordering</strong> guarantees in order to ensure that data becomes <strong>visible</strong> to other threads in the <strong>correct order</strong>.  </p></blockquote></li><li><p>Guildllines: </p><blockquote><ul><li>use <code>std::memory_order_seq_cst</code> for prototyping </li><li>use a lock-free memory reclamation scheme </li><li>simplify it to the context: <ul><li>only one thread calling <code>push()</code> at a time </li><li>only one thread calling <code>pop()</code> at a time</li></ul></li><li>watch out for the ABA problem</li><li>identify busy-wait loops and help the other thread</li></ul></blockquote></li></ul></li><li><p><a href="https://lottiefiles.com/">Lottie</a>:</p><blockquote><p>A lottie is JSON-based animation file format that allows you to ship animations on any playform as easily as shipping static assets.  </p></blockquote><ul><li><p>Parse Lottie:</p><ul><li><a href="https://doc.qt.io/qt-6/qml-qt-labs-lottieqt-lottieanimation.html">LottieAnimation</a>: a bodymovin player for Qt </li><li><a href="https://github.com/Samsung/rlottie">rlottie</a>: a platform independent standalone c++ library for rendering vector based animations and art <strong>IN REALTIME</strong></li></ul></li><li><p>Tips on rlottie:</p><ul><li>render mode: synchronize (<code>rendersync</code>) and asynchronzie (<code>render</code>)</li><li>cache policy: load from data with corresponding <strong>key</strong> to distinguish different cache</li></ul></li></ul></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>客户端中使用动画的业务场景大致相同, 如下范式可供参考:  </p><blockquote><p>本博主负责的 AR 直播 (1080p59.94) 项目中使用过类似范式： 16.6ms 内使用最少的 cpu 时间处理 4 路输出, 而每路每帧的 1080p 图片 <code>copy</code> 耗时 3ms 左右哦.</p></blockquote><ul><li>desigen structure:<ul><li>设计 <strong>单生产单消费者</strong> 数据结构: <code>lock_free_queue</code></li><li>分析业务场景并简化之，以适用于 <code>lock_free_queue</code></li></ul></li><li>request render: <ul><li>通过异步接口 <code>render()</code> 请求渲染一帧图片，并得到对应的 <code>future</code> 对象.  </li><li>将 <code>future</code> 对象存至对应的 <code>lock_free_queue</code>: <code>render_queue</code></li></ul></li><li>process request: 遍历所有 <code>render_queue</code> 中的所有 <code>future</code> 对象 (得益于良好的数据结构，业务逻辑无需锁)</li></ul><h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><p>本阶段就是要设计 (拿来主义) 对应的 <strong>无锁</strong> 数据结构啦, 一切从简, 就简单贴出标准的接口.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lock_free_queue</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>    &#123;<br>        std::shared_ptr&lt;T&gt; data;<br>        ndoe* next;<br>        <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    &#125;;<br>    std::atomic&lt;ndoe*&gt; head;<br>    std::atomic&lt;node*&gt; tail;<br>    <span class="hljs-function">node* <span class="hljs-title">pop_head</span><span class="hljs-params">()</span></span>&#123;<br>        node* <span class="hljs-type">const</span> old_head = head.<span class="hljs-built_in">load</span>();<br>        <span class="hljs-keyword">if</span>(old_head == tail.<span class="hljs-built_in">load</span>()) &#123;                                     <span class="hljs-comment">// &lt;order&gt; 1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        head.<span class="hljs-built_in">store</span>(old_head-&gt;next);<br>        <span class="hljs-keyword">return</span> old_head;<br>    &#125;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">lock_free_queue</span>():<span class="hljs-built_in">head</span>(<span class="hljs-keyword">new</span> node), <span class="hljs-built_in">tail</span>(head.<span class="hljs-built_in">load</span>())&#123;&#125;<br>    <span class="hljs-built_in">lock_free_queue</span>(<span class="hljs-type">const</span> lock_free_queue&amp; other)=<span class="hljs-keyword">delete</span>;<br>    lock_free_queue&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> lock_free_queue&amp; other)=<span class="hljs-keyword">delete</span>;<br>    ~<span class="hljs-built_in">lock_free_queue</span>();<br><br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>        node* old_head=<span class="hljs-built_in">pop_head</span>();<br>        <span class="hljs-keyword">if</span>(!old_head) <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt;();<br>        <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-type">const</span> <span class="hljs-title">res</span><span class="hljs-params">(old_head-&gt;data)</span></span>;                     <span class="hljs-comment">// &lt;order&gt; 2 </span><br>        <span class="hljs-keyword">delete</span> old_head;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T new_value)</span></span>&#123;<br>        <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">new_data</span><span class="hljs-params">(std::make_shared&lt;T&gt;(new_value))</span></span>;<br>        node* p = <span class="hljs-keyword">new</span> node;                                               <span class="hljs-comment">// &lt;order&gt; 3</span><br>        node* <span class="hljs-type">const</span> old_tail = tail.<span class="hljs-built_in">load</span>();                               <span class="hljs-comment">// &lt;order&gt; 4</span><br>        old_tail-&gt;data.<span class="hljs-built_in">swap</span>(new_data);                                    <span class="hljs-comment">// &lt;order&gt; 5</span><br>        old_tail-&gt;next = p;                                               <span class="hljs-comment">// &lt;order&gt; 6</span><br>        tail.<span class="hljs-built_in">store</span>(p);                                                    <span class="hljs-comment">// &lt;order&gt; 7</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>本阶段仅仅列出 <code>rlottie</code> 接口相关的内容. </p><blockquote><p><strong>预备知识</strong> 和 <strong>简介</strong> 是理论和实践经验的陈述. 其中涉及的异步处理框架, 需要根据项目的业务场景和采用的设计模式 (MVC, MVVM) 进行定制. </p></blockquote><ul><li>parseLottie: <code>lottie</code> 初始化, 包括: Animation, Surface 对象的构造, 堆内存分配<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parseLottie</span><span class="hljs-params">(std::string lottie_file)</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-comment">// load data</span><br>     <span class="hljs-keyword">auto</span> lottieData = util::<span class="hljs-built_in">loadFromFile</span>(lottie_file); <span class="hljs-comment">// load lottie.json file from lottie_file</span><br>     <span class="hljs-comment">// parse lottie and contruct `Animation`</span><br>     lottieAnimation = Animation::<span class="hljs-built_in">loadFromData</span>(lottieData, lottie_file); <span class="hljs-comment">// ****key: lottie_file****</span><br>     <span class="hljs-comment">// alloc 1 frame buffer and construct `Surface`</span><br>     <span class="hljs-type">size_t</span> bytesPerLine = cols * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">unint32_t</span>); <span class="hljs-comment">// row bytes to iterate</span><br>     <span class="hljs-keyword">auto</span> lottieBuffer = (<span class="hljs-type">uint32_t</span>*)<span class="hljs-built_in">malloc</span>(bytesPerline * rows);<br>     lottieSurface = <span class="hljs-built_in">Surface</span>(lottieBuffer, cols, rows, bytesPerline);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>requestRender: 以 <code>lottie</code> 动画的帧率, 调用该接口完成 1 次异步渲染请求<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">requestRender</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> future = lottieAnimation-&gt;<span class="hljs-built_in">render</span>(currentFrame, lottieSurface, <span class="hljs-literal">true</span>);<br>    currentFrame = (currentFrame + <span class="hljs-number">1</span>) % lottieAnimation-&gt;<span class="hljs-built_in">totalFrame</span>();<br>    <span class="hljs-comment">// lock-free queue</span><br>    lottieQueue-&gt;<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">make_pair</span>(key_to_index, future));<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="插件集成-–-Windows"><a href="#插件集成-–-Windows" class="headerlink" title="插件集成 – Windows"></a>插件集成 – Windows</h1><ul><li><strong>Build rlottie</strong><ul><li>Install <a href="https://gnuwin32.sourceforge.net/packages/make.htm">make</a> on Windows: in case of <code>command not found</code> on <code>make -j 2</code></li><li>Build libs for Windows: no need to flow <a href="https://github.com/Samsung/rlottie">rlottie</a><ul><li>step 1: <code>cmake ..</code> produces Visual Studio Solution (default on Windows)</li><li>step 2: open <em>rlottie.sln</em> and build it with Visual Studio</li></ul></li></ul></li><li><strong>Integrate rlottie</strong><ul><li><p>Header Files:</p><ul><li>Visual Studio: setup <em>Additional Include Directories</em></li><li>CMakeLists  <table style="margin-bottom: 8px">  <tbody>  <tr style="border: none">      <td style="background: black; border: none; width: 100vw; border-radius: 4px">          <ol style="margin:0">              <li align="left"><b>                  <font size=2 color=steelblue>include_directories</font><font size=2 color=silver>&ensp;(</font>              </b></li>              <li align="left"><b>                  <font size=2 color=mediumseagreen>&emsp;&emsp;${CMAKE_SOURCE_DIR}</font><font size=2 color=silver>/rlottie/</font><font size=2 color=skyblue>include</font>              </b></li>              <li align="left"><b>                  <font size=2 color=silver>)</font>              </b></li>          </ol>      </td>  </tr>  </tbody>  </table></li></ul></li><li><p>Libs</p><ul><li>Visual Studio: setup <em>Additional Dependencies</em></li><li>CMakeLists  <table style="margin-bottom: 8px">  <tbody>  <tr style="border: none">      <td style="background: black; border: none; width: 100vw; border-radius: 4px">          <ol style="margin:0">              <li align="left"><b>                  <font size=2 color=steelblue>target_link_libraries</font><font size=2 color=silver>&ensp;(</font><font size=2 color=mediumseagreen>${PROJECT_NAME}</font>              </b></li>              <li align="left"><b>                  <font size=2 color=skyblue>PRIVATE</font>              </b></li>              <li align="left"><b>                  <font size=2 color=gainsboro>debug</font>              </b></li>              <li align="left"><b>                  <font size=2 color=mediumseagreen>${CMAKE_SOURCE_DIR}</font><font size=2 color=silver>/rlottie/sdk/debug/rlottie.lib</font>              </b></li>              <li align="left"><b>                  <font size=2 color=gainsboro>optimized</font>              </b></li>              <li align="left"><b>                  <font size=2 color=mediumseagreen>${CMAKE_SOURCE_DIR}</font><font size=2 color=silver>/rlottie/sdk/release/rlottie.lib</font>              </b></li>              <li align="left"><b>                  <font size=2 color=silver>)</font>              </b></li>          </ol>      </td>  </tr>  </tbody>  </table></li></ul></li><li><p>Dlls</p><ul><li>Visual Studio: copy them to <em>Output Directory</em></li><li>CMakeLists  <table style="margin-bottom: 8px">  <tbody>  <tr style="border: none">      <td style="background: black; border: none; width: 100vw; border-radius: 4px">          <ol style="margin:0">              <li align="left"><b>                  <font size=2 color=white>cmake_path(CONVERT</font>                  <font size=2 color=peru>&ensp;"</font>                  <font size=2 color=mediumseagreen>${CMAKE_SOURCE_DIR}</font>                  <font size=2 color=white>/rlottie/sdk/$<CONFIG>/*.dll TO_NATIVE_PATH_LIST rlottie_dll_path)</font>              </b></li>                  <li align="left"><b>                  <font size=2 color=white>cmake_path(CONVERT</font><font size=2 color=peru>&ensp;"</font><font size=2 color=mediumseagreen>${CMAKE_RUNTIME_OUTPUT_DIRECTORY}</font><font size=2 color=peru>/"</font><font size=2 color=white>&ensp;TO_NATIVE_PATH_LIST runtime_output_ path)</font>              </b></li>              <li align="left"><b>                  <font size=2 color=steelblue>add_custom_command</font><font size=2 color=white>(</font><font size=2 color=steelblue>TARGET</font><font size=2 color=mediumseagreen>${XXX_TARGET_NAME}</font><font size=2 color=white>&ensp;POST_BUILD</font>              </b></li>              <li align="left"><b>                  <font size=2 color=steelblue>&emsp;&emsp;&emsp;&emsp;COMMAND</font><font size=2 color=white>&ensp;xcopy</font><font size=2 color=peru>&ensp;"</font><font size=2 color=mediumseagreen>${rlottie_dll_path}</font><font size=2 color=peru>"&ensp;"</font><font size=2 color=mediumseagreen>${runtime_output_path}</font><font size=2 color=peru>"</font><font size=2 color=white>&ensp;/y</font>              </b></li>              <li align="left"><b>                  <font size=2 color=steelblue>&emsp;&emsp;&emsp;&emsp;WORKING_DIRECTORY</font><font size=2 color=mediumseagreen>${CMAKE_CURRENT_SOURCE_DIR}</font>              </b></li>              <li align="left"><b>                  <font size=2 color=steelblue>&emsp;&emsp;&emsp;&emsp;COMMAND</font><font size=2 color=peru>&ensp;"Copying thirdparty files"</font><font size=2 color=steelblue>&ensp;VERBATIM</font>              </b></li>              <li align="left"><b>                  <font size=2 color=white>&emsp;&emsp;&emsp;)</font>              </b></li>          </ol>      </td>  </tr>  </tbody>  </table></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>[杂项] Enum to String</title>
    <link href="/2023/01/23/CPP-Macro-Enum2String/"/>
    <url>/2023/01/23/CPP-Macro-Enum2String/</url>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><!--> block reference used head of paragragh, and can be nested.--><ul><li>Standard predefined identifier: 预定义标识符  <ul><li><code>__func__</code>: 返回所在函数闭包对应的函数名. 本质上是常量字符数组, 由编译器提供(ISO C99 &amp; ISO C++11), 格式: <code>const char __func__[]</code></li></ul></li><li>Standard predefined macro: 预定义宏<blockquote><p>MSVC supports the predefined preprocessor macros required by the ANSI&#x2F;ISO C99, C11, and C17 standards, and the ISO C++14, C++17, and C++20 standards. </p></blockquote><ul><li>可提供通用的辅助性信息<ul><li><code>__LINE__</code>: 提供当前函数所在的行号, 格式: 数字</li><li><code>__FILE__</code>: 当前函数所在的文件, 格式: 字符串</li><li><code>__DATE__</code>: 当前日期, 格式: <code>Jan 19 2023</code></li><li><code>__TIME__</code>: 当前时间信息, 格式: <code>22:35:41</code></li></ul></li><li>提供具体到函数调用的信息本文将利用 <code>__FUNCSIG__</code> 提供的信息, 模拟反射机制来将 enum 变量转为字符串 <ul><li><code>__FUNCTION__</code>: 提供所在闭包对应函数的函数名, 格式: 返回 <code>__func__</code> 的值</li><li><code>__FUNCDNAME__</code>: 提供函数修饰名, 格式: <code>?main@@YAHXZ</code> 或 <code>main</code> 或 <code>_main</code>（可理解为符号表中导出的符号）</li><li><code>__FUNCSIG__</code>: 提供函数的完整声明(同g++支持的宏:<code>__PRETTY_FUNCTION__</code>), 格式: <code>int __cdecl main(void)</code></li></ul></li></ul></li><li>编译方式: 导出符号的修饰规则, 会影响到部分预定义宏的返回结果<ul><li><code>extern &quot;C&quot;</code>: 不带修饰符. 此时, <code>__FUNCTION__</code> 与 <code>__FUNCDNAME__</code> 的值相同 </li><li>其他: 导出符号被修饰, 如: <code>?main@@YAHXZ</code>, 可拆分为 <code>?</code> + <code>main</code> + <code>@@</code> + <code>参数表代号</code><ul><li>修饰符: 用于函数重载</li><li>代号: XDEFHIJKMN_NU, 比如: @@YAHXZ可拆分为<ul><li>@@YA:起始位置, 也有@@YG, @@YI</li><li>H: 返回类型为 <code>int</code></li><li>X: 参数列表为空, 即 <code>void</code></li><li>Z: 结束位置, 也有@Z</li></ul></li></ul></li></ul></li><li>调用约定:   <ul><li><code>_cdecl</code>: C Declaration 的缩写, 即采用 C 语言的声明方式（C缺省调用方式）  <ul><li>参数从右—&gt;左依次入栈</li><li>手动清栈, 即由调用者来恢复堆栈</li></ul></li><li><code>_stdcall</code>: Standard Call 的缩写, 是 C++ 的标准调用方式. MSVC 宏有 <code>PASCAL</code>, <code>WINAPI</code>, <code>CALLBACK</code> <ul><li>参数从右—&gt;左依次入栈</li><li>自动清栈, 即由被调用函数来恢复堆栈</li></ul></li><li><code>_fastcall</code><ul><li>参数借由CPU寄存器(ecx, edx)和堆栈来处理参数信息, 从右—&gt;左依次入栈</li><li>自动清栈: 同<code>_stdcall</code>, 减轻调用者负担</li></ul></li></ul></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>业务开发过程中, 会遇到需要获取 <krd>Enum</krd> 的相关信息, 具体应用场景如下: </p><ul><li>配置信息: 枚举值本身在代码逻辑中用于归类; 枚举名在初始化阶段作为配置信息的索引</li><li>多语言: 完整的枚举名列表用于前端UI展示; 枚举值用于用户交互进行语言切换</li></ul><p>本文目标是模拟反射机制(c#, java), 获取对应枚举的相关信息. 由预备知识可知, <code>__FUNCSIG__</code> 可获取当前函数的完整声明信息(包括调用约定信息). 不由产生两个疑问: </p><ul><li><code>__FUNCSIG__</code> 是如何获得函数的完整声明?</li><li>函数的声明如何能获得任意类型的 <code>enum class</code> 的相关信息?</li></ul><p>好的问题远比答案重要: 在编译阶段, 模板函数会对所有的枚举类型进行实例化. 而实例化过程中, 传入的枚举类型及枚举值就是我们所需要的相关信息. 本文目标是提供操作枚举类型的工具函数, 如下:</p><ul><li><code>get_enum_name</code>: 通过枚举值, 获取对应名称</li><li><code>get_all_enum_names</code>: 获取枚举类型中所有值对应的名称列表</li><li><del><code>get_enum_value</code>: 通过名称, 获取对应枚举值</del></li><li><del><code>check_enum_valid</code>: 确认是否是有效的枚举(value or name)</del></li></ul><h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><p>考虑到兼顾不同编译器的情况, 需要对不同编译器提供的预定义宏进行适配. 个人比较喜欢 <code>__PRETTY_FUNCTION__</code>, 如下:   </p><ul><li><blockquote><p><a href="https://learn.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-170">msvc</a>: <code>__FUNCSIG__</code> Defined as a string literal that contains the signature of the enclosing function.</p></blockquote></li><li><blockquote><p><a href="https://gcc.gnu.org/onlinedocs/gcc/Function-Names.html">gcc</a>: In C, <code>__PRETTY_FUNCTION__</code> is yet another name for <code>__func__</code>, except that at file scope (or, in C++, namespace scope), it evaluates to the string “top level”. In addition, in C++, <code>__PRETTY_FUNCTION__</code> contains the signature of the function as well as its bare name.</p></blockquote></li></ul><table style="margin-bottom: 8px;">    <tbody>        <tr style="border: none">            <td style="background: black; border: none; width: 100vw; border-radius: 4px">                <ol style="margin:0;">                    <li align="left"><b>                        <font size=2 color=silver>#if&ensp;!defined(</font><font size=2 color=peru>__PRETTY_FUNCTION__</font><font size=2 color=silver>)&ensp;&&&ensp;!defined(</font><font size=2 color=gainsboro>__GNUC__</font><font size=2 color=silver>)</font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=silver>#&emsp;&emsp;define</font>                        <font size=2 color=mediumpurple>__PRETTY_FUNCTION__</font>                        <font size=2 color=peru>__FUNCSIG__</font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=silver>#endif</font>                    </b></li>                </ol>            </td>        </tr>    </tbody></table>  <p>同时, 提供工具函数用于遍历枚举类的所有枚举值: 根据阈值 <code>boundary</code>, 生成枚举值所在范围列表 [-boundary, boundary)  </p><table style="margin-top: 8px">    <tbody>        <tr style="border: none">            <td style="background: black; border: none; width: 100vw; border-radius: 4px">                <ol style="margin:0;">                        <li align="left"><b>                        <font size=2 color=steelblue>template</font><font size=2 color=silver>&ensp;<</font><font size=2 color=steelblue>int</font><font size=2 color=silver>...</font><font size=2 color=gainsboro>&ensp;sequence</font><font size=2 color=silver>></font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=steelblue>constexpr&ensp;auto</font><font size=2 color=lemonchiffon>&ensp;make_sequence_impl</font><font size=2 color=silver>(std::</font><font size=2 color=mediumseagreen>index_sequence</font><font size=2 color=silver><</font><font size=2 color=gainsboro>sequence</font><font size=2 color=silver>...>&ensp;seq)&ensp;{</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&ensp;return</font><font size=2 color=silver>&ensp;std::</font><font size=2 color=mediumseagreen>integer_sequence</font><font size=2 color=silver><</font><font size=2 color=steelblue>int</font><font size=2 color=silver>,&ensp;(</font><font size=2 color=gainsboro>sequence&ensp;-</font><font size=2 color=silver>&ensp;seq.</font><font size=2 color=gainsboro>size</font><font size=2 color=silver>())...,</font><font size=2 color=gainsboro>&ensp;sequence</font><font size=2 color=silver>...>();</font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=silver>}</font>                    </b></li>                                           <li align="left"><b>                        <font size=2 color=steelblue>template</font><font size=2 color=silver>&ensp;<</font><font size=2 color=steelblue>int</font><font size=2 color=gainsboro>&ensp;boundary</font><font size=2 color=silver>,</font><font size=2 color=steelblue>&ensp;typename</font><font size=2 color=mediumseagreen>&ensp;indices</font><font size=2 color=silver>&ensp;=&ensp;std::</font><font size=2 color=mediumseagreen>make_index_sequence</font><font size=2 color=silver><</font><font size=2 color=gainsboro>boundary</font><font size=2 color=silver>>></font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=steelblue>constexpr&ensp;auto</font><font size=2 color=lemonchiffon>&ensp;make_sequence</font><font size=2 color=silver>()&ensp;{</font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&ensp;return</font><font size=2 color=gainsboro>&ensp;make_sequence_impl</font><font size=2 color=silver>(</font><font size=2 color=mediumseagreen>indices</font><font size=2 color=silver>());</font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=silver>}</font>                    </b></li>                </ol>            </td>        </tr>    </tbody></table>  <h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li><code>get_enum_name</code>: 由于 <code>std::regex</code> 不支持 look behind, 此处藉由 <code>QRegualr</code> 实现对编译期常量<b><font color=gainsboro><code>V</code></font></b>和类型<b><font color=mediumseagreen><code>E</code></font></b>的捕获.</li></ul><table>    <tbody>        <tr style="border: none">            <td style="background: black; border: none; width: 100vw; border-radius: 4px">                <ol style="margin:0;">                    <li><b>                        <font size=2 color=steelblue>template</font><font size=2 color=silver>&ensp;<</font><font size=2 color=steelblue>typename</font><font size=2 color=MediumSeaGreen>&ensp;E</font><font size=2 color=silver>,</font><font size=2 color=MediumSeaGreen>&ensp;E</font><font size=2 color=gainsboro>&ensp;V</font><font size=2 color=silver>></font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=steelblue>constexpr</font><font size=2 color=silver>&ensp;std::</font><font size=2 color=MediumSeaGreen>string</font><font size=2 color=LemonChiffon>&ensp;get_enum_name</font><font size=2 color=silver>()&ensp;{</font>                    </b></li>                    <b><li align="left">                        <font size=2 color=silver>&emsp;&emsp;&ensp;std::</font><font size=2 color=mediumseagreen>string</font><font size=2 color=skyblue>&ensp;name</font><font size=2 color=silver>(</font><font size=2 color=mediumpurple>__PRETTY_FUNCTION__</font><font size=2 color=silver>);</font>                    </b></li>                    <b><li align="left">                        <font size=2 color=mediumseagreen>&emsp;&emsp;&ensp;QRegularExpression</font><font size=2 color=skyblue>&ensp;reg</font><font size=2 color=silver>(</font><font size=2 color=peru>"(?<=::)[a-zA-Z_]+[</font><font size=2 color=navajowhite>\\</font><font size=2 color=peru>w]*(?=>)"</font><font size=2 color=silver>);</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumseagreen>&emsp;&emsp;&ensp;QRegularExpressionMatch</font><font size=2 color=skyblue>&ensp;match</font><font size=2 color=silver>&ensp;=</font><font size=2 color=skyblue>&ensp;reg</font><font size=2 color=silver>.</font><font size=2 color=lemonchiffon>match</font><font size=2 color=silver>(</font><font size=2 color=skyblue>name</font><font size=2 color=silver>.</font><font size=2 color=lemonchiffon>c_str</font><font size=2 color=silver>());</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumseagreen>&emsp;&emsp;&ensp;QString</font><font size=2 color=skyblue>&ensp;matched</font><font size=2 color=silver>&ensp;=</font><font size=2 color=lemonchiffon>&ensp;""</font><font size=2 color=silver>;</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&ensp;if</font>                        <font size=2 color=silver>(</font><font size=2 color=skyblue>match</font><font size=2 color=silver>.</font><font size=2 color=lemonchiffon>hasMatch</font><font size=2 color=silver>())&ensp;{</font>                    </b></li>                    <li><b>                        <font size=2 color=skyblue>&emsp;&emsp;&emsp;&emsp;matched</font><font size=2 color=silver>&ensp;=</font><font size=2 color=skyblue>&ensp;match</font><font size=2 color=silver>.</font><font size=2 color=lemonchiffon>captured</font><font size=2 color=silver>(</font><font size=2 color=powderblue>0</font><font size=2 color=silver>);</font>                    </b></li>                    <li><b>                        <font size=2 color=silver>&emsp;&emsp;&ensp;}</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&ensp;return</font><font size=2 color=skyblue>&ensp;matched</font><font size=2 color=silver>.</font><font size=2 color=lemonchiffon>size</font><font size=2 color=silver>()&ensp;></font><font size=2 color=powderblue>&ensp;0</font><font size=2 color=silver>&ensp;?</font><font size=2 color=skyblue>&ensp;matched</font><font size=2 color=silver>.</font><font size=2 color=lemonchiffon>toStdString</font><font size=2 color=silver>()&ensp;:</font><font size=2 color=burlywood>&ensp;""</font><font size=2 color=silver>;</font>                    </b></li>                    <li><b>                        <font size=2 colro=silver>}</font>                    </b></li>                </ol>            </td>        </tr>    </tbody></table>  <ul><li><code>get_all_enum_names</code>:</li></ul><table>    <tbody>        <tr style="border: none">            <td style="background: black; border: none; width: 100vw; border-radius: 4px">                <ol style="margin:0;">                    <li><b>                        <font size=2 color=steelblue>template</font><font size=2 color=silver>&ensp;<</font><font size=2 color=steelblue>typename</font><font size=2 color=mediumseagreen>&ensp;T</font><font size=2 color=silver>,</font><font size=2 color=steelblue>&ensp;int</font><font size=2 color=silver>...</font><font size=2 color=gainsboro>&ensp;Ints</font><font size=2 color=silver>></font>                    </b></li>                    <li><b>                        <font size =2 color=steelblue>constexpr&ensp;auto</font><font size =2 color=lemonchiffon>&ensp;get_all_enum_names</font><font size =2 color=silver>(std::</font><font size =2 color=mediumseagreen>integer_sequence</font><font size =2 color=silver><</font><font size =2 color=steelblue>int</font><font size=2 color=silver>,</font><font size=2 color=gainsboro>&ensp;Ints</font><font size=2 color=silver>...>)&ensp;{</font>                    </b></li>                    <li><b>                        <font size=2 color=silver>&emsp;&emsp;&ensp;std::</font><font size=2 color=mediumseagreen>array</font><font size=2 color=silver><</font><font size=2 color=silver>std::</font><font size=2 color=mediumseagreen>string</font><font size=2 color=silver>,</font><font size=2 color=steelblue>&ensp;sizeof</font><font size=2 color=silver>...(</font><font size=2 color=gainsboro>Ints</font><font size=2 color=silver>)></font><font size=2 color=skyblue>&ensp;names</font><font size=2 color=silver>{</font><font size=2 color=gainsboro>&nbsp;get_enum_name</font><font size=2 color=silver><</font><font size=2 color=mediumseagreen>T</font><font size=2 color=silver>,</font><font size=2 color=steelblue>&ensp;static_cast</font><font size=2 color=silver><</font><font size=2 color=mediumseagreen>T</font><font size=2 color=silver>>(</font><font size=2 color=gainsboro>Ints</font><font size=2 color=silver>)>()...&nbsp;};</font>                    </b></li>                    <li><b>                        <font size=2 color=silver>&emsp;&emsp;&ensp;std::</font><font size=2 color=mediumseagreen>vector</font><font size=2 color=silver><</font><font size=2 color=silver>std::</font><font size=2 color=mediumseagreen>string</font><font size=2 color=silver>></font><font size=2 color=skyblue>&ensp;valid</font><font size=2 color=silver>{};</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&ensp;for</font><font size=2 color=silver>&ensp;(</font><font size=2 color=steelblue>auto const</font><font size=2 color=silver>&</font><font size=2 color=skyblue>&ensp;name</font><font size=2 color=silver>&ensp;:</font><font size=2 color=skyblue>&ensp;names</font><font size=2 color=silver>)&emsp;{</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&emsp;&emsp;&ensp;if</font><font size=2 color=silver>&ensp;(</font><font size=2 color=skyblue>name</font><font size=2 color=silver>.</font><font size=2 color=gainsboro>size</font><font size=2 color=silver>()&ensp;==</font><font size=2 color=powderblue>&ensp;0</font><font size=2 color=silver>)</font><font size=2 color=mediumorchid>&ensp;continue</font><font size=2 color=silver>;</font>                    </b></li>                     <li><b>                        <font size=2 color=skyblue>&emsp;&emsp;&emsp;&emsp;&ensp;valid</font><font size=2 color=silver>.</font><font size=2 color=gainsboro>push_back</font><font size=2 color=silver>(</font><font size=2 color=skyblue>name</font><font size=2 color=silver>);</font>                    </b></li>                                   <li><b>                        <font size=2 color=silver>&emsp;&emsp;&ensp;}</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&ensp;return</font><font size=2 color=skyblue>&ensp;valid</font><font size=2 color=silver>;</font>                    </b></li>                    <li><b>                         <font size=2 color=silver>}</font>                   </b></li>                </ol>            </td>        </tr>    </tbody></table>  <h1 id="接口封装"><a href="#接口封装" class="headerlink" title="接口封装"></a>接口封装</h1><table>    <tbody>        <tr style="border: none">            <td style="background: black; border: none; width: 100vw; border-radius: 4px">                <ol style="margin:0;">                    <li><b>                        <font size=2 color=steelblue>template</font><font size=2 color=silver>&ensp;<</font><font size=2 color=steelblue>typename</font><font size=2 color=mediumseagreen>&ensp;T</font><font size=2 color=silver>,</font><font size=2 color=steelblue>&ensp;int</font><font size=2 color=gainsboro>&ensp;boundary</font><font size=2 color=silver>></font>                    </b></li>                    <li><b>                        <font size=2 color=steelblue>auto</font><font size=2 color=gainsboro>&ensp;enum_names</font><font size=2 color=silver>&ensp;=</font><font size =2 color=gainsboro>&ensp;get_all_enum_names</font><font size =2 color=silver><</font><font size =2 color=mediumseagreen>T</font><font size =2 color=silver>>(</font><font size=2 color=gainsboro>make_sequence</font><font size=2 color=silver><</font><font size=2 color=gainsboro>boundary</font><font size=2 color=silver>>());</font>                    </b></li>                </ol>            </td>        </tr>    </tbody></table>  ]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
