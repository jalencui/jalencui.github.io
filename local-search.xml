<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AR-前后景处理-Overview</title>
    <link href="/2023/03/22/AR-FrontAndRearScene-Overview/"/>
    <url>/2023/03/22/AR-FrontAndRearScene-Overview/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文着重梳理两年来博主在 AR 直播领域（渲染、推流、数据处理）的技术积累. 由下文的预备知识可知, 其中的每项都可以作为单独的专题展开讲解. 碍于全职工作, 近期不可能对所有的内容展开详尽讨论. 为避免遗忘这些宝贵的经验和方法, 才有了这篇文章.</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="GPU-流水线"><a href="#GPU-流水线" class="headerlink" title="GPU 流水线"></a>GPU 流水线</h2><ul><li>顶点数据: 模型通常由三角面 (或四边面) 组成. 在 GPU 渲染流程中，三角面片的顶点数据则是顶点着色器的输入，包括：位置, 法线, 切线, N 个纹理坐标以及颜色<ul><li>坐标系: 空间位置都是相对的.<br>  日常技术沟通时，我们常说：A 坐标系在 B 坐标系下的表示; 点在某个坐标系下的表示;<ul><li>A 类： 左手系, 右手系</li><li>B 类：模型坐标系, 相机坐标系, 世界坐标系</li></ul></li></ul></li><li>集合阶段: <ul><li><strong>顶点着色器</strong>: 顶点&#x2F;片元着色器的第一个函数<ul><li>必要动作：完成顶点坐标从模型空间转换到齐次裁剪空间(<code>mul(UNITY_MVP, v.position)</code>)</li><li>应用: 顶点动画, 低质量光照计算</li></ul></li><li>曲面细分着色器: 可忽略哈, 99.9% 的技美不会接触到这里</li><li>集合着色器: 同上可忽略, 如果感兴趣 google 一下</li><li><strong>裁剪</strong>: 至关重要, 跟投影矩阵直接相关(正交投影, 透视投影)</li><li><strong>屏幕映射</strong>: 至关重要, 3D –&gt; 2D</li></ul></li><li>光栅化阶段<ul><li>三角形设置: 固定函数阶段</li><li>三角形遍历: 固定函数阶段</li><li>片元着色器: 进行逐片元的着色操作. 顶点&#x2F;片元着色器的第二个函数</li><li>逐片元操作: 主要完成颜色, 深度缓冲, 混合等操作. 非可编程阶段, 开发人员 <strong>不可直接介入</strong></li></ul></li><li>屏幕图像</li></ul><h2 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h2><ul><li>Shading Language: 列出几种常见的高级语言—可视为 <strong>中间语言</strong> (Intermediate Language, IL). 这里的高级是相对于汇编语言来讲的, 并不是像 C# 相对于 C 的高级那种.<ul><li>HLSL: DirectX 专用</li><li>GLSL: OpenGL 专用</li><li>CG: NVIDA 专用, 也即 <code>C for Graphic</code>. 在单个 <code>Pass</code> 通道, C 风格的代码通常被包围在 <code>CGPROGRAM</code> 和 <code>ENDCG</code> 之间。</li></ul></li><li>Unity Shader: Unity 开发中, 有三种形式来编写 Unity Shader<ul><li>表面着色器 (Surface Shader): 噢噢噢噢，Unity 的宠儿. 使用这种着色器, 开发人员无需过多关注光照的处理细节</li><li>顶点&#x2F;片元着色器 (Vertex&#x2F;Fragment Shader): 更加复杂, 灵活度更高. 博主全权负责开发的 AR 直播项目 100% 采用这种形式</li><li>固定函数着色器 (Fixed Function Shader): 已经被抛弃, 也可以稍稍了解下</li></ul></li></ul><h2 id="3D-空间变换-投影，坐标变换"><a href="#3D-空间变换-投影，坐标变换" class="headerlink" title="3D 空间变换: 投影，坐标变换"></a>3D 空间变换: 投影，坐标变换</h2><ul><li>坐标投影: 也即 3D —&gt; 2D, 从世界坐标系 —&gt; 投影平面的变换<ul><li>坐标变换: 依赖相机外参进行世界坐标到相机坐标的变换; 依赖内参进行进一步到投影平面的操作<ul><li>相机外参: 世界坐标系到相机坐标系的变换 (<strong>必须</strong>)</li><li>相机内参: 进一步变换到投影屏幕 (<strong>可选</strong>) (物理相机的畸变在大多数情况下可忽略, 但直播画面必须要进行处理)</li></ul></li><li>3D 点投影: 即消除系数 <code>Z</code> 的作用 (透视投影下, 平行线会在无穷远处相交. <code>Z</code> 可理解为深度信息或距离)<ul><li>齐次坐标系: <code>pos_2d = world2Proj * pos_3d</code></li><li>笛卡尔坐标系: <code>pos_2d = pos_2d / pos_2d.z</code></li></ul></li></ul></li></ul><h2 id="3D-模型：点云处理-模型拼接"><a href="#3D-模型：点云处理-模型拼接" class="headerlink" title="3D 模型：点云处理, 模型拼接"></a>3D 模型：点云处理, 模型拼接</h2><p>AR 字面义为 <strong>增强现实</strong>. 说白了, AR 也就是在现实世界的基础上增加些 <strong>点缀</strong>. 点缀容易, 但要点缀地恰到好处：</p><ul><li>视觉上: 让用户感到 <strong>恰到好处</strong>, 也即视野范围内的径向位置合适, 径向深度合适</li><li>听觉上：让用户感受到那种 <strong>由远及近的鸣笛声</strong></li></ul><p>本文重点讲解视觉上的效果处理 (后续有机会的话, 再对声音的多普勒效应模拟展开介绍). AR 增强现实要做到上述的效果, 离不开对现实世界的 <strong>建模</strong> 和 <strong>标定</strong>. 对于不同的 AR 应用, 建模的方式有多种. 拿 LPL 直播效果, 盲猜他们会选择如下几种方式 (或者完全不需要, LPL 不需要对整个直播场地毫无遗漏的高精度要求)</p><ul><li>点云扫描：扫描精度不够, 尤其是边角处. 需要专业人员对从点云的导出模型进行修模 (如: 减面), 否侧很容易到达数百万顶点的模型文件</li><li>设计模型：过于理想, 现场搭建的场地往往是组装起来的. 而组装的精度跟施工人员专业程度, 场地大小强相关</li><li>设计模型拼接：相对比较节省人力, 节省时间的方式. 它的精度足够满足 AR 呈现的需求<ul><li>设计模型分块：按照实际场地的组装形式，对整体的设计模型进行拆分.</li><li>场地标定：对搭建后的场地, 按需进行坐标点标定</li><li>模型拼接：需要专用的模型拼接软件进行拼接. 作为当年的预研项, 博主当时耗时三周完成了基本功能的开发<ul><li>模型动态导入: <a href="https://ricardoreis.net/trilib-a-unity-3d-file-loader-asset/">插件</a>可用, 很好用<ul><li>模型缩放问题：可选缩放系数</li><li>模型材质问题：需要遍历所有的 <code>material</code>, 有些模型会存在 submesh 的情况</li></ul></li><li>模型拼接并导出: Unity 官方插件可用, 依赖于 Editor 模式<ul><li>模型缩放问题：100:1 的问题</li><li>模型格式问题：导入和导出的格式会涉及 fbx, obj, 因为我们是需要给模型贴图的. 某些情况下会生成光秃秃的模型哈哈哈哈</li></ul></li><li>模型点拾取: 实际上拾取的是三角面, 然后计算出距离拾取点最近的模型顶点. 注: 会存在多个三角面共点的情况</li><li>刚体变换: 奇异值求解 T44 坐标变换矩阵; 然后对模型施加相应分量的旋转、平移、缩放. 不难哈哈哈哈</li></ul></li></ul></li></ul><h2 id="相机内外参"><a href="#相机内外参" class="headerlink" title="相机内外参"></a>相机内外参</h2><p>内外参完全描述了物理相机的所有信息, 包括：相对于世界坐标系的变换, 相机的物理参数</p><ul><li>外参: 描述了相机的 <strong>位姿</strong> 信息, 包括：旋转参数, 平移参数. 旋转通常由 <strong>Euler</strong> 角描述, 可表示为 (qx, qy, qz, qw) </li><li>内参: 描述了相机的 <strong>畸变</strong> 和相机参数信息, 包括: 内参矩阵, 畸变系数 <ul><li>内参系数: fx, fy, cx, cy</li><li>畸变系数: 径向畸变, 切向畸变<ul><li>径向畸变: 来自透镜形状不规则及建模方式, 导致镜头不同区域焦距不同. 光线远离透镜中心的地方偏折更大 (枕型畸变) 或更小 (桶形畸变). 通常由 k1, k2, k3 表示</li><li>切向畸变：来自整个相机的组装过程. 由于透镜制造上的缺陷, 使得透镜本身与图像平面不平行而产生的 通常由 p1, p2 表示</li></ul></li></ul></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>AR 呈现 (或者是 AR 直播) 本质上是多张纹理 (或者图片) 的叠加 (<code>Blend</code> 指令, <code>Blit</code> 函数, <code>lerp</code> 插值函数). 这些纹理可分为: 底图 (UYVY422), UI 层 (BGRA), 特效层1, 特效层2, 特效层3 等</p><ul><li><strong>最上层</strong> (UI 层): 常驻元素不随机位变化, 包括：2D UI, 2D 动画等</li><li><strong>中间层</strong> (特效层): 各种类型的特效, 这里的特效层划分不是随意定的哦.  前文所述的恰到好处的 <strong>点缀</strong> 侧重在深度上的体现, 而不同类型的特效在深度上会受到不同类型的 <strong>遮挡</strong>. 按遮挡需求, 很容易对不同类型的特效进行划分. 就拿 <strong>某某</strong> 赛事直播来说, 可进行如下划分<ul><li>UI 层: 是的, 就其呈现形式来讲, 有些 UI (依赖于相机视角, 所属物体的状态) 是要归类为特效</li><li>移动拖尾效果: 根据实时位置, 对粒子进行持续移动即可形成连续的轨迹. 实现方式有：ParticleSystem, TrailRender</li><li>粒子效果: 本质上是 2D 精灵, 借助于<a href="https://assetstore.unity.com/packages/tools/particles-effects/spritetoparticles-69765">插件</a>将其转换为具有 3D 效果的粒子特效</li></ul></li><li><strong>最底层</strong> (物理相机输出的底图): 物理相机无法避免会存在各种前述畸变.<ul><li>对上述特效层添加畸变效果, 以使特效跟底图完全吻合 (此时存在畸变)</li><li>对叠加后的畸变输出, 进行裁剪 (通常表现为四周存在黑边, 因此需要先裁剪后缩放至原始尺寸)</li></ul></li></ul><p>对于本文要介绍的前后景关, AR 呈现效果只是最后的表现. 而背后却需要硬件, 算法, 系统框架, 设计, 程序的支撑. 接下来将以 <strong>某某</strong> 直播为例, 简要概括前后景处理中涉及到的关键技术点 (注: 不涉及通用解决方案, 仅关注突破点)</p><ul><li>场地(官方场景): 针对场地, AR 要做的事情就是要进行场地对齐: 现实世界与虚拟世界的完全对齐. 然后, 对齐 (标定) 并不是本文的重点. 现在我们更关注如何提高虚拟世界的 <strong>精度</strong>.</li><li>道具(官方设备): 道具没有场地的固定位置, 但相对于玩家来说, 道具会在很长一段时间内具有固定的位置 (参数). 这就是对道具的定义, 针对不同的应用场景完全可以换个名词. 现在我们就关注世界坐标系到屏幕图像的 <strong>映射</strong> 及相关处理.</li><li>玩家(赛队机器人)：在 AR 直播领域, 玩家的深度处理相关比较复杂 (游戏的纯虚拟世界无法与其相提并论). 现在我们关注玩家与特效的前后景 <strong>互动</strong></li></ul><h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><p>本节开门见山, 直接针对简介中提出的三点作出相应的描述</p><ul><li><strong>场地精度</strong>: 由 <strong>预备知识</strong> 中对于 <strong>3D 模型</strong> 重点描述可知, <strong>模型拼接</strong> 可以相对提高对 AR 建模的精度</li><li><strong>道具映射</strong>: 涉及到 <strong>预备知识</strong> 中的 <strong>3D 空间变换</strong> 和 <strong>相机内外参</strong> 【前面的长篇陈述, 没有一句话是多余的】</li><li><strong>玩家互动</strong>: 涉及到玩家 <strong>Mask</strong> 不规则区域, 玩家的 <strong>3D 位置</strong></li></ul><h1 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h1><p>包括模型拼接，坐标映射，以及玩家互动。</p><h2 id="模型拼接"><a href="#模型拼接" class="headerlink" title="模型拼接"></a>模型拼接</h2><p>有很多前置条件不在本文讲解范围，后续有机会再分享。</p><ul><li><strong>模型分割</strong> ：即对整体的设计模型, 按照施工人员的组装方式进行分割。 这部分工作由相应的设计人员来完成, 但需要我们提出几点技术要求：<ul><li>坐标系: 统一为 AR 系统中采用的 <strong>左手系</strong> 或者 __右手系__。 <strong>预备知识</strong> 中对 <strong>GPU 流水线</strong> 的描述中有提及</li><li>坐标零点: 尽量保持处于模型的集合中心, 这样方便用户交互 (基于坐标零点)</li><li>模型缩放: 根据最终使用模型的引擎工具, 要对模型进行相应的缩放。比如： Unity 中导入的模型会存在 100:1 的关系</li><li>模型贴图：这点对于具有对称性的 AR 场地比较重要</li><li>模型减面: 比如, 可以在 Blender 中对模型添加 <code>Decimate Modifier</code>, 对不可见细节进行减面处理</li></ul></li><li><strong>模型动态导入</strong> ：Unity 开发中， 可以借助付费插件 <a href="https://assetstore.unity.com/packages/tools/modeling/trilib-2-model-loading-package-157548">Trilib</a> 来完成</li><li><strong>模型点拾取</strong> ：涉及到 <strong>3渲2</strong> 或 <strong>OSR</strong> ，即：用户看到的永远是 2D 图片, 用户的交互会被投影到不可见的 3D 场景</li><li><strong>模型定位</strong> ：即根据现实世界中测量的模型位置 (至少有 3 个不共面的模型顶点), 求解拾取点所需要的变换操作<ul><li>刚体变换求解：<ul><li>平移：消除偏移对拾取点的影响。如果模型本身的原点处于集合中心，则无需本步操作</li><li>旋转：通过奇异值分解的方式，计算 <strong>模型坐标系</strong> 下拾取点到 <strong>世界坐标系</strong> 下的标定点的旋转矩阵（3X3）</li><li>变换矩阵：通过前两步参数，得到 T44 变换矩阵</li></ul></li><li>施加变换：对于 Unity 开发，也就1个接口的调用而已</li></ul></li><li><strong>模型拼接并导出</strong> ：依赖于 Unity 官方插件 以及 Editor 模式。注意导出模型存在 <code>SubMesh</code> 的情况</li></ul><h2 id="坐标映射"><a href="#坐标映射" class="headerlink" title="坐标映射"></a>坐标映射</h2><p>官方设备外形固定且位姿参数相对稳定。针对这种情况，通常将它们的物理属性以配置参数的形式介入前端渲染流程：通过 <strong>3D 投影</strong> 可在二维成像平面的 <strong>裁剪</strong> 区域形成 <strong>BoundingBox</strong> ，再根据径向深度就可对 <strong>BoundingBox</strong> 内的像素点进行剔除 （<code>Clip</code>）。 从而，产生视觉上的视觉差：<em>特效被遮挡了</em>  </p><ul><li><strong>BoundingBox</strong> 意义: 矩形框。由 3D 空间中的测量点 (标定点)，根据当前相机的内外参进行成像平面的实时投影。 内外参包括相机的 <code>Focus</code>, <code>Zoom</code>, <code>Eular Angle</code>, 而这几个参数跟相机动态变化的姿态和视野范围强相关。因此，需要进行实时投影。  </li><li>变换步骤：世界坐标系 –&gt; 相机坐标系 –&gt; 2D投影<ul><li>生成包围体：可选六棱柱，可根据需要测量点（没必要）</li><li>投影：世界坐标系到 2D 投影<ul><li>数据准备：<ul><li>外参矩阵（View2World）： 相机外参，即旋转，平移。 Unity 接口为 Matrix4x4::SetTRS()</li><li>内参矩阵（View2Proj）: 相机内参，即 fx, fy, cx, cy</li></ul></li><li>实施变换：有两种方式供选：可实现算法接口，也可直接调用 Opencv 接口<ul><li><strong>自定义接口</strong> ：<ul><li>求解 world2Proj 矩阵： world2Proj &#x3D; view2Proj * world2View</li><li>进行 3D 点投影：<ul><li>齐次坐标系：pos_2d &#x3D; worldProj * pos_3d</li><li>笛卡尔坐标系：pos_2d &#x3D; pos_2d &#x2F; pos2d.z</li></ul></li><li>计算 BoundingBox: 从六棱柱对应的 12 个投影后的 2D 坐标中，选出最小包围盒</li></ul></li><li><strong>Opencv 接口</strong> ：<ul><li>接口介绍：<ul><li>Calib3D.Rogdrigues: 依赖 <strong>外参矩阵</strong> ，计算 <strong>旋转向量</strong></li><li>Calib3D.projectPoints: 依赖 <strong>旋转向量</strong> ，<strong>平移向量</strong> ，<strong>内参矩阵</strong> ，__畸变系数__（可选），计算投影点</li><li>Imgproc.boundingRect: 计算包围盒</li></ul></li><li>步骤：<ul><li>平移向量：取自 T44 矩阵的最后一列，即平移参数</li><li>旋转向量：通过 Rodrigues 计算出旋转向量</li><li>3D 投影：通过 projectPoints 直接投影</li><li>BoundingBox：通过 Imgproc.boundingRect 计算出投影点的最小包围盒</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="玩家互动"><a href="#玩家互动" class="headerlink" title="玩家互动:"></a>玩家互动:</h2><p>指真实世界中的 <em>玩家</em> 跟虚拟世界中特效的相互干涉。这里的互动涉及两个层面：屏幕投影，前后关系</p><ul><li><strong>不规则 Mask</strong> ：玩家不规则投影在相机可见范围的联通区。这些知识需要大量数据，来对模型训练已提供识别准确性。机器学习不在我的能力范围，故这里仅作简要介绍。<ul><li>数据传输：可以将场地上所有玩家的联通区，以 alpha 通道的形式跟底图一起传递给引擎</li><li>应用：根据不同玩家的联通区在 1080p 图片的位置，可以实时生成 中间层特效（UI 层）用于描述当前玩家的状态，如：血量，Buff, 等级等</li></ul></li><li><strong>径向深度</strong> : 借助于 <strong>Mask</strong> 联通区，可以深度信息实时判断当前像素点与对应玩家的前后关系。若玩家深度大小当前特效像素点的深度，则保留特效；若玩家深度小于当前像素点深度，则特效被剔除（Clip）。</li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>本文仅对 AR 直播中深度处理及相关技术作简要介绍，暂未涉及 Coding 相关的技术和性能要求。后续大致会对本文进行拆解，并增加以下专题：</p><ul><li>直播推流：硬件及方案选型，包括：BMD硬件采集卡，NDI 设备，本地局域网内传输方案等。 这里提及的推流追求最小延时和最少丢帧，不涉及通常所说的编解码工作。</li><li>AR 前端渲染：以往经历使用的是 Unity 引擎。 为向行业内的解决方案靠拢，后续会使用 Unreal 实现所有的技术点【手头没有 1 行代码】</li><li>AR 后端系统：由我全权搭建的后端直播系统，应该够前东家使用3年以上。 后续会使用 Qt 再现最小直播系统：包括视频采集，数据对齐，NDI输出等功能【依赖天价设备和算法支撑，只能模拟最小系统】</li></ul>]]></content>
    
    
    <categories>
      
      <category>AR</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>QCef-Ime-JSInject</title>
    <link href="/2023/03/08/QCef-Ime-JSInject/"/>
    <url>/2023/03/08/QCef-Ime-JSInject/</url>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><ul><li>Communications: between host and web<ul><li><a href="https://www.electronjs.org/docs/latest/tutorial/tutorial-preload"><strong>Preloading</strong></a>: supported by Electron only<blockquote><p>Preload scripts are injected <strong>BEFORE</strong> a web page loads in the renderer, similar to a Chrome extension’s content scripts. To add features to your renderer that require privileged access, you can define global objects through the contentBridge API.</p></blockquote><ul><li><strong>Guard current context</strong>: Embedding google login or facebook login page, for example, we need to isolate their content (global setting, global variables etc.). Otherwise, we may encounter various error info, for example, jquery related error or something else. And <code>Preload</code> is the only way to taskle this situation.</li></ul></li><li><a href="https://cefview.github.io/QCefView/zh/docs/reference/QCefView"><strong>Execute Javascript</strong></a>: supported by almost all framework<blockquote><p>Executes javascript code in specified frame at any time.</p></blockquote><ul><li><strong>Inject JS Code</strong>: In this way, we usually do something to adjust user interface, or fix some irregular behavior in our host. For example, constraint user to type chinese, japanese to <strong>INPUT</strong>, and this is the only way to fix this in OSR mode.</li></ul></li></ul></li><li>Html:  <code>&lt;input/&gt;</code> event related<ul><li>Enter:<ul><li><code>keydown</code> -&gt; <code>keypress</code> -&gt; <code>change</code> -&gt; <code>keyup</code></li></ul></li><li>Alphabet: <ul><li><code>keydown</code> -&gt; <code>keypress</code> -&gt; <code>change</code> -&gt; <code>keyup</code></li></ul></li><li>Ime:<ul><li><code>compositionstart</code> -&gt; <code>compositionupdate</code> -&gt; <code>input</code> -&gt; … -&gt; <code>input</code> -&gt; <code>compositionend</code></li></ul></li><li>Ime: filter in <code>input</code> event<ul><li><code>compositionstart</code> -&gt; <code>compositionupdate</code> -&gt; <code>input</code> -&gt; … -&gt; <code>input</code> -&gt; <code>compositionend</code></li></ul></li></ul></li><li>Cef: develop tools<ul><li>Mode:<ul><li>Popup Window: this is the only effective way if <strong>OSR</strong> enabled</li><li>Child Window: like all other browsers’ default behavior</li><li>Windowless: off-screen rendering</li></ul></li><li>Prerequisite:<ul><li>OnPreKeyEvent:<ul><li>CefViewBrowserClient: from CefViewBrowserClient_KeyboardHandler</li><li>CCefClientDelegate: from CCefCientDelegate_KeyboardHandler</li></ul></li></ul></li></ul></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>桌面端嵌入类 <code>webview</code> 的产品十分常见(开发周期极短, 开箱即用). 从某种程度上来讲，桌面软件扮演了浏览器的角色。对于常规 web 页面, 浏览器的行为在这种 Hybrid 模式的桌面软件中必定发生不符合预期的表现:  </p><ul><li>登录注册:<ul><li>Fackbook: 需要保证相对纯净的 jquery 上下文, 才能正常走完登录的流程</li><li>Google: 需要伪造合法的 User Agent, 才能通过页面的验证</li></ul></li><li>输入法: only <strong>IME</strong> introduced<ul><li>联想相关: 联想框弹出位置问题</li><li>IME: 中文输入法问题<ul><li>IE 浏览器: 可通过 属性 <code>ime-mode</code> 属性屏蔽 <code>composition</code> 相关动作</li><li>Chrone 系列： 不支持 <code>ime-mode</code><ul><li>屏蔽系统输入法 </li><li>JS 注入, 以改变 <strong>HTML</strong> 默认行为</li></ul></li></ul></li></ul></li></ul><p>本文主要介绍 web 页面内 <code>input</code> 标签屏蔽中文输入的相关方法. 考虑到 Cef 支持两种渲染模式(<strong>OSR</strong>, <strong>NON-OSR</strong>), 这里介绍两种不同的方式处理中文输入问题：屏蔽系统输入法, JS 注入改变默认行为.</p><h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><ul><li>双端通讯: 主进程与渲染进程间通信的方式，无外乎通过全局变量(window.XXXX). Electron 开发中就是直接的对 <code>window</code> 进行赋值. QCef 则提供了 <code>setBridgeObjectName</code> 接口. 二者本质上没有区别.<ul><li>进程通信:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QCefConfig::<span class="hljs-built_in">setBridgeObjectName</span>(<span class="hljs-string">&quot;CallBridge&quot;</span>);<br></code></pre></td></tr></table></figure></li><li>HTML 回调:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-string">R&quot;(</span><br><span class="hljs-string">    window.addEventListener(&#x27;load&#x27;, ()=&gt;&#123;</span><br><span class="hljs-string">        setTimeout(()=&gt;&#123;</span><br><span class="hljs-string">            var inputs = document.getElementsByClassName(&#x27;XXXXXX&#x27;); // or getElementById</span><br><span class="hljs-string">            if(inputs.length &gt; 0)&#123;</span><br><span class="hljs-string">                // method 1</span><br><span class="hljs-string">                inputs[0].addEventListener(&quot;XXXXX&quot;, (event)=&gt;&#123;</span><br><span class="hljs-string">                    // 改变 HTML 默认行为, 达到屏蔽中文的目的</span><br><span class="hljs-string">                &#125;);</span><br><span class="hljs-string">                // method 2</span><br><span class="hljs-string">                inputs[0].addEventListener(&quot;YYYYY&quot;, (event)=&gt;&#123;</span><br><span class="hljs-string">                    // 回调至主进程, 以屏蔽输入法</span><br><span class="hljs-string">                &#125;)</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;, 200); // delay 200ms in case too early to find no &lt;input/&gt;</span><br><span class="hljs-string">    &#125;);</span><br><span class="hljs-string">)&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li><li>屏蔽系统输入法: 这是相对比较合理的处理方式. 此处贴出相关逻辑处理 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">XXX::setImeEnabled</span><span class="hljs-params">(<span class="hljs-type">bool</span> enabled)</span></span><br><span class="hljs-function"></span>&#123;<br>    HWND wnd = <span class="hljs-built_in">getWindowHandle</span>(); <span class="hljs-comment">// user defined</span><br>    <span class="hljs-keyword">if</span>(enabled)<br>    &#123;<br>        m_himc = ::<span class="hljs-built_in">ImmGetContext</span>(wnd);<br>        <span class="hljs-keyword">if</span>(m_himc)<br>        &#123;<br>            <span class="hljs-built_in">ImmAssociateContext</span>(wnd, <span class="hljs-literal">nullptr</span>);<br>            <span class="hljs-built_in">ImmReleaseContext</span>(wnd, m_himc);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(m_himc)&#123;<br>            <span class="hljs-built_in">ImmDestroyContext</span>(m_himc);<br>            m_himc = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        m_himc = <span class="hljs-built_in">ImmCreateContext</span>();<br>        <span class="hljs-keyword">if</span>(m_himc)<br>        &#123;<br>            <span class="hljs-built_in">ImmAssociateContext</span>(wnd, m_himc);<br>            <span class="hljs-built_in">ImmReleaseContext</span>(wnd, m_himc);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>JS 注入: OSR 模式下, 业务层无法拿到当前输入法对应的窗口句柄(HWND). 为了保证 Web 页面多端行为一致性, 要求相应开发修改前端逻辑是不合适的.</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>两种方式可以屏蔽用户输入中文密码的问题:  </p><ul><li>屏蔽中文输入法:<br>通过注入代码的形式, 绑定 <code>&lt;input/&gt;</code> 焦点事件. 当获取焦点时, 通过捕获 <code>focus</code> 事件的方式间接通知 host 屏蔽当前窗口对应的输入法，即: 调用 <code>setImeEnabled</code>. 当失去焦点时, 则通知 host 恢复当前窗口的输入法状态.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">YYY::injectToLogin</span><span class="hljs-params">()</span></span>&#123;<br>    QString jsCode = <span class="hljs-string">R&quot;(</span><br><span class="hljs-string">        window.addEventListener(&#x27;load&#x27;, ()=&gt;&#123;</span><br><span class="hljs-string">            setTimeout(()=&gt;&#123;</span><br><span class="hljs-string">                var inputs = document.getElementsByClassName(&#x27;XXXXXX&#x27;); // or getElementById</span><br><span class="hljs-string">                if(inputs.length &gt; 0)&#123; // method 2</span><br><span class="hljs-string">                    inputs[0].addEventListener(&quot;focus&quot;, (event)=&gt;&#123;</span><br><span class="hljs-string">                        window.CallBridge.invokeMethod(&quot;inputFocus&quot;, &#x27;&#123;&quot;focus&quot;: true&#125;&#x27;);</span><br><span class="hljs-string">                    &#125;)</span><br><span class="hljs-string">                    inputs[0].addEventListener(&quot;focusout&quot;, (event)=&gt;&#123;</span><br><span class="hljs-string">                        window.CallBridge.invokeMethod(&quot;inputFocus&quot;, &#x27;&#123;&quot;focus&quot;: false&#125;&#x27;);</span><br><span class="hljs-string">                    &#125;)</span><br><span class="hljs-string">                &#125;</span><br><span class="hljs-string">            &#125;, 200); // delay 200ms in case too early to find no &lt;input/&gt;</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">    )&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>Js 注入:<br>当采用这种方式过滤中文字符时，会造成用户无法通过 ENTER 键触发登录的问题. 由 <strong>预备知识</strong> 可知, <code>keydown</code> 是最早触发的事件. 通过捕获 <code>keydown</code> 事件, 我们可以在用户输入完密码并按下 <strong>ENTER</strong> 键的第一时刻模拟登录按钮的单击事件.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">YYY::injectToLogin</span><span class="hljs-params">()</span></span>&#123;<br>    QString jsCode = <span class="hljs-string">R&quot;(</span><br><span class="hljs-string">        window.addEventListener(&#x27;load&#x27;, ()=&gt;&#123;</span><br><span class="hljs-string">            setTimeout(()=&gt;&#123;</span><br><span class="hljs-string">                var inputs = document.getElementsByClassName(&#x27;XXXXXX&#x27;); // or getElementById</span><br><span class="hljs-string">                if(inputs.length &gt; 0)&#123; // method 1</span><br><span class="hljs-string">                    inputs[0].addEventListener(&quot;keydown&quot;, (event)=&gt;&#123; // fix: simulate click event trigger by ENTER</span><br><span class="hljs-string">                        var key = event.which;</span><br><span class="hljs-string">                        if(key === 13)</span><br><span class="hljs-string">                        &#123;</span><br><span class="hljs-string">                            inputs[0].blur();</span><br><span class="hljs-string">                            var loginBtn = document.getElementById(&#x27;YYYYYY&#x27;)</span><br><span class="hljs-string">                            if(loginBtn)&#123;</span><br><span class="hljs-string">                                const event = new MouseEvent(&#x27;click&#x27;, &#123;</span><br><span class="hljs-string">                                    view: window,</span><br><span class="hljs-string">                                    bubbles: true,</span><br><span class="hljs-string">                                    cancelable: true</span><br><span class="hljs-string">                                &#125;);</span><br><span class="hljs-string">                                loginBtn.dispatchEvent(event);</span><br><span class="hljs-string">                            &#125;</span><br><span class="hljs-string">                        &#125;</span><br><span class="hljs-string">                    &#125;)</span><br><span class="hljs-string">                    inputs[0].addEventListener(&quot;input&quot;, (event)=&gt;&#123;</span><br><span class="hljs-string">                        event.target.value = event.target.value.replace(/[\u4e00-\u9fa5]/g, &#x27;&#x27;);</span><br><span class="hljs-string">                    &#125;)</span><br><span class="hljs-string">                &#125;</span><br><span class="hljs-string">            &#125;, 200); // delay 200ms in case too early to find no &lt;input/&gt;</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">    )&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="To-be-continue-…"><a href="#To-be-continue-…" class="headerlink" title="To be continue …"></a>To be continue …</h1>]]></content>
    
    
    <categories>
      
      <category>Cef</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>rlottie -- Animation Parser on CPP Client</title>
    <link href="/2023/02/18/CPP-Animation-rlottie/"/>
    <url>/2023/02/18/CPP-Animation-rlottie/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面向用户的企业级产品，UI 和交互会直接影响到用户的体验：鼠标交互可以附加 UI 的 <code>hover</code>, <code>pressed</code> 状态； 对于持续的状态 (Download, Uninstall, Update), 则可以考虑在功能入口引入 <strong>GIF</strong> 。下图是博主随意截取的 <strong>GIF</strong> (Sam Smith)<br><img src="/2023/02/18/CPP-Animation-rlottie/samdemo.gif"></p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><ul><li><p>Concurrency In Action: <strong>single-producer, single-consumer</strong></p><ul><li><p>Lock-free concurrent data structure: </p><blockquote><p>lock-free data structures rely on the use of <strong>atomic operations</strong> and the associated <strong>memory-ordering</strong> guarantees in order to ensure that data becomes <strong>visible</strong> to other threads in the <strong>correct order</strong>.  </p></blockquote></li><li><p>Guildllines: </p><blockquote><ul><li>use <code>std::memory_order_seq_cst</code> for prototyping </li><li>use a lock-free memory reclamation scheme </li><li>simplify it to the context: <ul><li>only one thread calling <code>push()</code> at a time </li><li>only one thread calling <code>pop()</code> at a time</li></ul></li><li>watch out for the ABA problem</li><li>identify busy-wait loops and help the other thread</li></ul></blockquote></li></ul></li><li><p><a href="https://lottiefiles.com/">Lottie</a>:</p><blockquote><p>A lottie is JSON-based animation file format that allows you to ship animations on any playform as easily as shipping static assets.  </p></blockquote><ul><li><p>Parse Lottie:</p><ul><li><a href="https://doc.qt.io/qt-6/qml-qt-labs-lottieqt-lottieanimation.html">LottieAnimation</a>: a bodymovin player for Qt </li><li><a href="https://github.com/Samsung/rlottie">rlottie</a>: a platform independent standalone c++ library for rendering vector based animations and art <strong>IN REALTIME</strong></li></ul></li><li><p>Tips on rlottie:</p><ul><li>render mode: synchronize (<code>rendersync</code>) and asynchronzie (<code>render</code>)</li><li>cache policy: load from data with corresponding <strong>key</strong> to distinguish different cache</li></ul></li></ul></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>客户端中使用动画的业务场景大致相同, 如下范式可供参考:  </p><blockquote><p>本博主负责的 AR 直播 (1080p59.94) 项目中使用过类似范式： 16.6ms 内使用最少的 cpu 时间处理 4 路输出, 而每路每帧的 1080p 图片 <code>copy</code> 耗时 3ms 左右哦.</p></blockquote><ul><li>desigen structure:<ul><li>设计 <strong>单生产单消费者</strong> 数据结构: <code>lock_free_queue</code></li><li>分析业务场景并简化之，以适用于 <code>lock_free_queue</code></li></ul></li><li>request render: <ul><li>通过异步接口 <code>render()</code> 请求渲染一帧图片，并得到对应的 <code>future</code> 对象.  </li><li>将 <code>future</code> 对象存至对应的 <code>lock_free_queue</code>: <code>render_queue</code></li></ul></li><li>process request: 遍历所有 <code>render_queue</code> 中的所有 <code>future</code> 对象 (得益于良好的数据结构，业务逻辑无需锁)</li></ul><h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><p>本阶段就是要设计 (拿来主义) 对应的 <strong>无锁</strong> 数据结构啦, 一切从简, 就简单贴出标准的接口.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lock_free_queue</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>    &#123;<br>        std::shared_ptr&lt;T&gt; data;<br>        ndoe* next;<br>        <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    &#125;;<br>    std::atomic&lt;ndoe*&gt; head;<br>    std::atomic&lt;node*&gt; tail;<br>    <span class="hljs-function">node* <span class="hljs-title">pop_head</span><span class="hljs-params">()</span></span>&#123;<br>        node* <span class="hljs-type">const</span> old_head = head.<span class="hljs-built_in">load</span>();<br>        <span class="hljs-keyword">if</span>(old_head == tail.<span class="hljs-built_in">load</span>()) &#123;                                     <span class="hljs-comment">// &lt;order&gt; 1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        head.<span class="hljs-built_in">store</span>(old_head-&gt;next);<br>        <span class="hljs-keyword">return</span> old_head;<br>    &#125;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">lock_free_queue</span>():<span class="hljs-built_in">head</span>(<span class="hljs-keyword">new</span> node), <span class="hljs-built_in">tail</span>(head.<span class="hljs-built_in">load</span>())&#123;&#125;<br>    <span class="hljs-built_in">lock_free_queue</span>(<span class="hljs-type">const</span> lock_free_queue&amp; other)=<span class="hljs-keyword">delete</span>;<br>    lock_free_queue&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> lock_free_queue&amp; other)=<span class="hljs-keyword">delete</span>;<br>    ~<span class="hljs-built_in">lock_free_queue</span>();<br><br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>        node* old_head=<span class="hljs-built_in">pop_head</span>();<br>        <span class="hljs-keyword">if</span>(!old_head) <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt;();<br>        <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-type">const</span> <span class="hljs-title">res</span><span class="hljs-params">(old_head-&gt;data)</span></span>;                     <span class="hljs-comment">// &lt;order&gt; 2 </span><br>        <span class="hljs-keyword">delete</span> old_head;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T new_value)</span></span>&#123;<br>        <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">new_data</span><span class="hljs-params">(std::make_shared&lt;T&gt;(new_value))</span></span>;<br>        node* p = <span class="hljs-keyword">new</span> node;                                               <span class="hljs-comment">// &lt;order&gt; 3</span><br>        node* <span class="hljs-type">const</span> old_tail = tail.<span class="hljs-built_in">load</span>();                               <span class="hljs-comment">// &lt;order&gt; 4</span><br>        old_tail-&gt;data.<span class="hljs-built_in">swap</span>(new_data);                                    <span class="hljs-comment">// &lt;order&gt; 5</span><br>        old_tail-&gt;next = p;                                               <span class="hljs-comment">// &lt;order&gt; 6</span><br>        tail.<span class="hljs-built_in">store</span>(p);                                                    <span class="hljs-comment">// &lt;order&gt; 7</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>本阶段仅仅列出 <code>rlottie</code> 接口相关的内容. </p><blockquote><p><strong>预备知识</strong> 和 <strong>简介</strong> 是理论和实践经验的陈述. 其中涉及的异步处理框架, 需要根据项目的业务场景和采用的设计模式 (MVC, MVVM) 进行定制. </p></blockquote><ul><li>parseLottie: <code>lottie</code> 初始化, 包括: Animation, Surface 对象的构造, 堆内存分配<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parseLottie</span><span class="hljs-params">(std::string lottie_file)</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-comment">// load data</span><br>     <span class="hljs-keyword">auto</span> lottieData = util::<span class="hljs-built_in">loadFromFile</span>(lottie_file); <span class="hljs-comment">// load lottie.json file from lottie_file</span><br>     <span class="hljs-comment">// parse lottie and contruct `Animation`</span><br>     lottieAnimation = Animation::<span class="hljs-built_in">loadFromData</span>(lottieData, lottie_file); <span class="hljs-comment">// ****key: lottie_file****</span><br>     <span class="hljs-comment">// alloc 1 frame buffer and construct `Surface`</span><br>     <span class="hljs-type">size_t</span> bytesPerLine = cols * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">unint32_t</span>); <span class="hljs-comment">// row bytes to iterate</span><br>     <span class="hljs-keyword">auto</span> lottieBuffer = (<span class="hljs-type">uint32_t</span>*)<span class="hljs-built_in">malloc</span>(bytesPerline * rows);<br>     lottieSurface = <span class="hljs-built_in">Surface</span>(lottieBuffer, cols, rows, bytesPerline);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>requestRender: 以 <code>lottie</code> 动画的帧率, 调用该接口完成 1 次异步渲染请求<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">requestRender</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> future = lottieAnimation-&gt;<span class="hljs-built_in">render</span>(currentFrame, lottieSurface, <span class="hljs-literal">true</span>);<br>    currentFrame = (currentFrame + <span class="hljs-number">1</span>) % lottieAnimation-&gt;<span class="hljs-built_in">totalFrame</span>();<br>    <span class="hljs-comment">// lock-free queue</span><br>    lottieQueue-&gt;<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">make_pair</span>(key_to_index, future));<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="插件集成-–-Windows"><a href="#插件集成-–-Windows" class="headerlink" title="插件集成 – Windows"></a>插件集成 – Windows</h1><ul><li><strong>Build rlottie</strong><ul><li>Install <a href="https://gnuwin32.sourceforge.net/packages/make.htm">make</a> on Windows: in case of <code>command not found</code> on <code>make -j 2</code></li><li>Build libs for Windows: no need to flow <a href="https://github.com/Samsung/rlottie">rlottie</a><ul><li>step 1: <code>cmake ..</code> produces Visual Studio Solution (default on Windows)</li><li>step 2: open <em>rlottie.sln</em> and build it with Visual Studio</li></ul></li></ul></li><li><strong>Integrate rlottie</strong><ul><li><p>Header Files:</p><ul><li>Visual Studio: setup <em>Additional Include Directories</em></li><li>CMakeLists  <table style="margin-bottom: 8px">  <tbody>  <tr style="border: none">      <td style="background: black; border: none; width: 100vw; border-radius: 4px">          <ol style="margin:0">              <li align="left"><b>                  <font size=2 color=steelblue>include_directories</font><font size=2 color=silver>&ensp;(</font>              </b></li>              <li align="left"><b>                  <font size=2 color=mediumseagreen>&emsp;&emsp;${CMAKE_SOURCE_DIR}</font><font size=2 color=silver>/rlottie/</font><font size=2 color=skyblue>include</font>              </b></li>              <li align="left"><b>                  <font size=2 color=silver>)</font>              </b></li>          </ol>      </td>  </tr>  </tbody>  </table></li></ul></li><li><p>Libs</p><ul><li>Visual Studio: setup <em>Additional Dependencies</em></li><li>CMakeLists  <table style="margin-bottom: 8px">  <tbody>  <tr style="border: none">      <td style="background: black; border: none; width: 100vw; border-radius: 4px">          <ol style="margin:0">              <li align="left"><b>                  <font size=2 color=steelblue>target_link_libraries</font><font size=2 color=silver>&ensp;(</font><font size=2 color=mediumseagreen>${PROJECT_NAME}</font>              </b></li>              <li align="left"><b>                  <font size=2 color=skyblue>PRIVATE</font>              </b></li>              <li align="left"><b>                  <font size=2 color=gainsboro>debug</font>              </b></li>              <li align="left"><b>                  <font size=2 color=mediumseagreen>${CMAKE_SOURCE_DIR}</font><font size=2 color=silver>/rlottie/sdk/debug/rlottie.lib</font>              </b></li>              <li align="left"><b>                  <font size=2 color=gainsboro>optimized</font>              </b></li>              <li align="left"><b>                  <font size=2 color=mediumseagreen>${CMAKE_SOURCE_DIR}</font><font size=2 color=silver>/rlottie/sdk/release/rlottie.lib</font>              </b></li>              <li align="left"><b>                  <font size=2 color=silver>)</font>              </b></li>          </ol>      </td>  </tr>  </tbody>  </table></li></ul></li><li><p>Dlls</p><ul><li>Visual Studio: copy them to <em>Output Directory</em></li><li>CMakeLists  <table style="margin-bottom: 8px">  <tbody>  <tr style="border: none">      <td style="background: black; border: none; width: 100vw; border-radius: 4px">          <ol style="margin:0">              <li align="left"><b>                  <font size=2 color=white>cmake_path(CONVERT</font>                  <font size=2 color=peru>&ensp;"</font>                  <font size=2 color=mediumseagreen>${CMAKE_SOURCE_DIR}</font>                  <font size=2 color=white>/rlottie/sdk/$<CONFIG>/*.dll TO_NATIVE_PATH_LIST rlottie_dll_path)</font>              </b></li>                  <li align="left"><b>                  <font size=2 color=white>cmake_path(CONVERT</font><font size=2 color=peru>&ensp;"</font><font size=2 color=mediumseagreen>${CMAKE_RUNTIME_OUTPUT_DIRECTORY}</font><font size=2 color=peru>/"</font><font size=2 color=white>&ensp;TO_NATIVE_PATH_LIST runtime_output_ path)</font>              </b></li>              <li align="left"><b>                  <font size=2 color=steelblue>add_custom_command</font><font size=2 color=white>(</font><font size=2 color=steelblue>TARGET</font><font size=2 color=mediumseagreen>${XXX_TARGET_NAME}</font><font size=2 color=white>&ensp;POST_BUILD</font>              </b></li>              <li align="left"><b>                  <font size=2 color=steelblue>&emsp;&emsp;&emsp;&emsp;COMMAND</font><font size=2 color=white>&ensp;xcopy</font><font size=2 color=peru>&ensp;"</font><font size=2 color=mediumseagreen>${rlottie_dll_path}</font><font size=2 color=peru>"&ensp;"</font><font size=2 color=mediumseagreen>${runtime_output_path}</font><font size=2 color=peru>"</font><font size=2 color=white>&ensp;/y</font>              </b></li>              <li align="left"><b>                  <font size=2 color=steelblue>&emsp;&emsp;&emsp;&emsp;WORKING_DIRECTORY</font><font size=2 color=mediumseagreen>${CMAKE_CURRENT_SOURCE_DIR}</font>              </b></li>              <li align="left"><b>                  <font size=2 color=steelblue>&emsp;&emsp;&emsp;&emsp;COMMAND</font><font size=2 color=peru>&ensp;"Copying thirdparty files"</font><font size=2 color=steelblue>&ensp;VERBATIM</font>              </b></li>              <li align="left"><b>                  <font size=2 color=white>&emsp;&emsp;&emsp;)</font>              </b></li>          </ol>      </td>  </tr>  </tbody>  </table></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MSVC Compiler Prefined Macro -- 枚举(enum class)转字符串</title>
    <link href="/2023/01/23/CPP-Macro-Enum2String/"/>
    <url>/2023/01/23/CPP-Macro-Enum2String/</url>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><!--> block reference used head of paragragh, and can be nested.--><ul><li>Standard predefined identifier: 预定义标识符  <ul><li><code>__func__</code>: 返回所在函数闭包对应的函数名. 本质上是常量字符数组, 由编译器提供(ISO C99 &amp; ISO C++11), 格式: <code>const char __func__[]</code></li></ul></li><li>Standard predefined macro: 预定义宏<blockquote><p>MSVC supports the predefined preprocessor macros required by the ANSI&#x2F;ISO C99, C11, and C17 standards, and the ISO C++14, C++17, and C++20 standards. </p></blockquote><ul><li>可提供通用的辅助性信息<ul><li><code>__LINE__</code>: 提供当前函数所在的行号, 格式: 数字</li><li><code>__FILE__</code>: 当前函数所在的文件, 格式: 字符串</li><li><code>__DATE__</code>: 当前日期, 格式: <code>Jan 19 2023</code></li><li><code>__TIME__</code>: 当前时间信息, 格式: <code>22:35:41</code></li></ul></li><li>提供具体到函数调用的信息本文将利用 <code>__FUNCSIG__</code> 提供的信息, 模拟反射机制来将 enum 变量转为字符串 <ul><li><code>__FUNCTION__</code>: 提供所在闭包对应函数的函数名, 格式: 返回 <code>__func__</code> 的值</li><li><code>__FUNCDNAME__</code>: 提供函数修饰名, 格式: <code>?main@@YAHXZ</code> 或 <code>main</code> 或 <code>_main</code>（可理解为符号表中导出的符号）</li><li><code>__FUNCSIG__</code>: 提供函数的完整声明(同g++支持的宏:<code>__PRETTY_FUNCTION__</code>), 格式: <code>int __cdecl main(void)</code></li></ul></li></ul></li><li>编译方式: 导出符号的修饰规则, 会影响到部分预定义宏的返回结果<ul><li><code>extern &quot;C&quot;</code>: 不带修饰符. 此时, <code>__FUNCTION__</code> 与 <code>__FUNCDNAME__</code> 的值相同 </li><li>其他: 导出符号被修饰, 如: <code>?main@@YAHXZ</code>, 可拆分为 <code>?</code> + <code>main</code> + <code>@@</code> + <code>参数表代号</code><ul><li>修饰符: 用于函数重载</li><li>代号: XDEFHIJKMN_NU, 比如: @@YAHXZ可拆分为<ul><li>@@YA:起始位置, 也有@@YG, @@YI</li><li>H: 返回类型为 <code>int</code></li><li>X: 参数列表为空, 即 <code>void</code></li><li>Z: 结束位置, 也有@Z</li></ul></li></ul></li></ul></li><li>调用约定:   <ul><li><code>_cdecl</code>: C Declaration 的缩写, 即采用 C 语言的声明方式（C缺省调用方式）  <ul><li>参数从右—&gt;左依次入栈</li><li>手动清栈, 即由调用者来恢复堆栈</li></ul></li><li><code>_stdcall</code>: Standard Call 的缩写, 是 C++ 的标准调用方式. MSVC 宏有 <code>PASCAL</code>, <code>WINAPI</code>, <code>CALLBACK</code> <ul><li>参数从右—&gt;左依次入栈</li><li>自动清栈, 即由被调用函数来恢复堆栈</li></ul></li><li><code>_fastcall</code><ul><li>参数借由CPU寄存器(ecx, edx)和堆栈来处理参数信息, 从右—&gt;左依次入栈</li><li>自动清栈: 同<code>_stdcall</code>, 减轻调用者负担</li></ul></li></ul></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>业务开发过程中, 会遇到需要获取 <krd>Enum</krd> 的相关信息, 具体应用场景如下: </p><ul><li>配置信息: 枚举值本身在代码逻辑中用于归类; 枚举名在初始化阶段作为配置信息的索引</li><li>多语言: 完整的枚举名列表用于前端UI展示; 枚举值用于用户交互进行语言切换</li></ul><p>本文目标是模拟反射机制(c#, java), 获取对应枚举的相关信息. 由预备知识可知, <code>__FUNCSIG__</code> 可获取当前函数的完整声明信息(包括调用约定信息). 不由产生两个疑问: </p><ul><li><code>__FUNCSIG__</code> 是如何获得函数的完整声明?</li><li>函数的声明如何能获得任意类型的 <code>enum class</code> 的相关信息?</li></ul><p>好的问题远比答案重要: 在编译阶段, 模板函数会对所有的枚举类型进行实例化. 而实例化过程中, 传入的枚举类型及枚举值就是我们所需要的相关信息. 本文目标是提供操作枚举类型的工具函数, 如下:</p><ul><li><code>get_enum_name</code>: 通过枚举值, 获取对应名称</li><li><code>get_all_enum_names</code>: 获取枚举类型中所有值对应的名称列表</li><li><del><code>get_enum_value</code>: 通过名称, 获取对应枚举值</del></li><li><del><code>check_enum_valid</code>: 确认是否是有效的枚举(value or name)</del></li></ul><h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><p>考虑到兼顾不同编译器的情况, 需要对不同编译器提供的预定义宏进行适配. 个人比较喜欢 <code>__PRETTY_FUNCTION__</code>, 如下:   </p><ul><li><blockquote><p><a href="https://learn.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-170">msvc</a>: <code>__FUNCSIG__</code> Defined as a string literal that contains the signature of the enclosing function.</p></blockquote></li><li><blockquote><p><a href="https://gcc.gnu.org/onlinedocs/gcc/Function-Names.html">gcc</a>: In C, <code>__PRETTY_FUNCTION__</code> is yet another name for <code>__func__</code>, except that at file scope (or, in C++, namespace scope), it evaluates to the string “top level”. In addition, in C++, <code>__PRETTY_FUNCTION__</code> contains the signature of the function as well as its bare name.</p></blockquote></li></ul><table style="margin-bottom: 8px;">    <tbody>        <tr style="border: none">            <td style="background: black; border: none; width: 100vw; border-radius: 4px">                <ol style="margin:0;">                    <li align="left"><b>                        <font size=2 color=silver>#if&ensp;!defined(</font><font size=2 color=peru>__PRETTY_FUNCTION__</font><font size=2 color=silver>)&ensp;&&&ensp;!defined(</font><font size=2 color=gainsboro>__GNUC__</font><font size=2 color=silver>)</font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=silver>#&emsp;&emsp;define</font>                        <font size=2 color=mediumpurple>__PRETTY_FUNCTION__</font>                        <font size=2 color=peru>__FUNCSIG__</font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=silver>#endif</font>                    </b></li>                </ol>            </td>        </tr>    </tbody></table>  <p>同时, 提供工具函数用于遍历枚举类的所有枚举值: 根据阈值 <code>boundary</code>, 生成枚举值所在范围列表 [-boundary, boundary)  </p><table style="margin-top: 8px">    <tbody>        <tr style="border: none">            <td style="background: black; border: none; width: 100vw; border-radius: 4px">                <ol style="margin:0;">                        <li align="left"><b>                        <font size=2 color=steelblue>template</font><font size=2 color=silver>&ensp;<</font><font size=2 color=steelblue>int</font><font size=2 color=silver>...</font><font size=2 color=gainsboro>&ensp;sequence</font><font size=2 color=silver>></font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=steelblue>constexpr&ensp;auto</font><font size=2 color=lemonchiffon>&ensp;make_sequence_impl</font><font size=2 color=silver>(std::</font><font size=2 color=mediumseagreen>index_sequence</font><font size=2 color=silver><</font><font size=2 color=gainsboro>sequence</font><font size=2 color=silver>...>&ensp;seq)&ensp;{</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&ensp;return</font><font size=2 color=silver>&ensp;std::</font><font size=2 color=mediumseagreen>integer_sequence</font><font size=2 color=silver><</font><font size=2 color=steelblue>int</font><font size=2 color=silver>,&ensp;(</font><font size=2 color=gainsboro>sequence&ensp;-</font><font size=2 color=silver>&ensp;seq.</font><font size=2 color=gainsboro>size</font><font size=2 color=silver>())...,</font><font size=2 color=gainsboro>&ensp;sequence</font><font size=2 color=silver>...>();</font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=silver>}</font>                    </b></li>                                           <li align="left"><b>                        <font size=2 color=steelblue>template</font><font size=2 color=silver>&ensp;<</font><font size=2 color=steelblue>int</font><font size=2 color=gainsboro>&ensp;boundary</font><font size=2 color=silver>,</font><font size=2 color=steelblue>&ensp;typename</font><font size=2 color=mediumseagreen>&ensp;indices</font><font size=2 color=silver>&ensp;=&ensp;std::</font><font size=2 color=mediumseagreen>make_index_sequence</font><font size=2 color=silver><</font><font size=2 color=gainsboro>boundary</font><font size=2 color=silver>>></font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=steelblue>constexpr&ensp;auto</font><font size=2 color=lemonchiffon>&ensp;make_sequence</font><font size=2 color=silver>()&ensp;{</font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&ensp;return</font><font size=2 color=gainsboro>&ensp;make_sequence_impl</font><font size=2 color=silver>(</font><font size=2 color=mediumseagreen>indices</font><font size=2 color=silver>());</font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=silver>}</font>                    </b></li>                </ol>            </td>        </tr>    </tbody></table>  <h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li><code>get_enum_name</code>: 由于 <code>std::regex</code> 不支持 look behind, 此处藉由 <code>QRegualr</code> 实现对编译期常量<b><font color=gainsboro><code>V</code></font></b>和类型<b><font color=mediumseagreen><code>E</code></font></b>的捕获.</li></ul><table>    <tbody>        <tr style="border: none">            <td style="background: black; border: none; width: 100vw; border-radius: 4px">                <ol style="margin:0;">                    <li><b>                        <font size=2 color=steelblue>template</font><font size=2 color=silver>&ensp;<</font><font size=2 color=steelblue>typename</font><font size=2 color=MediumSeaGreen>&ensp;E</font><font size=2 color=silver>,</font><font size=2 color=MediumSeaGreen>&ensp;E</font><font size=2 color=gainsboro>&ensp;V</font><font size=2 color=silver>></font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=steelblue>constexpr</font><font size=2 color=silver>&ensp;std::</font><font size=2 color=MediumSeaGreen>string</font><font size=2 color=LemonChiffon>&ensp;get_enum_name</font><font size=2 color=silver>()&ensp;{</font>                    </b></li>                    <b><li align="left">                        <font size=2 color=silver>&emsp;&emsp;&ensp;std::</font><font size=2 color=mediumseagreen>string</font><font size=2 color=skyblue>&ensp;name</font><font size=2 color=silver>(</font><font size=2 color=mediumpurple>__PRETTY_FUNCTION__</font><font size=2 color=silver>);</font>                    </b></li>                    <b><li align="left">                        <font size=2 color=mediumseagreen>&emsp;&emsp;&ensp;QRegularExpression</font><font size=2 color=skyblue>&ensp;reg</font><font size=2 color=silver>(</font><font size=2 color=peru>"(?<=::)[a-zA-Z_]+[</font><font size=2 color=navajowhite>\\</font><font size=2 color=peru>w]*(?=>)"</font><font size=2 color=silver>);</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumseagreen>&emsp;&emsp;&ensp;QRegularExpressionMatch</font><font size=2 color=skyblue>&ensp;match</font><font size=2 color=silver>&ensp;=</font><font size=2 color=skyblue>&ensp;reg</font><font size=2 color=silver>.</font><font size=2 color=lemonchiffon>match</font><font size=2 color=silver>(</font><font size=2 color=skyblue>name</font><font size=2 color=silver>.</font><font size=2 color=lemonchiffon>c_str</font><font size=2 color=silver>());</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumseagreen>&emsp;&emsp;&ensp;QString</font><font size=2 color=skyblue>&ensp;matched</font><font size=2 color=silver>&ensp;=</font><font size=2 color=lemonchiffon>&ensp;""</font><font size=2 color=silver>;</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&ensp;if</font>                        <font size=2 color=silver>(</font><font size=2 color=skyblue>match</font><font size=2 color=silver>.</font><font size=2 color=lemonchiffon>hasMatch</font><font size=2 color=silver>())&ensp;{</font>                    </b></li>                    <li><b>                        <font size=2 color=skyblue>&emsp;&emsp;&emsp;&emsp;matched</font><font size=2 color=silver>&ensp;=</font><font size=2 color=skyblue>&ensp;match</font><font size=2 color=silver>.</font><font size=2 color=lemonchiffon>captured</font><font size=2 color=silver>(</font><font size=2 color=powderblue>0</font><font size=2 color=silver>);</font>                    </b></li>                    <li><b>                        <font size=2 color=silver>&emsp;&emsp;&ensp;}</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&ensp;return</font><font size=2 color=skyblue>&ensp;matched</font><font size=2 color=silver>.</font><font size=2 color=lemonchiffon>size</font><font size=2 color=silver>()&ensp;></font><font size=2 color=powderblue>&ensp;0</font><font size=2 color=silver>&ensp;?</font><font size=2 color=skyblue>&ensp;matched</font><font size=2 color=silver>.</font><font size=2 color=lemonchiffon>toStdString</font><font size=2 color=silver>()&ensp;:</font><font size=2 color=burlywood>&ensp;""</font><font size=2 color=silver>;</font>                    </b></li>                    <li><b>                        <font size=2 colro=silver>}</font>                    </b></li>                </ol>            </td>        </tr>    </tbody></table>  <ul><li><code>get_all_enum_names</code>:</li></ul><table>    <tbody>        <tr style="border: none">            <td style="background: black; border: none; width: 100vw; border-radius: 4px">                <ol style="margin:0;">                    <li><b>                        <font size=2 color=steelblue>template</font><font size=2 color=silver>&ensp;<</font><font size=2 color=steelblue>typename</font><font size=2 color=mediumseagreen>&ensp;T</font><font size=2 color=silver>,</font><font size=2 color=steelblue>&ensp;int</font><font size=2 color=silver>...</font><font size=2 color=gainsboro>&ensp;Ints</font><font size=2 color=silver>></font>                    </b></li>                    <li><b>                        <font size =2 color=steelblue>constexpr&ensp;auto</font><font size =2 color=lemonchiffon>&ensp;get_all_enum_names</font><font size =2 color=silver>(std::</font><font size =2 color=mediumseagreen>integer_sequence</font><font size =2 color=silver><</font><font size =2 color=steelblue>int</font><font size=2 color=silver>,</font><font size=2 color=gainsboro>&ensp;Ints</font><font size=2 color=silver>...>)&ensp;{</font>                    </b></li>                    <li><b>                        <font size=2 color=silver>&emsp;&emsp;&ensp;std::</font><font size=2 color=mediumseagreen>array</font><font size=2 color=silver><</font><font size=2 color=silver>std::</font><font size=2 color=mediumseagreen>string</font><font size=2 color=silver>,</font><font size=2 color=steelblue>&ensp;sizeof</font><font size=2 color=silver>...(</font><font size=2 color=gainsboro>Ints</font><font size=2 color=silver>)></font><font size=2 color=skyblue>&ensp;names</font><font size=2 color=silver>{</font><font size=2 color=gainsboro>&nbsp;get_enum_name</font><font size=2 color=silver><</font><font size=2 color=mediumseagreen>T</font><font size=2 color=silver>,</font><font size=2 color=steelblue>&ensp;static_cast</font><font size=2 color=silver><</font><font size=2 color=mediumseagreen>T</font><font size=2 color=silver>>(</font><font size=2 color=gainsboro>Ints</font><font size=2 color=silver>)>()...&nbsp;};</font>                    </b></li>                    <li><b>                        <font size=2 color=silver>&emsp;&emsp;&ensp;std::</font><font size=2 color=mediumseagreen>vector</font><font size=2 color=silver><</font><font size=2 color=silver>std::</font><font size=2 color=mediumseagreen>string</font><font size=2 color=silver>></font><font size=2 color=skyblue>&ensp;valid</font><font size=2 color=silver>{};</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&ensp;for</font><font size=2 color=silver>&ensp;(</font><font size=2 color=steelblue>auto const</font><font size=2 color=silver>&</font><font size=2 color=skyblue>&ensp;name</font><font size=2 color=silver>&ensp;:</font><font size=2 color=skyblue>&ensp;names</font><font size=2 color=silver>)&emsp;{</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&emsp;&emsp;&ensp;if</font><font size=2 color=silver>&ensp;(</font><font size=2 color=skyblue>name</font><font size=2 color=silver>.</font><font size=2 color=gainsboro>size</font><font size=2 color=silver>()&ensp;==</font><font size=2 color=powderblue>&ensp;0</font><font size=2 color=silver>)</font><font size=2 color=mediumorchid>&ensp;continue</font><font size=2 color=silver>;</font>                    </b></li>                     <li><b>                        <font size=2 color=skyblue>&emsp;&emsp;&emsp;&emsp;&ensp;valid</font><font size=2 color=silver>.</font><font size=2 color=gainsboro>push_back</font><font size=2 color=silver>(</font><font size=2 color=skyblue>name</font><font size=2 color=silver>);</font>                    </b></li>                                   <li><b>                        <font size=2 color=silver>&emsp;&emsp;&ensp;}</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&ensp;return</font><font size=2 color=skyblue>&ensp;valid</font><font size=2 color=silver>;</font>                    </b></li>                    <li><b>                         <font size=2 color=silver>}</font>                   </b></li>                </ol>            </td>        </tr>    </tbody></table>  <h1 id="接口封装"><a href="#接口封装" class="headerlink" title="接口封装"></a>接口封装</h1><table>    <tbody>        <tr style="border: none">            <td style="background: black; border: none; width: 100vw; border-radius: 4px">                <ol style="margin:0;">                    <li><b>                        <font size=2 color=steelblue>template</font><font size=2 color=silver>&ensp;<</font><font size=2 color=steelblue>typename</font><font size=2 color=mediumseagreen>&ensp;T</font><font size=2 color=silver>,</font><font size=2 color=steelblue>&ensp;int</font><font size=2 color=gainsboro>&ensp;boundary</font><font size=2 color=silver>></font>                    </b></li>                    <li><b>                        <font size=2 color=steelblue>auto</font><font size=2 color=gainsboro>&ensp;enum_names</font><font size=2 color=silver>&ensp;=</font><font size =2 color=gainsboro>&ensp;get_all_enum_names</font><font size =2 color=silver><</font><font size =2 color=mediumseagreen>T</font><font size =2 color=silver>>(</font><font size=2 color=gainsboro>make_sequence</font><font size=2 color=silver><</font><font size=2 color=gainsboro>boundary</font><font size=2 color=silver>>());</font>                    </b></li>                </ol>            </td>        </tr>    </tbody></table>  ]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
