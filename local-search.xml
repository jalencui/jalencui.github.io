<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>cUI 系列 -- 窗口绘制</title>
    <link href="/2025/10/12/cUI-windowpaint/"/>
    <url>/2025/10/12/cUI-windowpaint/</url>
    
    <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>任何 UI 框架的基础能力：显示一幅 “图”。<br>这幅 “图” 的可能来源：静态图片, 动画帧，解码后的视频帧，亦或是 OSR 模式下 CEF3 渲染进程输出的页面帧等。</p><h1 id="二、关键技术"><a href="#二、关键技术" class="headerlink" title="二、关键技术"></a>二、关键技术</h1><h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><p>这里给出可选项：</p><ul><li>WIC: 微软提供的图像编解码框架，支持 BMP, JPEG，PNG, GIF, TIFF, ICO 等；</li><li>Bitmap (C#): 基于 WIC。但是，仅支持解析 GIF 的第一帧。</li><li>stb：三方插件，不支持矢量图 svg。</li><li>skia: 三方插件，完美支持各式资源（位图, 矢量图，动画）。</li></ul><p>本示例程序，使用 Bitmap 和 skia 实现了所有图片格式的解码。为侧重于渲染，skia 解码部分已删减。</p><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>这里给出可选项：</p><ul><li>GDI：底层API, 直接与硬件交互，更接近操作系统；</li><li>GDI+: GDI 的封装与扩展；</li><li>Direct2D: 同 opengl 和 vulkan, 充分利用 GPU 资源。考虑到兼容性，此部分会作为 cUI 框架的扩展功能。</li></ul><p>本示例程序沿用更底层的 GDI 工具。这里给出 GDI 常用接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">CreateCompatibleDC</span>() <span class="hljs-comment">// 创建内存设备上下文</span><br><br><span class="hljs-built_in">SelectObject</span>() <span class="hljs-comment">// 选择GDI对象（位图、画笔等）</span><br><br><span class="hljs-built_in">SetStretchBltMode</span>() <span class="hljs-comment">// 设置位图拉伸模式，即插值方式</span><br><br><span class="hljs-built_in">StretchBlt</span>() <span class="hljs-comment">// 位块传输（拉伸复制）</span><br><br><span class="hljs-built_in">DeleteDC</span>() <span class="hljs-comment">// 删除设备上下文</span><br></code></pre></td></tr></table></figure><h1 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h1><h2 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h2><ul><li>静态图片： 绘制功能；</li><li><del>动态图片： 绘制功能；基于 Timer 的按需刷新及缓存机制。</del></li></ul><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>该示例仅包含通用的 win32 接口和标准 thread 接口调用。<br><a href="https://github.com/jalencui/cUI/tree/master/WindowPaint"><strong>点我获取示例程序</strong></a></p><h1 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h1><p>该系列后续示例程序，将会回归更简洁的开发语言 c&#x2F;c++。 期待下一篇：桌面通知~  </p>]]></content>
    
    
    <categories>
      
      <category>cUI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cUI 系列 -- 任务栏托盘</title>
    <link href="/2025/10/11/cUI-tray/"/>
    <url>/2025/10/11/cUI-tray/</url>
    
    <content type="html"><![CDATA[<h1 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h1><p>常规的桌面端后台应用程序：没有通俗意义上的 UI 线程。此时，它需要一个任务栏图标。</p><h1 id="二、客户端构成"><a href="#二、客户端构成" class="headerlink" title="二、客户端构成"></a>二、客户端构成</h1><p>鉴于系列首篇，额外插入该环节。</p><ul><li>物理载体：窗口，比如：windows 中的 win32 窗口。</li><li>逻辑载体：“UI 线程” 和它的消息队列，用于维护或者共享当前的输入状态，比如：键盘状态，焦点窗口。</li><li>消息循环：用于处理属于 “UI 线程” 的所有消息。</li></ul><h1 id="三、问答"><a href="#三、问答" class="headerlink" title="三、问答"></a>三、问答</h1><p>鉴于系列首篇，额外插入该环节。</p><ul><li>什么是 “UI 线程”？<br>没有所谓的 “UI 线程”，它是所有非系统线程的代名词，也即：任何“用户线程”都可以作为 “UI 线程”。</li><li>单进程可以拥有两个 “UI 线程”吗？<br>可以，没有理论上限。</li><li>消息循环的转发机制？<br>系统队列 –&gt; 线程队列（Input Desktop） –&gt; 窗口过程。</li><li>窗口与对话框的区别？<br>还真有区别，自行 deepseek 吧。对话框（非模态，窗口级模态，进程级模态）算是高度定制的窗口。同时，对话框拥有特定的创建接口，消息类型等。</li></ul><h1 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h1><h2 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h2><p>示例程序使用单独的线程，来维护消息窗口的消息循环。消息窗口的作用，如下所示：</p><ul><li>托盘图标：指定的父窗口可接收任务栏图标的交互事件。特定事件构成：自定义的托盘消息 &amp; lParam 参数。</li><li>右键菜单：指定的父窗口可接收右键菜单的交互事件。特定事件构成：WM_COMMAND 消息 &amp; 自定义参数。</li></ul><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>该示例仅包含通用的 win32 接口和标准 thread 接口调用。此 C# 代码也可以无缝转为 C&#x2F;C++ (无需 P&#x2F;Invoke, 更简单).<br><a href="https://github.com/jalencui/cUI/tree/master/SystemTray"><strong>点我获取示例程序</strong></a></p>]]></content>
    
    
    <categories>
      
      <category>cUI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cUI 系列 -- 规划</title>
    <link href="/2025/10/09/cUI-planning/"/>
    <url>/2025/10/09/cUI-planning/</url>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p> cUI 将会是一款基于 win32 实现的 UI 框架。力求精简，即：最少依赖，最小包体体积。</p><h1 id="二、规划"><a href="#二、规划" class="headerlink" title="二、规划"></a>二、规划</h1><ul><li>任务栏托盘<br>桌面客户端的基础能力，包括：任务栏托盘图标，托盘右键菜单。</li><li>窗口绘制<br>桌面客户端的基础能力，包括：位图(bmp, png, jpg)，矢量图（svg），动图（gif, webp, lottie）。</li><li>桌面通知<br>桌面客户端的特殊能力。监于过于通用，那就把 windows SDK 的能力拿来剖析一下。</li><li>常规控件<br>桌面客户端的基础能力，包括：Button, COMBOBOX, EDIT, LISTBOX, MDICLIENT, RichEdit, SCROLLBAR等。</li><li>…</li></ul><h1 id="三、备注"><a href="#三、备注" class="headerlink" title="三、备注"></a>三、备注</h1><p>1、该系列不局限于某一开发语言。但，仅涉及 win32 接口和所有开发语言都具备的标准接口。<br>2、该系列仅提供客户端方面的基础能力。所以，图片解析，GDI绘制等特定技术栈不在讨论范围。<br>3、该系列的目标是实现一种 UI 框架，基础设施往往是最难的。所以，简单的示例也会涉及：线程，窗口，windows消息，定时器等。</p>]]></content>
    
    
    <categories>
      
      <category>cUI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OpenGL 系列 -- 渲染性能优化随记</title>
    <link href="/2025/02/15/Opengl-Practice-1/"/>
    <url>/2025/02/15/Opengl-Practice-1/</url>
    
    <content type="html"><![CDATA[<p>张三丰：“无忌，我教你的还记得多少？”<br>张无忌：“回太师傅，我只记得一大半。”<br>…<br>张三丰：“那现在呢？”<br>张无忌：“已经剩下一小半了。”<br>…<br>张三丰：“那现在呢？”<br>张无忌：“我已经把所有的全忘记了。”</p><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><p>知识科普部分对相关概念一带而过。但对新同学至关重要 – 避免在庞杂的书面知识上浪费时间。<br>技术选型部分对相关技术仅给出当前考量 – 方向是对的，剩下的就是工作量。<br>技术细节部分对相关技术细节的设计作详细阐述 – 浪费您的时间了。</p><h1 id="知识科普"><a href="#知识科普" class="headerlink" title="知识科普"></a>知识科普</h1><p>本文提及渲染时，统一默认为 OpenGL(或OpenGL ES) 和它的 GLSL。同时，文中尽量减少不必要的专业名词或术语。</p><h2 id="什么是-OpenGL"><a href="#什么是-OpenGL" class="headerlink" title="什么是 OpenGL?"></a>什么是 OpenGL?</h2><p>请从状态机的角度，去理解它。<br>请从客户机&#x2F;服务器的角度，去理解它。</p><h2 id="什么是-OpenGL-1"><a href="#什么是-OpenGL-1" class="headerlink" title="什么是 OpenGL?"></a>什么是 OpenGL?</h2><p>如果从 OpenGL 以什么方式完成什么事情的角度，更愿意把它看作一个“建模大师” –（拿来用而已）</p><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>提及 RGB, 大多数人习以为常。<br>提及 BGR，OpenCV开发人员比较熟悉（默认颜色空间）。<br>至于其他的颜色空间，也只是表示方式不同。颜色处理时，99%的情况要转为 RGB 三成分。数据传输时，按需转为其他格式。</p><h4 id="在解码时，要输出哪种格式？"><a href="#在解码时，要输出哪种格式？" class="headerlink" title="在解码时，要输出哪种格式？"></a>在解码时，要输出哪种格式？</h4><p>这是数据源要关注的点。如果从渲染的角度判断，那就是：当前显卡驱动支持的最优格式。</p><h4 id="对于渲染链路中的数据，要注意什么？"><a href="#对于渲染链路中的数据，要注意什么？" class="headerlink" title="对于渲染链路中的数据，要注意什么？"></a>对于渲染链路中的数据，要注意什么？</h4><ul><li>尽量保持数据大小和数据格式不变，以减少格式转换带来的额外开销。</li><li>尽量通过代码设计避免数据copy，以减少不必要的开销。</li><li>尽量拥抱新知识，将耗时操作从 CPU 转移到 GPU。</li></ul><h3 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h3><p>基础领域的研究成果，拿来用用而已（模拟现实是VR，增强现实是AR等）</p><h4 id="对光源的划分"><a href="#对光源的划分" class="headerlink" title="对光源的划分"></a>对光源的划分</h4><p>光源划分本身就是一个建模的过程。比如：太阳光定义为平行光；白炽灯定义为点光源。</p><h4 id="对光源成分的划分"><a href="#对光源成分的划分" class="headerlink" title="对光源成分的划分"></a>对光源成分的划分</h4><p>同样是一个建模的过程，比如：环境光，漫反射，高光反射等。</p><h4 id="对光源成分建模"><a href="#对光源成分建模" class="headerlink" title="对光源成分建模"></a>对光源成分建模</h4><p>一堆计算公式而已，比如：Lambert模型， Half-Lambert模型， Phong模型，Blinne-Phong模型。建议忽略该部分，这是 TA 操心的事情。</p><h3 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h3><p>无论是一场 AR 直播，一个复杂的游戏场景，或者一幅图片，在生动的视觉效果背后都存在一个摸不着的虚拟世界。虚拟世界的完整描述，依赖各类坐标系（左右手）：世界坐标系，模型坐标系，观察坐标系，裁剪坐标系。借助这些信息，渲染流水线得以完成各种变换（MVP）。</p><ul><li>世界坐标系描述了所有模型和光源位置</li><li>光照计算需要在模型坐标系下进行</li><li>视图坐标系定义了相机的位姿，直接影响画面的输出</li><li>裁剪坐标系是经过透视除法后的坐标系，设计正交投影和透视投影。其中，透视投影矩阵是对近大远小等透视效果的建模。</li></ul><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>对人物或物体的建模，本质上就是描述其轮廓&#x2F;包络&#x2F;网格的过程。下面对一个模型文件进行分析：</p><h4 id="准备环节"><a href="#准备环节" class="headerlink" title="准备环节"></a>准备环节</h4><p>通过资源网站下载或者 blender 生成模型文件。为避免展开话题，我们限定模型文件格式为 .obj。</p><h4 id="格式定义"><a href="#格式定义" class="headerlink" title="格式定义"></a>格式定义</h4><p>mtllib 部分：忽略该部分（包含各种反射的参数信息，纹理文件信息等内容）<br>object 部分：必备参数（:v, :f），可选参数（:vt, :vn）。</p><ul><li>必备参数：顶点:v 和三角面:f 完整描述了物体的包络&#x2F;网格。</li><li>可选参数：忽略该部分（纹理顶点:vt 描述了贴图的映射信息，顶点法线:vn 用于光照计算）</li></ul><h4 id="应用分析"><a href="#应用分析" class="headerlink" title="应用分析"></a>应用分析</h4><p>必备参数完整描述了模型的包络信息。可选参数算是辅助信息，比如：顶点法线用于光照计算（可在导入引擎时生成）；纹理顶点相当于物体&#x2F;人物贴图映射关系等等。</p><ul><li>对于 OpenGL 开发来说，控制如何绘制顶点是比较重要的一环。比如：<ul><li>需要初始化 VBO 信息，也即顶点:v</li><li>需要初始化 EBO 信息，也即顶点索引:f</li><li>可能需要初始化 VAO，也即元数据。它描述各个 buffer 的数据存储信息（VBO，EBO）</li><li>可能需要初始化 PBO，用于释放 glTextureSubImage2D 操作的 cpu 占用</li></ul></li><li>对于引擎应用开发来说，更多的工作集中在 shader 及 shader 参数配置</li></ul><h2 id="什么是-OpenGL-2"><a href="#什么是-OpenGL-2" class="headerlink" title="什么是 OpenGL?"></a>什么是 OpenGL?</h2><p>请忘掉上述回复。对于常规 opengl 开发，它跟普通的库没有区别。只需要了解相关接口即可。</p><ul><li>非必要，不要引入 MVP。比如：视频帧渲染，如果默认 MVP 都是单位阵，试试有什么效果?</li><li>非必要，不要接触光照，那是 TA 操心的内容。再者，视频帧渲染跟光照没有半毛钱关系。</li><li>没必要接触模型。对于视频帧或者图片渲染来说，模型就是四个顶点（两个三角面&#x2F;一个四边面）。</li></ul><h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><h2 id="QT-技术栈"><a href="#QT-技术栈" class="headerlink" title="QT 技术栈"></a>QT 技术栈</h2><h3 id="qt-quick"><a href="#qt-quick" class="headerlink" title="qt quick"></a>qt quick</h3><p>不存在渲染性能问题，qt quick 默认采用 gpu 渲染。在禁用 gpu （qt::aa_usesoftwareopengl）的情况下，才会 fallback。</p><h3 id="qt-qwidget"><a href="#qt-qwidget" class="headerlink" title="qt qwidget"></a>qt qwidget</h3><p>qwidget 是采用 cpu 渲染。如果想利用 gpu 的优势，需要借助 qopenglwidget 控件，并且需要大量的工作</p><ul><li>oepngl 版本控制： 兼容用户的显卡驱动版本<ul><li>pbo 技术： gles 4.2, opengl 3.3 才得以支持</li><li>gl_polygon 枚举：旧版本的参数在新版本已被舍弃</li><li>shader 指令： gles 中 inout 参数需要提供精度信息</li><li>…</li></ul></li><li>fallback 操作：对于禁用 gpu 的场景，需要额外提供软渲作为兜底</li><li>opengl 渲染：需要同时支持 opengl 和 gles</li><li>软渲：用于 fallback 场景</li></ul><h2 id="QT-渲染属性"><a href="#QT-渲染属性" class="headerlink" title="QT 渲染属性"></a>QT 渲染属性</h2><h3 id="qt-aa-usedefault-qt-没有该枚举，用于占位"><a href="#qt-aa-usedefault-qt-没有该枚举，用于占位" class="headerlink" title="qt::aa_usedefault (qt 没有该枚举，用于占位)"></a>qt::aa_usedefault (qt 没有该枚举，用于占位)</h3><p>默认情况下， qt 会渲染当前显卡驱动的 opengl 版本，比如：4.6</p><h3 id="qt-aa-useopengles"><a href="#qt-aa-useopengles" class="headerlink" title="qt::aa_useopengles"></a>qt::aa_useopengles</h3><p>当指定该渲染属性时，qt 会选择显卡驱动支持的 gles 版本，比如：2.0</p><h3 id="qt-aa-usesoftwareopengl"><a href="#qt-aa-usesoftwareopengl" class="headerlink" title="qt::aa_usesoftwareopengl"></a>qt::aa_usesoftwareopengl</h3><p>当指定该渲染属性时，当前应用中的所有 ui 渲染都会 fallback</p><h2 id="QT-渲染方式"><a href="#QT-渲染方式" class="headerlink" title="QT 渲染方式"></a>QT 渲染方式</h2><h3 id="paintevent-with-qpainter"><a href="#paintevent-with-qpainter" class="headerlink" title="paintevent(*) with qpainter"></a>paintevent(*) with qpainter</h3><p>qwidget 提供的渲染接口，也即上文的软渲。由于 qopenglwidget 是继承至 qwidget，所以需要实现该接口用于 fallback 场景</p><h3 id="paintgl-with-qpainter"><a href="#paintgl-with-qpainter" class="headerlink" title="paintgl() with qpainter"></a>paintgl() with qpainter</h3><p>提供了灵活支持，可以使用一些非 opengl 指令。但该操作本身会占用 cpu</p><h3 id="paintgl-with-opengl-commands"><a href="#paintgl-with-opengl-commands" class="headerlink" title="paintgl() with opengl commands"></a>paintgl() with opengl commands</h3><p>即是 opengl 渲染~</p><h2 id="OpenGL-amp-Shader"><a href="#OpenGL-amp-Shader" class="headerlink" title="OpenGL &amp; Shader"></a>OpenGL &amp; Shader</h2><h3 id="opengl-与着色器-shader-是什么关系呢？"><a href="#opengl-与着色器-shader-是什么关系呢？" class="headerlink" title="opengl 与着色器 shader 是什么关系呢？"></a>opengl 与着色器 shader 是什么关系呢？</h3><p>对于 opengl 来说，glsl 算是一个辅助工具。借用《红宝书第七版》的描述： glsl 可以进一步发掘 OpenGL 的现代硬件实现的计算威力。 如果没有shader, 某些计算只能在 cpu 中进行。</p><h3 id="不使用-shader，-opengl-可以完成常规渲染操作吗？"><a href="#不使用-shader，-opengl-可以完成常规渲染操作吗？" class="headerlink" title="不使用 shader， opengl 可以完成常规渲染操作吗？"></a>不使用 shader， opengl 可以完成常规渲染操作吗？</h3><p>对于引擎应用开发来说，不行。引擎应用开发唯一能操作的就是shader，他们无需关心 opengl 底层接口。<br>对于非引擎应用开发，shader 是一个可选项。多重纹理渲染那的场景：</p><ul><li>当纹理大小完全匹配时，单次 draw call 即可完成</li><li>当纹理大小不完全匹配且某些纹理需要等比缩放（cover 模式）<ul><li>opengl 实现： 使用独立的顶点和纹理映射，多次 draw call 即可完成（配合 blend separate）</li><li>shader 实现： 多次 draw call 比较麻烦；单次 draw call 时，需要借助 cpu 完成对各个纹理进行缩放和平移</li></ul></li></ul><p>注：draw call 是引擎渲染中的术语。对于 opengl 开发，就是一次顶点接口调用，如：glDrawElements。</p><h2 id="阅读推荐"><a href="#阅读推荐" class="headerlink" title="阅读推荐"></a>阅读推荐</h2><p>《OpenGL 红宝书第七版》：建议精读。后续接触新知识时，会更容易理解它们的由来。<br>《OpenGL 红宝书第九版》：大部分内容趋于同质化。只需了解最新的纹理及多重纹理内容即可。<br>《OpenGL ES 3.0 编程指南》：工具书，方便查询接口。</p><h1 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h1><p>截至前两部分，本文基本上已经完成。代码是廉价的，偷懒不想再作详细介绍~~ bye</p><ul><li>1282 error: 参数错误。 opengl 不同版本会舍弃一些参数；</li><li>1281 error: 接口报错，比如：pbo 映射内存时，没有进行 bind 操作；</li><li>gltex<em>image</em> 接口：比较耗时哦。尽量合理利用；</li><li>ffmpeg 解码：尽量借助帧间隔（sleep）完成对一阵纹理的提交，避免多余的内存 copy。</li></ul>]]></content>
    
    
    <categories>
      
      <category>OpenGL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Video 系列 -- 性能优化方案调研</title>
    <link href="/2025/01/11/Video-PerformanceOptimize-Solution/"/>
    <url>/2025/01/11/Video-PerformanceOptimize-Solution/</url>
    
    <content type="html"><![CDATA[<h1 id="整体方案思路"><a href="#整体方案思路" class="headerlink" title="整体方案思路"></a>整体方案思路</h1><h2 id="vlc调研"><a href="#vlc调研" class="headerlink" title="vlc调研"></a>vlc调研</h2><p>vlc组件支持两种视频播放模式：渲染至窗口，渲染至图片。</p><ul><li>渲染至窗口：<ul><li>对于windows原生开发来说，《渲染至窗口》的整体流程更简洁。同时，也丧失了一定的灵活性。比如：视频帧的后处理。</li><li>对于qt开发来说，《渲染至窗口》需要获取qt空间的窗口句柄winId。但是，winId会导致窗口继承链中的事件处理中断。</li></ul></li><li>渲染至图片：<ul><li>相对比较灵活，通用的方式，它不受具体开发框架的限制。</li></ul></li></ul><h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul><li>原生控件 – 单纹理绘制：既支持 <span style="color:red">渲染至窗口</span>，也支持渲染至图片</li><li>原生控件 – 多纹理绘制：需要与指定的视频帧进行alpha混合（其它纹理即蒙层等）， <span style="color:red">“不支持渲染至窗口”</span></li><li>原生控件 – qml 绘制：需要提供视频帧， <span style="color:red">“不支持渲染至窗口”</span></li><li>H5控件 – 单纹理绘制： 无需额外解码，仅视频帧渲染流程需要优化</li></ul><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>桌面应用开发基本上会涉及音视频播放：原生视频播放，H5视频播放。</p><h1 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h1><ul><li>原生：视频帧渲染环节，视频解码环节</li><li>H5: 视频帧渲染环节</li></ul><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>方向1：Qt 开发框架下，有三种图片渲染：QWidget::paint, QML::Image, QOpenGLWidget。其中，QOpenGLWidget提供了多种方式。我们采用它的opengl渲染流程 <b>（原生+H5）</b></p><p><del><span style="color:red">方向2（V1）：使用第三方组件库vlc，重构端内的视频解码+渲染流程，即：直接将视频帧渲染至指定窗口  <b>（仅原生）</b></span></del></p><p><del><span style="color:red">方向2（V2）: 使用第三方组件库vlc，重构端内的视频解码流程，即：vlc作为独立进程负责解码并输出纹理texture2d。最终的渲染操作依赖方向1的实现 <b>（仅原生）</b></span></del></p><p>方向2（终版）：使用第三方组件库vlc，重构端内的视频解码实现，即：vlc作为库形式嵌入应用。通过vlc回调实时刷新视频帧，并由方向1的渲染流程负责最终显示 <b>（仅原生）</b></span></p><p><img src="/2025/01/11/Video-PerformanceOptimize-Solution/Video_PerformanceOpt.drawio.png"></p><p><del><span style="color:red">向3：现有CEF3采用OSR渲染模式, 除了方向1提及的opengl渲染外，我们可选CEF提供的非OSR渲染模式。即：子窗口和弹窗模式<b>（仅H5）方案不可行</b><span></del></p><h1 id="实现（方向2）"><a href="#实现（方向2）" class="headerlink" title="实现（方向2）"></a>实现（方向2）</h1><p>从播放器的角度，音视频仅需仅需1份ffmpeg解码，1份视频帧渲染。具体如下：<br><img src="/2025/01/11/Video-PerformanceOptimize-Solution/Video_PlaybackFramework.drawio.png"></p><h1 id="业务相关"><a href="#业务相关" class="headerlink" title="业务相关"></a>业务相关</h1><p>桌面应用开发中，音视频播放流程基本上要兼顾通用播放器的大部分功能：</p><ul><li>音视频控制逻辑：支持暂停，继续，销毁</li><li>音视频切换逻辑：需要支持不同视频的切换等</li></ul>]]></content>
    
    
    <categories>
      
      <category>Video</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【杂项】Windows 异形窗体</title>
    <link href="/2024/09/17/Windows-HeteroTypeWindow/"/>
    <url>/2024/09/17/Windows-HeteroTypeWindow/</url>
    
    <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>桌面客户端非规则窗体实现。同时，需要保留窗口的缩放、鼠标穿透、跨屏拖放等交互效果。</p><h1 id="二、技术点"><a href="#二、技术点" class="headerlink" title="二、技术点"></a>二、技术点</h1><h3 id="技术点1：异形窗体"><a href="#技术点1：异形窗体" class="headerlink" title="技术点1：异形窗体"></a>技术点1：异形窗体</h3><p>使用透明控件扩充主窗口四周，以达到不规则图形超出客户区而不被裁剪的目的。同时，能保证窗口不受因缩放造成的抖动或闪烁。</p><h3 id="技术点2：鼠标穿透至桌面"><a href="#技术点2：鼠标穿透至桌面" class="headerlink" title="技术点2：鼠标穿透至桌面"></a>技术点2：鼠标穿透至桌面</h3><p>鼠标穿透可借助透明区域裁剪操作。其中，区域计算涉及布尔运算，图片掩码等图形学操作。</p><h3 id="技术点3：-窗体缩放"><a href="#技术点3：-窗体缩放" class="headerlink" title="技术点3： 窗体缩放"></a>技术点3： 窗体缩放</h3><ul><li>窗体样式： WS_OVERLAPPED | WS_MAXIMIZEBOX | WS_MINIMIZEBOX</li><li>鼠标输入通知： WM_NCHITTEST 是鼠标时间的入口。其返回值：HTCAPTION, HTTOP, HTTOPRIGHT…</li><li>窗体通知： WM_SIZING | WM_MOVING | WM_ENTERSIZEMVOE | WM_EXITSIZEMOVE | WM_GETMINMAXINFO | WM_NCLBUTTONDBLCLK | WM_NCCALCSIZE</li></ul><p>注：本部分仅列出实现功能所涉及的 window style, window notifications 和 window messages.</p><h1 id="三、-疑难点"><a href="#三、-疑难点" class="headerlink" title="三、 疑难点"></a>三、 疑难点</h1><h3 id="疑难点1：-桌面顶部停靠"><a href="#疑难点1：-桌面顶部停靠" class="headerlink" title="疑难点1： 桌面顶部停靠"></a>疑难点1： 桌面顶部停靠</h3><p>当窗口移动时，顶部透明区域需要被裁剪：WM_MOVING, WM_EXITSIZEMOVE</p><h3 id="疑难点2：-裁剪与缩放的冲突"><a href="#疑难点2：-裁剪与缩放的冲突" class="headerlink" title="疑难点2： 裁剪与缩放的冲突"></a>疑难点2： 裁剪与缩放的冲突</h3><p>当窗体缩放时，需要取消裁剪操作以避免窗体抖动：WM_SIZING | WM_NCCALCSIZE | WM_NCHITTEST </p><h3 id="疑难点3：-跨屏窗体异常"><a href="#疑难点3：-跨屏窗体异常" class="headerlink" title="疑难点3： 跨屏窗体异常"></a>疑难点3： 跨屏窗体异常</h3><p>当拖动窗体跨越具有不同 DPI 的屏幕时，需要刷新窗口：WM_ENTERSIZEMOVE | WM_EXITSIZEMOVE | QWindow::screenChanged</p><p>注：本部分仅列出解决问题需要的 window notifications 和 一些接口。</p><h1 id="四、剖析"><a href="#四、剖析" class="headerlink" title="四、剖析"></a>四、剖析</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本部分仅对 1 例疑难点处理作简要分析，其它同理。</p><h3 id="基本常识"><a href="#基本常识" class="headerlink" title="基本常识"></a>基本常识</h3><p>windows 桌面窗口控制着所有顶层窗口的行为。本部分不再重复介绍，有以下链接可参考</p><ul><li><a href="https://blog.csdn.net/tonglin12138/article/details/103967711">https://blog.csdn.net/tonglin12138/article/details/103967711</a></li><li><a href="https://www.cnblogs.com/staring-hxs/p/3202219.html">https://www.cnblogs.com/staring-hxs/p/3202219.html</a></li></ul><p>注：上述链接对于顶层窗口，子窗口等术语的定义会存在出入，一切以 Windows App Development 为准。</p><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>to be continued…</p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【杂项】Aria2 - 基础应用（持续更新）</title>
    <link href="/2024/09/16/Aria2-CommonSence-1/"/>
    <url>/2024/09/16/Aria2-CommonSence-1/</url>
    
    <content type="html"><![CDATA[<h1 id="1、Aria-基础设施"><a href="#1、Aria-基础设施" class="headerlink" title="1、Aria 基础设施"></a>1、Aria 基础设施</h1><h3 id="Aria2-下载器"><a href="#Aria2-下载器" class="headerlink" title="Aria2 下载器"></a>Aria2 下载器</h3><p>开源的 Aria2 下载器支持多种 IPC 通信模式： JSON-RPC, XML-RPC。</p><h3 id="IPC-机制"><a href="#IPC-机制" class="headerlink" title="IPC 机制"></a>IPC 机制</h3><p>基于 Aria2 提供的 RPC 机制， 我们选择了 xmlrpc 作为进程间通信方式。xmlrpc 开源库多种多样， 比如：libmaia, timxmlrpc。</p><ul><li>libmaia: <a href="https://github.com/wiedi/libmaia">https://github.com/wiedi/libmaia</a><br>一款为 Qt 定制的 XML-RPC 库。</li><li>timxmprpc: <a href="https://github.com/drtimcooper/XmlRpc4Win">https://github.com/drtimcooper/XmlRpc4Win</a><br>一款轻量的基于 C&#x2F;C++ 的 XML-RPC 库。</li></ul><h1 id="2、Aria-通信机制"><a href="#2、Aria-通信机制" class="headerlink" title="2、Aria 通信机制"></a>2、Aria 通信机制</h1><p>Aria2 下载器具有较灵活的配置：全局配置，单文件配置。<br>其中，全局配置会覆盖默认参数并影响所有下载资源；单文件配置仅对指定文件生效。</p><ul><li>–continue: 当下载中断时，支持继续下载（append and then check）</li><li>–auto-file-renaming&#x3D;false: 不支持重命名，即：相同文件会被覆盖</li><li>–allow-override&#x3D;true: 当缺少控制文件时，重新下载</li></ul><p>同时，Aria2 支持通过 command-line 进行初始化，也支持通过 rpc 进行下载过程中的交互。</p><ul><li>aria2.tellStatus: 信息或状态查询</li><li>aria2.addUri: 添加下载文件</li><li>aria2.pasueAll: 暂停操作，比如：下载，校验等</li><li>aria2.unpauseAll: 取消暂停操作</li><li>aria2.getVersion: 获取 aria 版本</li></ul><h1 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h1><ul><li>IPC通信：多文件下载时，略显鸡肋。需要主动查询并统计，还要控制好频率。同时，需要注意 aria2 的 初始化状态（借助 aria2.getVersion 探测）</li><li>下载进度：各种原因会造成进度回退，需要针对性处理（更新文件，继续上次下载等情况）</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows 系列 -- 设备IO</title>
    <link href="/2024/04/07/Windows-DeviceIO/"/>
    <url>/2024/04/07/Windows-DeviceIO/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本篇索引大致分为以下内容：设备、接口、同步设备I&#x2F;O、异步设备I&#x2F;O。 该篇非入门，可止步。</p><h1 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h1><p>本节以图示形式列出，供随时索引。更详细节可参考 Windows via C&#x2F;C++ (第五版)。<br><img src="/2024/04/07/Windows-DeviceIO/deviceio.png"></p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows 系列 -- 规划</title>
    <link href="/2024/04/07/Windows-OpenTopic/"/>
    <url>/2024/04/07/Windows-OpenTopic/</url>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>该系列将作为 Windows via C&#x2F;C++ (第五版)的索引，大致可分为以下几类：</p><ul><li>Windows 内核对象：重中之重。</li><li>Windows 开发通识: 一些常识，比如: 进程，线程，设备等。</li><li>Windows 技术设施: 一些便捷接口，比如：可提醒 IO 提供的 QueueForAPC 机制。</li></ul><h1 id="二、规划"><a href="#二、规划" class="headerlink" title="二、规划"></a>二、规划</h1><ul><li>设备IO</li><li>Windows 消息</li><li>…</li></ul><h1 id="三、体会"><a href="#三、体会" class="headerlink" title="三、体会"></a>三、体会</h1><p>Windows Job: 管理，监听当前 Process 及其 Child Process。无论是业务开发，还是日常 Debug (配合IOCP)，真好用。<br>Windows Message: 便捷的 IPC 通信小助手。借助冗余字段，可轻易搭建 Process 间的双向通信。<br>…</p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SDK 系列 -- Crashes</title>
    <link href="/2024/02/27/SDK-Crashes/"/>
    <url>/2024/02/27/SDK-Crashes/</url>
    
    <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>应用开发时，难免遇到崩溃问题：常识用于缩小检索范围；检索能力要靠经验积累喽。</p><h1 id="二、SDK-崩溃："><a href="#二、SDK-崩溃：" class="headerlink" title="二、SDK 崩溃："></a>二、SDK 崩溃：</h1><ul><li>spdlog: 开源日志库<br>当日志路径存在 utf16 字符时，构造函数传入的路径参数会造成崩溃。此时，需要单独构建支持 utf16 的库版本。</li><li>zmq: 开源IPC库<br>zmq 会在当前用户目录下的某个路径写入一些临时数据。如果当前用户的账户名存在 utf16 字符时，zmq 创建 socket 时，会导致进程强制退出（quit）。zmq 4.3.5 版本已修复。</li><li>cef: 开源webview库<br>如果 cef 运行目录和安装目录中存在 utf16 字符，页面渲染会出现黑屏现象。博主当时的解决方式是更新 cef 的版本（95 –&gt; 109）。</li><li>bit7z: 开源解压缩库<br>当有解压缩文件需求时，我们可选地有 7z.exe 或者 集成 bit7z。<br>对于使用bit7z的应用，有两个版本可选：V3, V4。V3 版本的 bit7z 不支持解压缩途中退出。V4 版本的 bit7z 借助业务回调接口的返回值（0 or 非0）达到了中途退出的目的。然而，V4.0.0 版本的异常捕获机制存在崩溃Bug(空间不足时崩溃)。<br>截至 2024年2月27日，bit7z 已更新至 V4.0.5 版本。不确定后来的版本是否修复上述问题哦。</li></ul>]]></content>
    
    
    <categories>
      
      <category>SDK</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SDK 系列 -- CEF -- 构建流程(Current Branches &amp; Legacy Branches)</title>
    <link href="/2024/02/26/CEF-Build/"/>
    <url>/2024/02/26/CEF-Build/</url>
    
    <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>由于版权限制，CEF官方提供的库文件并不支持视频解码功能。<br>截至 2024年2月26日，CEF 的最新 Release 大版本号是 122。对于 CEF 的所有版本号，博主通常有两种划分方式：</p><h6 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h6><ul><li>Supported Branches: 官方维护的构建工具支持构建的分支。</li><li>Unsupported Branches: 官方维护的构建工具不支持构建的分支。注意：<a href="https://bitbucket.org/chromiumembedded/cef/wiki/BranchesAndBuilding">官方文档</a>中的部分 Legacy Release Branches 也可直接完成构建哦。博主曾傻瓜式构建的最近大版本号是 117。</li></ul><h6 id="方式二：system-requirement"><a href="#方式二：system-requirement" class="headerlink" title="方式二：system requirement"></a>方式二：system requirement</h6><ul><li>Win10 and up: 大版本号为 110 或更高的版本，仅支持 Win10, Win11系统。</li><li>Win7 and up： 支持 Win7, Win8, Win10, Win11 的最新版本号为 109, 对应分支是 5414。</li></ul><h1 id="二、构建库"><a href="#二、构建库" class="headerlink" title="二、构建库"></a>二、构建库</h1><p>两种构建方式，大致命名为：Current Release Build, Legacy Release Build。</p><h4 id="Current-Release-Build"><a href="#Current-Release-Build" class="headerlink" title="Current Release Build"></a>Current Release Build</h4><p>构建流程可参考上述官方文档。部分配置参数:</p><ul><li>is_official_build&#x3D;true</li><li>proprietary_codecs&#x3D;true</li><li>ffmpeg_branding&#x3D;Chrome</li><li>chrome_pgo_phase&#x3D;0</li></ul><h4 id="Legacy-Release-Build"><a href="#Legacy-Release-Build" class="headerlink" title="Legacy Release Build"></a>Legacy Release Build</h4><p>构建流程及构建参数同上。在较低版本的构建中，会遇到两次错误：</p><ul><li><p>Error 1：git_dependencies配置不兼容，需要修改<a href="https://source.chromium.org/chromium/_/chromium/chromium/tools/depot_tools.git/+/b6eaed26fce285228743f626ccd8de1b5a26a6dd">打包脚本</a>（gclient.py, gclient_eval.py）</p></li><li><p>Error 2: python 解析相对路径失败, 需要修改<a href="https://github.com/chromiumembedded/cef/issues/3506">模块脚本</a>（mojom_js_generator.py 或者 mojom_ts_generator.py）<br>需要全局搜索文件，匹配字符串：”path &#x3D;&#x3D; ‘&#x2F;‘“。</p></li></ul><h1 id="三、系统配置"><a href="#三、系统配置" class="headerlink" title="三、系统配置"></a>三、系统配置</h1><ul><li>CPU：CPU 逻辑核心数强有关，即可并发执行的数量。(建议 i7 12700k)</li><li>磁盘：读写速度强相关，链接阶段持续较久。(建议固态1T)</li></ul>]]></content>
    
    
    <categories>
      
      <category>SDK</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>下载器 -- IPC 调研(备忘) -- 2024.09.15 旧稿发布</title>
    <link href="/2023/09/16/SDK-Downlaoder-part2/"/>
    <url>/2023/09/16/SDK-Downlaoder-part2/</url>
    
    <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>借助于开源的 Aria2c 下载器，实现一款资源下载工具。</p><h1 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h1><p>开源的 Aria2c 下载器使用定制的 MaiaIPC 进行通信：http post。会存在一些问题：</p><ul><li>Http 链接：N 组资源下载，需要在业务层维持 N 个 Http链接</li><li>状态查询：定时主动轮询，会存在 60% 以上的无效查询。</li><li>异常同步：强依赖状态查询。若不查询，则无法获取异常信息。</li></ul><p><img src="/2023/09/16/SDK-Downlaoder-part2/maia_ipc.png"></p><h1 id="三、预期"><a href="#三、预期" class="headerlink" title="三、预期"></a>三、预期</h1><p>新版 IPC 要能做到按需同步信息，主要是状态信息。按照现有的资源下载机制，新版 IPC 流程大致如下：</p><p><img src="/2023/09/16/SDK-Downlaoder-part2/ipc_wrapper.png"></p><p>一些针对性改进：</p><ul><li>在业务层面，client只需要提前简历两个链接；downloader 也只需跟对应的两个链接通信</li><li>client 可以主动给 downlaoder 下发命令（暂停，继续等）; downloader 也可以主动上报（状态，异常等）</li></ul><h1 id="四、调研"><a href="#四、调研" class="headerlink" title="四、调研"></a>四、调研</h1><p>1、gRPC<br>库过于庞大，存在过多无用功能。暂不考虑应用在 IPC 通信。</p><p>2、Microsoft IPC<br>C++ 模板库。但提供的功能单一，仅支持了同步的 REQ&#x2F;REP 机制。后续持续跟进，并验证可用性。</p><p>3、ZeroMQ<br>轻量的嵌入式IPC库。具有相对灵活的可定制性。非 Win10 或者 Win10（17063 以下）系统，只能使用 socket。不过，unix domain socket 挺香。<br>(注：RabbitMQ, RocketMQ, Kafka 各有其用，不在本文考虑范围内)</p><h1 id="五、实现"><a href="#五、实现" class="headerlink" title="五、实现"></a>五、实现</h1><p>使用 ZeroMQ 实现 IPC 通信功能。PUB&#x2F;SUB 通信模式如下：</p><p><img src="/2023/09/16/SDK-Downlaoder-part2/fanin_fanout.png"></p><h1 id="六、建议"><a href="#六、建议" class="headerlink" title="六、建议"></a>六、建议</h1><ul><li>win 10 (17063) 以下系统，只能使用 socket 进行 IPC 通信。</li><li>在 windows 环境下，zmq 使用 wepoll 开源库支持 epoll。经线上实践，wepoll 存在问题。因此， windows 环境下的 polling 机制建议选择 select。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>下载器 -- 调试工具(备忘)</title>
    <link href="/2023/09/15/SDK-Downloader-part1/"/>
    <url>/2023/09/15/SDK-Downloader-part1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>如何便捷地调试 Golang 导出库。</p><ul><li>lib 生成工具：以应对 SDK 接入前期频繁更换库文件的情况</li><li>C++ 测试环境：以用于 SDK 接入前期的频繁验证工作</li></ul><h1 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h1><p>本节内容将以列表形式提供: lib 工具生成、VSCode 测试环境</p><h2 id="1、lib-生成（手动）"><a href="#1、lib-生成（手动）" class="headerlink" title="1、lib 生成（手动）"></a>1、lib 生成（手动）</h2><p>动态库的使用方式分为：动态调用，静态调用。SDK 导出库只给到了 *.h 和 *.dll 文件。要想以静态调用的方式使用，我们需要通过 *.dll 生成对应的 *.lib 符号文件。大致步骤如下：</p><ul><li><strong>导出 dump.txt</strong><br>使用 Developer Command Prompt for VS 20XX 工具，通过命令行 <code>dumpbin /EXPORTS *.dll &gt; dump.txt</code> 导出：<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tap">Dump of file 7z.dll<br><br>File Type: DLL<br><br>  Section contains the following exports for 7z.dll<br><br>   <span class="hljs-number"> 00000000 </span>characteristics<br>    62D16FC1 time date stamp Fri Jul<span class="hljs-number"> 15 </span>21:46:41 2022<br>        0.00 version<br>          <span class="hljs-number"> 1 </span>ordinal base<br>         <span class="hljs-number"> 13 </span>number of functions<br>         <span class="hljs-number"> 13 </span>number of names<br><br>    ordinal hint RVA      name<br>         <span class="hljs-number"> 1 </span>  <span class="hljs-number"> 0 </span>0010D6E0 CreateDecoder<br>          .<br>  Summary<br>       <span class="hljs-number"> 9000 </span>.data<span class="hljs-number"> 13000 </span>.pdata<span class="hljs-number"> 55000 </span>.rdata<span class="hljs-number"> 4000 </span>.reloc<span class="hljs-number"> 19000 </span>.rsrc<span class="hljs-number"> 137000 </span>.text<br></code></pre></td></tr></table></figure>导出信息相当丰富，但我们只需要 Section 段落中的导出函数名, 比如：CreateDecoder 等…</li><li><strong>生成 .def</strong><br>DEF 文件格式详见<a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/moduledefinition-dot-def-files?view=msvc-170">官方介绍</a>。本着最简原则，我们只需要用到：LIBRARY、EXPORTS。为了简化操作步骤，我们需要一个辅助工具: 根据 dump 信息生成 .def 文件 <strong>(导出接口变化时，才需要重新导出 DEF)</strong> 。辅助工具逻辑大致如下：<ul><li>读取 dump 文件: <code>dump.txt</code></li><li>定位 Section 段落：<ul><li>begin with： <code>original hint RVA</code> </li><li>end with: <code>Summary</code></li></ul></li><li>搜索符号并写入 .DEF 文件</li></ul></li><li><strong>生成 .lib</strong> ：<br>使用 Developer Command Prompt for VS 工具，通过命令行: <code>lib /def:example.def /machine:x64 /out:example.lib</code></li></ul><h2 id="2、lib-生成工具"><a href="#2、lib-生成工具" class="headerlink" title="2、lib 生成工具"></a>2、lib 生成工具</h2><p>现成的开源工具 <a href="https://digitalmars.com/ctg/implib.html">IMPLIB</a>，可以根据 DLL 文件或者 DEF 文件生成对应的导出文件 LIB。使用教程可参考官方文件，大致命令如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">implib [switches] libfile [ dllfile | deffile ]<br></code></pre></td></tr></table></figure><h2 id="3、测试环境搭建：VSCode-with-C"><a href="#3、测试环境搭建：VSCode-with-C" class="headerlink" title="3、测试环境搭建：VSCode with C++"></a>3、测试环境搭建：VSCode with C++</h2><p>当 DLL 接口更新时，涉及到的工作流大致如下：</p><ul><li>测试环境：快速生成 EXE、快速步进 DEBUG。</li><li>测试链路： 生成 .lib –&gt; 生成 EXE –&gt; DEBUG。</li></ul><p>VSCode 谁用谁知道，开发利器。因此，博主就将 VSCode 作为我们的测试环境。 关于 VSCode C++ 环境的搭建，网上教程一大把。因此，博主只对一些必要的配置做介绍。</p><ul><li><strong>mingw64</strong>: 提供 Windows 下软件构建所需的工具，如：gcc, g++ 等</li><li><strong>launch.json</strong>: vscode 启动程序的配置文件<ul><li>program: EXE 的全路径</li><li>miDebuggerPath: GDB 的全路径</li><li>preLaunchTask: EXE 运行的前置工作，如：编译工作。</li></ul></li><li><strong>task.json</strong>: 协助 launch.json 的前置工作<ul><li>label: 任务提示词，执行构建时供用户选用的提示</li><li>command: 执行命令</li><li>args: 构建参数，比如：源文件、包含路径、依赖路径等</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CEF3 系列 -- 实践汇总（持续更新）</title>
    <link href="/2023/09/02/CEF-Pratice-Summary/"/>
    <url>/2023/09/02/CEF-Pratice-Summary/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里给出一些 QCefView 存在的一些瑕疵。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>汇总主要关注应用开发中的技术问题、技术 <strong>‘难点’</strong> 。因此，后续部分将以列表形式给出。</p><h2 id="1、Input-Method-Editor-IME"><a href="#1、Input-Method-Editor-IME" class="headerlink" title="1、Input Method Editor (IME)"></a>1、Input Method Editor (IME)</h2><p>详见 <a href="/2023/03/08/QCef-Ime-JSInject/" title="[杂项] CEF3 -- IME Behavior">[杂项] CEF3 -- IME Behavior</a>。</p><h2 id="2、QCefView-输入法组合键：小语种（葡萄牙语）"><a href="#2、QCefView-输入法组合键：小语种（葡萄牙语）" class="headerlink" title="2、QCefView 输入法组合键：小语种（葡萄牙语）"></a>2、QCefView 输入法组合键：小语种（葡萄牙语）</h2><p>KeyBoardUtils 作为插件的辅助工具，主要用于 Qt 事件 –&gt; CEF3 事件的参数转换。其中的 <code>winGetKeyBoardModifiers</code> 接口，负责解析虚拟组合按键。</p><ul><li>问题代码段<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span></span><br><span class="hljs-function"><span class="hljs-title">winGetKeyboardModifiers</span><span class="hljs-params">(QKeyEvent* qe)</span></span>&#123;<br>    ...<br>    <span class="hljs-keyword">if</span>(!qe-&gt;<span class="hljs-built_in">text</span>().<span class="hljs-built_in">isEmpty</span>() &amp;&amp; (::<span class="hljs-built_in">GetKeyState</span>(VK_RMENU) &amp; <span class="hljs-number">0x8000</span>))&#123;<br>        HKL current_layout = ::<span class="hljs-built_in">GetKeyBoardLayout</span>(<span class="hljs-number">0</span>);<br>        SHORT scan_res = ::<span class="hljs-built_in">VkKeyScanExW</span>(vk, current_layout);<br>        <span class="hljs-keyword">if</span>(((scan_res &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>) == (<span class="hljs-number">2</span> | <span class="hljs-number">4</span>))&#123;<br>            cm &amp;= ~(EVENTFLAG_CONTROL_DOWN | EVENTFLAG_ALT_DOWN);<br>            cm |= EVENTFLAG_ALTGR_DOWN<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cm;<br>&#125;<br></code></pre></td></tr></table></figure>首先，从代码风格可见 <strong>QCefView</strong> 作者具备深厚的 Window 开发功底。问题代码意图：<ul><li>判断小语种键盘：<code>::GetKeyState(VK_RMENU) &amp; 0x8000</code></li><li>获取键盘布局：<code>::GetKeyBoardLayout(0)</code></li><li>通过 VirtualKey 和 物理键盘布局获取扫描码：<code>VkKeyScanExW(vk, current_layout)</code></li><li>匹配 Control + ALT 组合键：位运算见上述代码。</li></ul></li><li>修复代码段<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span></span><br><span class="hljs-function"><span class="hljs-title">winGetKeyboardModifiers</span><span class="hljs-params">(QKeyEvent* qe)</span></span>&#123;<br>    ...<br>    <span class="hljs-keyword">if</span>(!qe-&gt;<span class="hljs-built_in">text</span>().<span class="hljs-built_in">isEmpty</span>())&#123;<br>        <span class="hljs-keyword">if</span>((m &amp; Qt::ControlModifier) &amp;&amp; (m &amp; Qt::ALtModifier))&#123;<br>            cm &amp;= ~(EVENTFLAG_CONTROL_DOWN | EVENTFLAG_ALT_DOWN);<br>            cm |= EVENTFLAG_ALTGR_DOWN<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cm;<br>&#125;<br></code></pre></td></tr></table></figure>OSR 渲染模式下，我们无法获取正确的窗口句柄及其 Window 消息。所以，上述操作有点多此一举：只需要匹配 CONTROL + ALT 即可。</li></ul><h2 id="3、QCefView-Hover-Event-HoverIn-amp-HoverOut"><a href="#3、QCefView-Hover-Event-HoverIn-amp-HoverOut" class="headerlink" title="3、QCefView Hover Event: HoverIn &amp; HoverOut"></a>3、QCefView Hover Event: HoverIn &amp; HoverOut</h2><p><strong>CEF3 三种鼠标事件</strong> ：cef_browser_capi</p><ul><li>send_mouse_click_event: 处理鼠标点击</li><li>send_mouse_move_event：处理鼠标移动</li><li>send_mouse_wheel_event：处理鼠标滚轮</li></ul><p><strong>Qt 鼠标事件</strong> ：</p><ul><li>mouseMoveEvent: 鼠标移动</li><li>mousePressEvent：鼠标按下</li><li>mouseReleaseEvent：鼠标释放</li><li>wheelEvent：鼠标滚轮</li><li><strong>enterEvent</strong> &amp; <strong>leaveEvent</strong>: 鼠标移入 &amp; 移出</li></ul><p><strong>问题描述</strong> ：<br>QCefView 插件完美适配了 Qt 的前四种事件，即：mouseMove、mousePress、mouseRelease、wheelEvent。通过字面义，可以很清晰地将 CEF3 和 QCefView 事件映射。 然而，<code>enterEvent</code> 和 <code>leaveEvent</code> 并没有找到合适的选择。当窗口边缘属于可滚动区域时，边缘的滚动条的交互效果会出现 Bug: 缺少 HoverIn、HoverOut 效果。<br><strong>问题解决</strong> ：<br>通过测试，CEF3 的 send_mouse_move_event 接口兼具 moveMouse、mouseEnter 和 mouseLeave 的功能。因此，只需要按照 QCefView 接口规范，补充并转发 Qt 对应的 <strong>enterEvent</strong> 和 <strong>leaveEvent</strong> 即可。</p>]]></content>
    
    
    <categories>
      
      <category>Cef</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并发系列 -- 汇总（持续更新）</title>
    <link href="/2023/08/06/MultiThread-Pratice-4/"/>
    <url>/2023/08/06/MultiThread-Pratice-4/</url>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>本文摘自 C++ Concurrency IN  ACTION，一本基于 C++11 标准的并发和多线程编程深度指南。内容包括 std::thread、std::mutex、和 std::async 等基础类的使用，内存模型和原子操作、基于锁和无锁数据结构的构建，以及并行算法和线程管理。同时，会在部分章节附加 Qt 提供的便利工具。</p><ul><li>基础类<br><img src="/2023/08/06/MultiThread-Pratice-4/related_interfaces.png"><br>图中涉及 C++ 标准库 和 Qt 提供的一些工具类。它们足以满足 99.9% 的应用开发需求。你见过多少呢？又对它们的应用场景了解多少？（哎，难以想象共事的多位 10 多年工龄的互联网员工竟然对线程毫无感觉。博主心好累~）</li><li><del>内存模型</del></li><li><del>数据结构</del></li><li><del>并行算法</del></li><li><del>线程管理</del></li></ul><h1 id="二、并发编程实践"><a href="#二、并发编程实践" class="headerlink" title="二、并发编程实践"></a>二、并发编程实践</h1><p>该章节会结合博主 3 年多来在前端、后端、客户端方向的粗浅经验，对 C++ 并发编程作简要汇总。</p><h2 id="1、管理线程"><a href="#1、管理线程" class="headerlink" title="1、管理线程"></a>1、管理线程</h2><p>C++ 标准库让大多数线程管理变得相对简单，通过与给定线程关联的 std::thread 对象就可以管理所有事情。对于不直观的任务，标准库也提供了从基本构造快进行按需构建的可扩展性。</p><h3 id="基本线程管理"><a href="#基本线程管理" class="headerlink" title="基本线程管理"></a>基本线程管理</h3><h2 id="2、在线程间管理数据"><a href="#2、在线程间管理数据" class="headerlink" title="2、在线程间管理数据"></a><del>2、在线程间管理数据</del></h2><h2 id="3、同步并发操作"><a href="#3、同步并发操作" class="headerlink" title="3、同步并发操作"></a><del>3、同步并发操作</del></h2><h2 id="4、C-内存模型和原子类型操作"><a href="#4、C-内存模型和原子类型操作" class="headerlink" title="4、C++ 内存模型和原子类型操作"></a><del>4、C++ 内存模型和原子类型操作</del></h2><h2 id="5、数据结构：基于锁的并发数据结构，无锁的并发数据结构"><a href="#5、数据结构：基于锁的并发数据结构，无锁的并发数据结构" class="headerlink" title="5、数据结构：基于锁的并发数据结构，无锁的并发数据结构"></a><del>5、数据结构：基于锁的并发数据结构，无锁的并发数据结构</del></h2><h2 id="6、高级线程管理"><a href="#6、高级线程管理" class="headerlink" title="6、高级线程管理"></a><del>6、高级线程管理</del></h2>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>[杂项] QSS</title>
    <link href="/2023/04/25/QWidget-QSS-Overview/"/>
    <url>/2023/04/25/QWidget-QSS-Overview/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>QSS 实战经验总结。</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>QSS 就是 QWidget 会用到的样式表。只有 QWidget 会用到 QSS 。QML 是脚本语言啦，它依赖 Quick 提供的可视化组件。而 Item 系列的可视化组件是 JSEngine 负责渲染的。所以，QWidget 和 QuickItem 是属于两个完全不想干的领域（QObject 是唯一共性）。<br>以博主对 QSS 的认识，其大致可分为：</p><ul><li>CSS 部分: 仅限 2.0 版本。QSS 处于维护状态，应该永远支持不了 CSS3 了；</li><li>Subcontrol 部分：QWidget 独有，也是本文介绍的重点;</li><li>QProperty 部分：扩展样式表功能, 以达到出其不意的效果；</li></ul><h1 id="技术分析"><a href="#技术分析" class="headerlink" title="技术分析"></a>技术分析</h1><p>本节对以上文中的 CSS，Subcontrol 以及 QProperty 部分进行简要介绍。</p><h2 id="CSS-部分"><a href="#CSS-部分" class="headerlink" title="CSS 部分"></a>CSS 部分</h2><p>CSS 部分就不展开讨论了，也就那么点知识。博主在 <strong>DJI</strong> 就职时，负责开发的 Electron 桌面客户端涉及到大量的 CSS 技术。  </p><h2 id="Subcontrol-部分"><a href="#Subcontrol-部分" class="headerlink" title="Subcontrol 部分"></a>Subcontrol 部分</h2><p>玩转 QWidget 的重要组成部分。Subcontrol 依赖于 CSS 的 <strong>盒模型</strong> ，以控制子控件绘制的位置：Subcontrol-Origin, Subcontrol-position, 以及起到微调作用 Top 和 Left 属性。</p><ul><li>Subcontrol-Origin<br>subcontrol-origin 定义 children widget 在 parent widget 中绘制的包围盒，默认在 padding 的矩形中绘制。如下：<ul><li>subcontrol-origin: margin</li><li>subcontrol-origin: border</li><li>subcontrol-origin: padding</li><li>subcontrol-origin: content</li></ul></li><li>Subcontrol-Position<br>由 subcontrol-origin 定义了在 parent widget 上的绘制区域后，如：padding 包围区。那这么大的范围，具体绘制在哪里呢？ subcontrol-position 进一步限制绘制方向。<ul><li>subcontrol-origin: left</li><li>subcontrol-origin: right</li><li>subcontrol-origin: center</li><li>subcontrol-origin: top</li><li>subcontrol-origin: bottom</li></ul></li><li>Top &amp; Left<br>top 和 left 属性用于微调 subcontrol位置, 比如： 在 ::hover 和 ::pressed 状态时，通过微调达到视觉上的动画效果。</li></ul><h2 id="QProperty-部分"><a href="#QProperty-部分" class="headerlink" title="QProperty 部分"></a>QProperty 部分</h2><p>一个属性的行为就像一个类的数据成员，它有通过元对象系统访问的附加功能。本文仅介绍 QProperty 在 QSS 方面发挥的作用，也即各种 pseudo-classes，如：enabled, hover, pressed, checked。</p><p>但是呢，博主不打算介绍 Qt 在各个 QWidget 派生类中内置的各种状态属性。 本节仅举一例，来凸显 QProperty 在样式表功能扩展方面的能力。</p><p>对于 QCheckBox 控件，checked 状态 与 enabled 状态 存在交叉的场景，即：enable 和 disable 状态下，checked 样式需要具有不同的 UI 显示。这个时候，单凭 CSS 提供的能力是比较难办到的。借助于 Property 属性，我们可以通过几行简单的 QSS 语句就能对齐进行区分：</p><ul><li>QSS 配置<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">QCheckBox::disabled[check=true]&#123;image: <span class="hljs-string">&quot;qrc://cat.png&quot;</span>&#125;<br>QCheckBox::disabled[check=false]&#123;image: <span class="hljs-string">&quot;qrc://dog.png&quot;</span>&#125;<br></code></pre></td></tr></table></figure></li><li>Logic 控制<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">control-&gt;<span class="hljs-built_in">setProperty</span>(<span class="hljs-string">&quot;check&quot;</span>, <span class="hljs-literal">true</span>);<br>control-&gt;<span class="hljs-built_in">style</span>()-&gt;<span class="hljs-built_in">polish</span>();<br></code></pre></td></tr></table></figure></li></ul><h1 id="附记"><a href="#附记" class="headerlink" title="附记"></a>附记</h1><p>在上文中，我们看到 <code>style()-&gt;polish()</code>语句。本小节就附上一些心得：</p><ul><li>polish: 在程序运行时，QWidget 的样式发生变化需要配合 <code>polish</code> 才能生效；</li><li>updateGeometry: 当 QWidget 的 Size，Geometry 相关策略发生变化时，需要配合 <code>updateGeometry</code> 才能生效。比如：sizeHint 变化，maximumHeight 变化等；</li><li>update：当 UI 以任何形式变化时，有些情况会存在无法实时刷新，此时就需要配合 <code>update</code> 才能生效。比如：当 hover 状态下，通过修改 style-sheet 方式更改 QPushButton 的背景图片时。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>初探 QML 系列 -- 工程实践汇总（持续更新）</title>
    <link href="/2023/04/05/QML-Quick-framework/"/>
    <url>/2023/04/05/QML-Quick-framework/</url>
    
    <content type="html"><![CDATA[<h1 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a>一、预备知识</h1><p>Windows 支持两种类型的应用程序： GUI 程序和 CUI 程序。本文介绍的对象当然是 GUI 程序。Windows 应用程序必须有一个入口点函数，应用程序运行时，这个函数将被调用。C&#x2F;C++ 开发人员可以使用以下两种入口点函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Int WINAPI _tWinMain(<br>    HINSTANCE hInstanceExe,<br>    HINSTANCE,<br>    PTSTR pszCmdLine,<br>    <span class="hljs-type">int</span> nCmdShow);<br><br><span class="hljs-type">int</span> _tmain(<br>    <span class="hljs-type">int</span> argc,<br>    TCHAR *argv[],<br>    TCHAR *envp[]);<br></code></pre></td></tr></table></figure><p>实际上，操作系统并不调用我们所写入口点函数。相反，它会调用由 C&#x2F;C++ 运行库实现并在链接时使用 <strong>-entry:</strong> 命令行选项设置的一个 C&#x2F;C++ 运行时启动函数。<strong>这些</strong> 启动函数的用途简单总结如下：</p><ul><li>获取指向新进程的完整命令行的一个指针</li><li>获取指向新进程的环境变量的一个指针</li><li>初始化 C&#x2F;C++ 运行库的全局变量</li><li>初始化 C 运行库内存分配函数（ <strong>malloc</strong> 和 <strong>calloc</strong> ）以及其他底层 I&#x2F;O 例程使用的堆（heap）</li><li>调用所有全局和静态 C++ 类对象的构造函数</li></ul><p>完成所有这些初始化工作之后，C&#x2F;C++ 启动函数就会调用应用程序的入口点函数（后文简称 <code>main</code>）。一个精心设计的应用程序框架，会在 <code>main</code> 入口点做一些有条理的工作：</p><ul><li>解析命令行参数：判断运行目录，判断唤起方式，及其他业务</li><li>初始化环境：以共享内存的维护的单实例判断、日志系统初始化、多语言初始化、样式表初始化</li><li>初始化 UI：主窗口的初始化, 如：QMainWindow（qwidget）, Window（qml）</li><li>开启事件循环：阻塞型 exec 的执行，但不阻塞 <strong>交互</strong> 和 <strong>UI</strong> 。exec 可被其他事件循环暂时挂起，比如：模态对话框，<code>QEventLoop</code> 同步业务逻辑</li></ul><p>由于涉及知识点较广泛，本文仅从某一侧面梳理 quick 工程应有的模样。</p><h1 id="二、Qucik-工程调研"><a href="#二、Qucik-工程调研" class="headerlink" title="二、Qucik 工程调研"></a>二、Qucik 工程调研</h1><p><img src="/2023/04/05/QML-Quick-framework/qtquick_bp.png"></p><h1 id="三、Coding-规范及要求"><a href="#三、Coding-规范及要求" class="headerlink" title="三、Coding 规范及要求"></a>三、Coding 规范及要求</h1><p>对于采用 MVVM 框架的 QWidget 工程，嵌入 Quick UI 需要尽量保持：模块独立、链路清晰。</p><h2 id="1、协议命名规范"><a href="#1、协议命名规范" class="headerlink" title="1、协议命名规范"></a>1、协议命名规范</h2><ul><li>QML:<ul><li>事件请求：以 request 开头（requestXXX）</li><li>事件响应：以 Ack 结尾（XXXAck）</li></ul></li><li>Model:<ul><li>事件处理：不作限制，保持以往习惯</li><li>双向转发：<ul><li>QML to C++: 以 sig 开头， Req 结尾（sigXXXReq）</li><li>C++ to QML: 以 sig 开头， Ack 结尾（sigXXXAck）</li></ul></li></ul></li><li>Thread:<ul><li>Slots: 以 on 开头，Req 结尾（onXXXReq）</li></ul></li></ul><h2 id="2、QML-与-C-通信"><a href="#2、QML-与-C-通信" class="headerlink" title="2、QML 与 C++ 通信"></a>2、QML 与 C++ 通信</h2><p><img src="/2023/04/05/QML-Quick-framework/qml_cpp_comm.png"></p><h2 id="3、QML-与-C-线程划分"><a href="#3、QML-与-C-线程划分" class="headerlink" title="3、QML 与 C++ 线程划分"></a>3、QML 与 C++ 线程划分</h2><ul><li>模块接口描述<ul><li>QML CallBridge: QML 与 C++ 通信的媒介，属于 QWidget UI 线程<ul><li>requestXXX：用于 QML 内部发起请求，接口实际上只是触发一个事件（emit sigXXXReq）</li><li>XXXAck: 用于 QML 内部接收对应的事件，接口实际上用于响应 requestXXX， 可通过参数携带数据</li></ul></li><li>XXX Model: 常规 MVVM 框架中的 Model 层，属于 QWidget UI 线程<ul><li>XXX: 业务接口，用于 Http 请求服务端数据和状态</li><li>sigXXXReq: 用于中转事件请求，UI 线程 —-&gt; 非 UI 线程</li><li>sigXXXAck: 用于中转事件响应，非 UI 线程 —-&gt; UI 线程</li></ul></li><li>XXX Manager: 本质上属于 MVVM 框架中的 Model, 属于非 UI 线程。其主要用于数据相关业务的处理<ul><li>onXXXReq: 用于调用业务接口 XXX, 保证该接口、数据处理、回调等均在非 UI 线程处理</li></ul></li></ul></li><li>交互流程<br><img src="/2023/04/05/QML-Quick-framework/qml_cpp_thread.png"></li></ul>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>初探 QML 系列 -- 规划</title>
    <link href="/2023/03/22/QML-Series-OpenTopic/"/>
    <url>/2023/03/22/QML-Series-OpenTopic/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于桌面软件开发，常用的 UI 库包括：MFC、 QT、 wxWidget、FLTK 等。如果项目立项初期选择 Qt 的话，有两个大的方向可供选择：QWidget, QML。 在性能方面，两者基本上没有太大差距。 但对于 C++ 开发人员，两种选择都有不小的挑战。对于桌面 App 涉及到的技术点，博主将其分为两类：<strong>布局系统</strong> 和 <strong>其它</strong> 。 </p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>对比 QWidget 和 QML 的布局方式，以对 QT 开发中不可避免的 UI 开发具有基本认识。</p><ul><li>QWidget: 相对布局和绝对布局 <ul><li>相对布局：Layout相关，Alignment相关，Stretch相关，WindowType相关</li><li>绝对布局：一个良好设计的 Qt 桌面应用程序，会有 15% 左右的 UI 及交互会通过绝对定位的方式实现</li></ul></li><li>QML: 更高层次的抽象。结合相关技术，QML 将庞大的布局系统大致分为：<ul><li>绝对定位：同 QWidget 中的绝对布局。</li><li>坐标绑定：相对于绝对定位，增加了动态绑定的功能（性能成本）</li><li>锚定位：在各种渲染引擎的 UI 开发中，这种方式被称为 <strong>锚点</strong> 或 <strong>锚框</strong> 。博主有两年的 Unity 引擎开发经验~</li><li>定位器：通常用于排列，有：Column，Flow，Grid，Row 等</li><li>布局管理器：相对于定位器，它可以进行更细致的控制。包括：ColumnLayout，GridLayout，RowLayout，StackLayout 等</li></ul></li></ul><h1 id="系列规划"><a href="#系列规划" class="headerlink" title="系列规划"></a>系列规划</h1><p>事实上，博主利用周末和空闲时间已经做了些准备工作，且初具成效。后续会针对现有项目开发过程中遇到的未解问题，使用 QML 逐个攻破。近期安排如下：</p><h4 id="像素级还原-重构-系列"><a href="#像素级还原-重构-系列" class="headerlink" title="像素级还原(重构)系列"></a>像素级还原(重构)系列</h4><p>当你看到这篇文章时，该系列进度已经完成了 60%。至于详细的技术讲解，会有相应的文章陆续放出~</p><ul><li>重构 <code>QWidget</code> 组件： <code>ImageSlider</code><br><code>ImageSlider</code> 组件经过先后两次的重构后，仍没有解决已知问题。记得，最近一次重构耗时 2w，但实现不尽如人意。</li><li>重构 <code>QWidget</code> 组件： <code>TitleDock</code><br><code>TitleDock</code> 组件的布局 <strong>生硬</strong> ，导致功能扩展受限。随着需求的增长，它的问题越来越严重。</li><li>重构 <code>QWidget</code> 组件： <code>Size-Adaptable Area</code><br>博主实现的 <code>Adaptable Area</code> 组件本身没有什么问题。在项目中，这种组件应用十分广泛.</li><li>…</li></ul><h4 id="专项攻破系列"><a href="#专项攻破系列" class="headerlink" title="专项攻破系列"></a>专项攻破系列</h4><ul><li>QML 数据处理：Model, Delegate</li><li>Quick 框架设计：MVVM 设计模式</li><li>…</li></ul>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>[杂项] AR -- 前后景处理</title>
    <link href="/2023/03/22/AR-FrontAndRearScene-Overview/"/>
    <url>/2023/03/22/AR-FrontAndRearScene-Overview/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文着重梳理两年来博主在 AR 直播领域（渲染、推流、数据处理）的技术积累. 为避免遗忘这些宝贵的经验和方法, 才有了这篇纯技术文章.</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="GPU-流水线"><a href="#GPU-流水线" class="headerlink" title="GPU 流水线"></a>GPU 流水线</h2><ul><li>顶点数据: 模型通常由三角面 (或四边面) 组成. 在 GPU 渲染流程中，三角面片的顶点数据则是顶点着色器的输入，包括：位置, 法线, 切线, N 个纹理坐标以及颜色<ul><li>坐标系: 空间位置都是相对的.<br>  日常技术沟通时，我们常说：A 坐标系在 B 坐标系下的表示; 点在某个坐标系下的表示;<ul><li>A 类： 左手系, 右手系</li><li>B 类：模型坐标系, 相机坐标系, 世界坐标系</li></ul></li></ul></li><li>集合阶段: <ul><li><strong>顶点着色器</strong>: 顶点&#x2F;片元着色器的第一个函数<ul><li>必要动作：完成顶点坐标从模型空间转换到齐次裁剪空间(<code>mul(UNITY_MVP, v.position)</code>)</li><li>应用: 顶点动画, 低质量光照计算</li></ul></li><li>曲面细分着色器: 可忽略哈, 99.9% 的技美不会接触到这里</li><li>集合着色器: 同上可忽略, 如果感兴趣 google 一下</li><li><strong>裁剪</strong>: 至关重要, 跟投影矩阵直接相关(正交投影, 透视投影)</li><li><strong>屏幕映射</strong>: 至关重要, 3D –&gt; 2D</li></ul></li><li>光栅化阶段<ul><li>三角形设置: 固定函数阶段</li><li>三角形遍历: 固定函数阶段</li><li>片元着色器: 进行逐片元的着色操作. 顶点&#x2F;片元着色器的第二个函数</li><li>逐片元操作: 主要完成颜色, 深度缓冲, 混合等操作. 非可编程阶段, 开发人员 <strong>不可直接介入</strong></li></ul></li><li>屏幕图像</li></ul><h2 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h2><ul><li>Shading Language: 列出几种常见的高级语言—可视为 <strong>中间语言</strong> (Intermediate Language, IL). 这里的高级是相对于汇编语言来讲的, 并不是像 C# 相对于 C 的高级那种.<ul><li>HLSL: DirectX 专用</li><li>GLSL: OpenGL 专用</li><li>CG: NVIDA 专用, 也即 <code>C for Graphic</code>. 在单个 <code>Pass</code> 通道, C 风格的代码通常被包围在 <code>CGPROGRAM</code> 和 <code>ENDCG</code> 之间。</li></ul></li><li>Unity Shader: Unity 开发中, 有三种形式来编写 Unity Shader<ul><li>表面着色器 (Surface Shader): 噢噢噢噢，Unity 的宠儿. 使用这种着色器, 开发人员无需过多关注光照的处理细节</li><li>顶点&#x2F;片元着色器 (Vertex&#x2F;Fragment Shader): 更加复杂, 灵活度更高. 博主全权负责开发的 AR 直播项目 100% 采用这种形式</li><li>固定函数着色器 (Fixed Function Shader): 已经被抛弃, 也可以稍稍了解下</li></ul></li></ul><h2 id="3D-空间变换-投影，坐标变换"><a href="#3D-空间变换-投影，坐标变换" class="headerlink" title="3D 空间变换: 投影，坐标变换"></a>3D 空间变换: 投影，坐标变换</h2><ul><li>坐标投影: 也即 3D —&gt; 2D, 从世界坐标系 —&gt; 投影平面的变换<ul><li>坐标变换: 依赖相机外参进行世界坐标到相机坐标的变换; 依赖内参进行进一步到投影平面的操作<ul><li>相机外参: 世界坐标系到相机坐标系的变换 (<strong>必须</strong>)</li><li>相机内参: 进一步变换到投影屏幕 (<strong>可选</strong>) (物理相机的畸变在大多数情况下可忽略, 但直播画面必须要进行处理)</li></ul></li><li>3D 点投影: 即消除系数 <code>Z</code> 的作用 (透视投影下, 平行线会在无穷远处相交. <code>Z</code> 可理解为深度信息或距离)<ul><li>齐次坐标系: <code>pos_2d = world2Proj * pos_3d</code></li><li>笛卡尔坐标系: <code>pos_2d = pos_2d / pos_2d.z</code></li></ul></li></ul></li></ul><h2 id="3D-模型：点云处理-模型拼接"><a href="#3D-模型：点云处理-模型拼接" class="headerlink" title="3D 模型：点云处理, 模型拼接"></a>3D 模型：点云处理, 模型拼接</h2><p>AR 字面义为 <strong>增强现实</strong>. 说白了, AR 也就是在现实世界的基础上增加些 <strong>点缀</strong>. 点缀容易, 但要点缀地恰到好处：</p><ul><li>视觉上: 让用户感到 <strong>恰到好处</strong>, 也即视野范围内的径向位置合适, 径向深度合适</li><li>听觉上：让用户感受到那种 <strong>由远及近的鸣笛声</strong></li></ul><p>本文重点讲解视觉上的效果处理 (后续有机会的话, 再对声音的多普勒效应模拟展开介绍). AR 增强现实要做到上述的效果, 离不开对现实世界的 <strong>建模</strong> 和 <strong>标定</strong>. 对于不同的 AR 应用, 建模的方式有多种. 拿 LPL 直播效果, 盲猜他们会选择如下几种方式 (或者完全不需要, LPL 不需要对整个直播场地毫无遗漏的高精度要求)</p><ul><li>点云扫描：扫描精度不够, 尤其是边角处. 需要专业人员对从点云的导出模型进行修模 (如: 减面), 否侧很容易到达数百万顶点的模型文件</li><li>设计模型：过于理想, 现场搭建的场地往往是组装起来的. 而组装的精度跟施工人员专业程度, 场地大小强相关</li><li>设计模型拼接：相对比较节省人力, 节省时间的方式. 它的精度足够满足 AR 呈现的需求<ul><li>设计模型分块：按照实际场地的组装形式，对整体的设计模型进行拆分.</li><li>场地标定：对搭建后的场地, 按需进行坐标点标定</li><li>模型拼接：需要专用的模型拼接软件进行拼接. 作为当年的预研项, 博主当时耗时三周完成了基本功能的开发<ul><li>模型动态导入: <a href="https://ricardoreis.net/trilib-a-unity-3d-file-loader-asset/">插件</a>可用, 很好用<ul><li>模型缩放问题：可选缩放系数</li><li>模型材质问题：需要遍历所有的 <code>material</code>, 有些模型会存在 submesh 的情况</li></ul></li><li>模型拼接并导出: Unity 官方插件可用, 依赖于 Editor 模式<ul><li>模型缩放问题：100:1 的问题</li><li>模型格式问题：导入和导出的格式会涉及 fbx, obj, 因为我们是需要给模型贴图的. 某些情况下会生成光秃秃的模型哈哈哈哈</li></ul></li><li>模型点拾取: 实际上拾取的是三角面, 然后计算出距离拾取点最近的模型顶点. 注: 会存在多个三角面共点的情况</li><li>刚体变换: 奇异值求解 T44 坐标变换矩阵; 然后对模型施加相应分量的旋转、平移、缩放. 不难哈哈哈哈</li></ul></li></ul></li></ul><h2 id="相机内外参"><a href="#相机内外参" class="headerlink" title="相机内外参"></a>相机内外参</h2><p>内外参完全描述了物理相机的所有信息, 包括：相对于世界坐标系的变换, 相机的物理参数</p><ul><li>外参: 描述了相机的 <strong>位姿</strong> 信息, 包括：旋转参数, 平移参数. 旋转通常由 <strong>Euler</strong> 角描述, 可表示为 (qx, qy, qz, qw) </li><li>内参: 描述了相机的 <strong>畸变</strong> 和相机参数信息, 包括: 内参矩阵, 畸变系数 <ul><li>内参系数: fx, fy, cx, cy</li><li>畸变系数: 径向畸变, 切向畸变<ul><li>径向畸变: 来自透镜形状不规则及建模方式, 导致镜头不同区域焦距不同. 光线远离透镜中心的地方偏折更大 (枕型畸变) 或更小 (桶形畸变). 通常由 k1, k2, k3 表示</li><li>切向畸变：来自整个相机的组装过程. 由于透镜制造上的缺陷, 使得透镜本身与图像平面不平行而产生的 通常由 p1, p2 表示</li></ul></li></ul></li></ul><h2 id="模型拼接"><a href="#模型拼接" class="headerlink" title="模型拼接"></a>模型拼接</h2><p>有很多前置条件不在本文讲解范围，后续有机会再分享。</p><ul><li><strong>模型分割</strong> ：即对整体的设计模型, 按照施工人员的组装方式进行分割。 这部分工作由相应的设计人员来完成, 但需要我们提出几点技术要求：<ul><li>坐标系: 统一为 AR 系统中采用的 <strong>左手系</strong> 或者 <strong>右手系</strong> 。 <strong>预备知识</strong> 中对 <strong>GPU 流水线</strong> 的描述中有提及</li><li>坐标零点: 尽量保持处于模型的集合中心, 这样方便用户交互 (基于坐标零点)</li><li>模型缩放: 根据最终使用模型的引擎工具, 要对模型进行相应的缩放。比如： Unity 中导入的模型会存在 100:1 的关系</li><li>模型贴图：这点对于具有对称性的 AR 场地比较重要</li><li>模型减面: 比如, 可以在 Blender 中对模型添加 <code>Decimate Modifier</code>, 对不可见细节进行减面处理</li></ul></li><li><strong>模型动态导入</strong> ：Unity 开发中， 可以借助付费插件 <a href="https://assetstore.unity.com/packages/tools/modeling/trilib-2-model-loading-package-157548">Trilib</a> 来完成</li><li><strong>模型点拾取</strong> ：涉及到 <strong>3渲2</strong> 或 <strong>OSR</strong> ，即：用户看到的永远是 2D 图片, 用户的交互会被投影到不可见的 3D 场景</li><li><strong>模型定位</strong> ：即根据现实世界中测量的模型位置 (至少有 3 个不共面的模型顶点), 求解拾取点所需要的变换操作<ul><li>刚体变换求解：<ul><li>平移：消除偏移对拾取点的影响。如果模型本身的原点处于集合中心，则无需本步操作</li><li>旋转：通过奇异值分解的方式，计算 <strong>模型坐标系</strong> 下拾取点到 <strong>世界坐标系</strong> 下的标定点的旋转矩阵（3X3）</li><li>变换矩阵：通过前两步参数，得到 T44 变换矩阵</li></ul></li><li>施加变换：对于 Unity 开发，也就1个接口的调用而已</li></ul></li><li><strong>模型拼接并导出</strong> ：依赖于 Unity 官方插件 以及 Editor 模式。注意导出模型存在 <code>SubMesh</code> 的情况</li></ul><h2 id="坐标映射"><a href="#坐标映射" class="headerlink" title="坐标映射"></a>坐标映射</h2><p>官方设备外形固定且位姿参数相对稳定。针对这种情况，通常将它们的物理属性以配置参数的形式介入前端渲染流程：通过 <strong>3D 投影</strong> 可在二维成像平面的 <strong>裁剪</strong> 区域形成 <strong>BoundingBox</strong> ，再根据径向深度就可对 <strong>BoundingBox</strong> 内的像素点进行剔除 （<code>Clip</code>）。 从而，产生视觉上的视觉差：<em>特效被遮挡了</em>  </p><ul><li><strong>BoundingBox</strong> 意义: 矩形框。由 3D 空间中的测量点 (标定点)，根据当前相机的内外参进行成像平面的实时投影。 内外参包括相机的 <code>Focus</code>, <code>Zoom</code>, <code>Eular Angle</code>, 而这几个参数跟相机动态变化的姿态和视野范围强相关。因此，需要进行实时投影。  </li><li>变换步骤：世界坐标系 –&gt; 相机坐标系 –&gt; 2D投影<ul><li>生成包围体：可选六棱柱，可根据需要测量点（没必要）</li><li>投影：世界坐标系到 2D 投影<ul><li>数据准备：<ul><li>外参矩阵（View2World）： 相机外参，即旋转，平移。 Unity 接口为 Matrix4x4::SetTRS()</li><li>内参矩阵（View2Proj）: 相机内参，即 fx, fy, cx, cy</li></ul></li><li>实施变换：有两种方式供选：可实现算法接口，也可直接调用 Opencv 接口<ul><li><strong>自定义接口</strong> ：<ul><li>求解 world2Proj 矩阵： world2Proj &#x3D; view2Proj * world2View</li><li>进行 3D 点投影：<ul><li>齐次坐标系：pos_2d &#x3D; worldProj * pos_3d</li><li>笛卡尔坐标系：pos_2d &#x3D; pos_2d &#x2F; pos2d.z</li></ul></li><li>计算 BoundingBox: 从六棱柱对应的 12 个投影后的 2D 坐标中，选出最小包围盒</li></ul></li><li><strong>Opencv 接口</strong> ：<ul><li>接口介绍：<ul><li>Calib3D.Rogdrigues: 依赖 <strong>外参矩阵</strong> ，计算 <strong>旋转向量</strong></li><li>Calib3D.projectPoints: 依赖 <strong>旋转向量</strong> ，<strong>平移向量</strong> ，<strong>内参矩阵</strong> ，__畸变系数__（可选），计算投影点</li><li>Imgproc.boundingRect: 计算包围盒</li></ul></li><li>步骤：<ul><li>平移向量：取自 T44 矩阵的最后一列，即平移参数</li><li>旋转向量：通过 Rodrigues 计算出旋转向量</li><li>3D 投影：通过 projectPoints 直接投影</li><li>BoundingBox：通过 Imgproc.boundingRect 计算出投影点的最小包围盒</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>本文仅对 AR 直播中深度处理及相关技术作简要介绍，暂未涉及 Coding 相关的技术和性能要求。</p>]]></content>
    
    
    <categories>
      
      <category>AR</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>[杂项] CEF3 -- IME Behavior</title>
    <link href="/2023/03/08/QCef-Ime-JSInject/"/>
    <url>/2023/03/08/QCef-Ime-JSInject/</url>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><ul><li><strong>Communications</strong> : between host and web<ul><li><a href="https://www.electronjs.org/docs/latest/tutorial/tutorial-preload"><strong>Preloading</strong></a>: supported by Electron only<blockquote><p>Preload scripts are injected <strong>BEFORE</strong> a web page loads in the renderer, similar to a Chrome extension’s content scripts. To add features to your renderer that require privileged access, you can define global objects through the contentBridge API.</p></blockquote><ul><li><strong>Guard current context</strong>: Embedding google login or facebook login page, for example, we need to isolate their content (global setting, global variables etc.). Otherwise, we may encounter various error info, for example, jquery related error or something else. And <code>Preload</code> is the only way to taskle this situation.</li></ul></li><li><a href="https://cefview.github.io/QCefView/zh/docs/reference/QCefView"><strong>Execute Javascript</strong></a>: supported by almost all framework<blockquote><p>Executes javascript code in specified frame at any time.</p></blockquote><ul><li><strong>Inject JS Code</strong>: In this way, we usually do something to adjust user interface, or fix some irregular behavior in our host. For example, constraint user to type chinese, japanese to <strong>INPUT</strong>, and this is the only way to fix this in OSR mode.</li></ul></li></ul></li><li><strong>Html</strong> :  <code>&lt;input/&gt;</code> event related<ul><li>Enter:<ul><li><code>keydown</code> -&gt; <code>keypress</code> -&gt; <code>change</code> -&gt; <code>keyup</code></li></ul></li><li>Alphabet: <ul><li><code>keydown</code> -&gt; <code>keypress</code> -&gt; <code>change</code> -&gt; <code>keyup</code></li></ul></li><li>Ime:<ul><li><code>compositionstart</code> -&gt; <code>compositionupdate</code> -&gt; <code>input</code> -&gt; … -&gt; <code>input</code> -&gt; <code>compositionend</code></li></ul></li><li>Ime: filter in <code>input</code> event<ul><li><code>compositionstart</code> -&gt; <code>compositionupdate</code> -&gt; <code>input</code> -&gt; … -&gt; <code>input</code> -&gt; <code>compositionend</code></li></ul></li></ul></li><li><strong>CEF</strong> : develop tools<ul><li>Mode:<ul><li>Popup Window: this is the only effective way if <strong>OSR</strong> enabled</li><li>Child Window: like all other browsers’ default behavior</li><li>Windowless: off-screen rendering</li></ul></li><li>Prerequisite:<ul><li>OnPreKeyEvent:<ul><li>CefViewBrowserClient: from CefViewBrowserClient_KeyboardHandler</li><li>CCefClientDelegate: from CCefCientDelegate_KeyboardHandler</li></ul></li></ul></li></ul></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>桌面端嵌入类 <code>webview</code> 的产品十分常见(开发周期极短, 开箱即用). 从某种程度上来讲，桌面软件扮演了浏览器的角色。对于常规 web 页面, 浏览器的行为在这种 Hybrid 模式的桌面软件中必定发生不符合预期的表现:  </p><ul><li>登录注册:<ul><li>Fackbook: 需要保证相对纯净的 jquery 上下文, 才能正常走完登录的流程</li><li>Google: 需要伪造合法的 User Agent, 才能通过页面的验证</li></ul></li><li>输入法: only <strong>IME</strong> introduced<ul><li>联想相关: 联想框弹出位置问题</li><li>IME: 中文输入法问题<ul><li>IE 浏览器: 可通过 属性 <code>ime-mode</code> 属性屏蔽 <code>composition</code> 相关动作</li><li>Chrone 系列： 不支持 <code>ime-mode</code><ul><li>屏蔽系统输入法 </li><li>JS 注入, 以改变 <strong>HTML</strong> 默认行为</li></ul></li></ul></li></ul></li></ul><p>本文主要介绍 web 页面内 <code>input</code> 标签屏蔽中文输入的相关方法. 考虑到 Cef 支持两种渲染模式(<strong>OSR</strong>, <strong>NON-OSR</strong>), 这里介绍两种不同的方式处理中文输入问题：屏蔽系统输入法, JS 注入改变默认行为.</p><h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><ul><li>双端通讯: 主进程与渲染进程间通信的方式，无外乎通过全局变量(window.XXXX). Electron 开发中就是直接的对 <code>window</code> 进行赋值. QCef 则提供了 <code>setBridgeObjectName</code> 接口. 二者本质上没有区别.<ul><li>进程通信:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QCefConfig::<span class="hljs-built_in">setBridgeObjectName</span>(<span class="hljs-string">&quot;CallBridge&quot;</span>);<br></code></pre></td></tr></table></figure></li><li>HTML 回调:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-string">R&quot;(</span><br><span class="hljs-string">    window.addEventListener(&#x27;load&#x27;, ()=&gt;&#123;</span><br><span class="hljs-string">        setTimeout(()=&gt;&#123;</span><br><span class="hljs-string">            var inputs = document.getElementsByClassName(&#x27;XXXXXX&#x27;); // or getElementById</span><br><span class="hljs-string">            if(inputs.length &gt; 0)&#123;</span><br><span class="hljs-string">                // method 1</span><br><span class="hljs-string">                inputs[0].addEventListener(&quot;XXXXX&quot;, (event)=&gt;&#123;</span><br><span class="hljs-string">                    // 改变 HTML 默认行为, 达到屏蔽中文的目的</span><br><span class="hljs-string">                &#125;);</span><br><span class="hljs-string">                // method 2</span><br><span class="hljs-string">                inputs[0].addEventListener(&quot;YYYYY&quot;, (event)=&gt;&#123;</span><br><span class="hljs-string">                    // 回调至主进程, 以屏蔽输入法</span><br><span class="hljs-string">                &#125;)</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;, 200); // delay 200ms in case too early to find no &lt;input/&gt;</span><br><span class="hljs-string">    &#125;);</span><br><span class="hljs-string">)&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li><li>屏蔽系统输入法: 这是相对比较合理的处理方式. 此处贴出相关逻辑处理 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">XXX::setImeEnabled</span><span class="hljs-params">(<span class="hljs-type">bool</span> enabled)</span></span><br><span class="hljs-function"></span>&#123;<br>    HWND wnd = <span class="hljs-built_in">getWindowHandle</span>(); <span class="hljs-comment">// user defined</span><br>    <span class="hljs-keyword">if</span>(enabled)<br>    &#123;<br>        m_himc = ::<span class="hljs-built_in">ImmGetContext</span>(wnd);<br>        <span class="hljs-keyword">if</span>(m_himc)<br>        &#123;<br>            <span class="hljs-built_in">ImmAssociateContext</span>(wnd, <span class="hljs-literal">nullptr</span>);<br>            <span class="hljs-built_in">ImmReleaseContext</span>(wnd, m_himc);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(m_himc)&#123;<br>            <span class="hljs-built_in">ImmDestroyContext</span>(m_himc);<br>            m_himc = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        m_himc = <span class="hljs-built_in">ImmCreateContext</span>();<br>        <span class="hljs-keyword">if</span>(m_himc)<br>        &#123;<br>            <span class="hljs-built_in">ImmAssociateContext</span>(wnd, m_himc);<br>            <span class="hljs-built_in">ImmReleaseContext</span>(wnd, m_himc);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>JS 注入: OSR 模式下, 业务层无法拿到当前输入法对应的窗口句柄(HWND). 为了保证 Web 页面多端行为一致性, 要求相应开发修改前端逻辑是不合适的.</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>两种方式可以屏蔽用户输入中文密码的问题:  </p><ul><li>屏蔽中文输入法:<br>通过注入代码的形式, 绑定 <code>&lt;input/&gt;</code> 焦点事件. 当获取焦点时, 通过捕获 <code>focus</code> 事件的方式间接通知 host 屏蔽当前窗口对应的输入法，即: 调用 <code>setImeEnabled</code>. 当失去焦点时, 则通知 host 恢复当前窗口的输入法状态.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">YYY::injectToLogin</span><span class="hljs-params">()</span></span>&#123;<br>    QString jsCode = <span class="hljs-string">R&quot;(</span><br><span class="hljs-string">        window.addEventListener(&#x27;load&#x27;, ()=&gt;&#123;</span><br><span class="hljs-string">            setTimeout(()=&gt;&#123;</span><br><span class="hljs-string">                var inputs = document.getElementsByClassName(&#x27;XXXXXX&#x27;); // or getElementById</span><br><span class="hljs-string">                if(inputs.length &gt; 0)&#123; // method 2</span><br><span class="hljs-string">                    inputs[0].addEventListener(&quot;focus&quot;, (event)=&gt;&#123;</span><br><span class="hljs-string">                        window.CallBridge.invokeMethod(&quot;inputFocus&quot;, &#x27;&#123;&quot;focus&quot;: true&#125;&#x27;);</span><br><span class="hljs-string">                    &#125;)</span><br><span class="hljs-string">                    inputs[0].addEventListener(&quot;focusout&quot;, (event)=&gt;&#123;</span><br><span class="hljs-string">                        window.CallBridge.invokeMethod(&quot;inputFocus&quot;, &#x27;&#123;&quot;focus&quot;: false&#125;&#x27;);</span><br><span class="hljs-string">                    &#125;)</span><br><span class="hljs-string">                &#125;</span><br><span class="hljs-string">            &#125;, 200); // delay 200ms in case too early to find no &lt;input/&gt;</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">    )&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>Js 注入:<br>当采用这种方式过滤中文字符时，会造成用户无法通过 ENTER 键触发登录的问题. 由 <strong>预备知识</strong> 可知, <code>keydown</code> 是最早触发的事件. 通过捕获 <code>keydown</code> 事件, 我们可以在用户输入完密码并按下 <strong>ENTER</strong> 键的第一时刻模拟登录按钮的单击事件.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">YYY::injectToLogin</span><span class="hljs-params">()</span></span>&#123;<br>    QString jsCode = <span class="hljs-string">R&quot;(</span><br><span class="hljs-string">        window.addEventListener(&#x27;load&#x27;, ()=&gt;&#123;</span><br><span class="hljs-string">            setTimeout(()=&gt;&#123;</span><br><span class="hljs-string">                var inputs = document.getElementsByClassName(&#x27;XXXXXX&#x27;); // or getElementById</span><br><span class="hljs-string">                if(inputs.length &gt; 0)&#123; // method 1</span><br><span class="hljs-string">                    inputs[0].addEventListener(&quot;keydown&quot;, (event)=&gt;&#123; // fix: simulate click event trigger by ENTER</span><br><span class="hljs-string">                        var key = event.which;</span><br><span class="hljs-string">                        if(key === 13)</span><br><span class="hljs-string">                        &#123;</span><br><span class="hljs-string">                            inputs[0].blur();</span><br><span class="hljs-string">                            var loginBtn = document.getElementById(&#x27;YYYYYY&#x27;)</span><br><span class="hljs-string">                            if(loginBtn)&#123;</span><br><span class="hljs-string">                                const event = new MouseEvent(&#x27;click&#x27;, &#123;</span><br><span class="hljs-string">                                    view: window,</span><br><span class="hljs-string">                                    bubbles: true,</span><br><span class="hljs-string">                                    cancelable: true</span><br><span class="hljs-string">                                &#125;);</span><br><span class="hljs-string">                                loginBtn.dispatchEvent(event);</span><br><span class="hljs-string">                            &#125;</span><br><span class="hljs-string">                        &#125;</span><br><span class="hljs-string">                    &#125;)</span><br><span class="hljs-string">                    inputs[0].addEventListener(&quot;input&quot;, (event)=&gt;&#123;</span><br><span class="hljs-string">                        event.target.value = event.target.value.replace(/[\u4e00-\u9fa5]/g, &#x27;&#x27;);</span><br><span class="hljs-string">                    &#125;)</span><br><span class="hljs-string">                &#125;</span><br><span class="hljs-string">            &#125;, 200); // delay 200ms in case too early to find no &lt;input/&gt;</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">    )&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="To-be-continued-…"><a href="#To-be-continued-…" class="headerlink" title="To be continued …"></a>To be continued …</h1>]]></content>
    
    
    <categories>
      
      <category>Cef</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>[杂项] rlottie</title>
    <link href="/2023/02/18/CPP-Animation-rlottie/"/>
    <url>/2023/02/18/CPP-Animation-rlottie/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开源的 rlottie SDk。</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><ul><li><p>Concurrency In Action: <strong>single-producer, single-consumer</strong></p><ul><li><p>Lock-free concurrent data structure: </p><blockquote><p>lock-free data structures rely on the use of <strong>atomic operations</strong> and the associated <strong>memory-ordering</strong> guarantees in order to ensure that data becomes <strong>visible</strong> to other threads in the <strong>correct order</strong>.  </p></blockquote></li><li><p>Guildllines: </p><blockquote><ul><li>use <code>std::memory_order_seq_cst</code> for prototyping </li><li>use a lock-free memory reclamation scheme </li><li>simplify it to the context: <ul><li>only one thread calling <code>push()</code> at a time </li><li>only one thread calling <code>pop()</code> at a time</li></ul></li><li>watch out for the ABA problem</li><li>identify busy-wait loops and help the other thread</li></ul></blockquote></li></ul></li><li><p><a href="https://lottiefiles.com/">Lottie</a>:</p><blockquote><p>A lottie is JSON-based animation file format that allows you to ship animations on any playform as easily as shipping static assets.  </p></blockquote><ul><li><p>Parse Lottie:</p><ul><li><a href="https://doc.qt.io/qt-6/qml-qt-labs-lottieqt-lottieanimation.html">LottieAnimation</a>: a bodymovin player for Qt </li><li><a href="https://github.com/Samsung/rlottie">rlottie</a>: a platform independent standalone c++ library for rendering vector based animations and art <strong>IN REALTIME</strong></li></ul></li><li><p>Tips on rlottie:</p><ul><li>render mode: synchronize (<code>rendersync</code>) and asynchronzie (<code>render</code>)</li><li>cache policy: load from data with corresponding <strong>key</strong> to distinguish different cache</li></ul></li></ul></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>客户端中使用动画的业务场景大致相同, 如下范式可供参考:  </p><blockquote><p>本博主负责的 AR 直播 (1080p59.94) 项目中使用过类似范式： 16.6ms 内使用最少的 cpu 时间处理 4 路输出, 而每路每帧的 1080p 图片 <code>copy</code> 耗时 3ms 左右哦.</p></blockquote><ul><li>desigen structure:<ul><li>设计 <strong>单生产单消费者</strong> 数据结构: <code>lock_free_queue</code></li><li>分析业务场景并简化之，以适用于 <code>lock_free_queue</code></li></ul></li><li>request render: <ul><li>通过异步接口 <code>render()</code> 请求渲染一帧图片，并得到对应的 <code>future</code> 对象.  </li><li>将 <code>future</code> 对象存至对应的 <code>lock_free_queue</code>: <code>render_queue</code></li></ul></li><li>process request: 遍历所有 <code>render_queue</code> 中的所有 <code>future</code> 对象 (得益于良好的数据结构，业务逻辑无需锁)</li></ul><h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><p>本阶段就是要设计 (拿来主义) 对应的 <strong>无锁</strong> 数据结构啦, 一切从简, 就简单贴出标准的接口.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lock_free_queue</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>    &#123;<br>        std::shared_ptr&lt;T&gt; data;<br>        ndoe* next;<br>        <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    &#125;;<br>    std::atomic&lt;ndoe*&gt; head;<br>    std::atomic&lt;node*&gt; tail;<br>    <span class="hljs-function">node* <span class="hljs-title">pop_head</span><span class="hljs-params">()</span></span>&#123;<br>        node* <span class="hljs-type">const</span> old_head = head.<span class="hljs-built_in">load</span>();<br>        <span class="hljs-keyword">if</span>(old_head == tail.<span class="hljs-built_in">load</span>()) &#123;                                     <span class="hljs-comment">// &lt;order&gt; 1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        head.<span class="hljs-built_in">store</span>(old_head-&gt;next);<br>        <span class="hljs-keyword">return</span> old_head;<br>    &#125;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">lock_free_queue</span>():<span class="hljs-built_in">head</span>(<span class="hljs-keyword">new</span> node), <span class="hljs-built_in">tail</span>(head.<span class="hljs-built_in">load</span>())&#123;&#125;<br>    <span class="hljs-built_in">lock_free_queue</span>(<span class="hljs-type">const</span> lock_free_queue&amp; other)=<span class="hljs-keyword">delete</span>;<br>    lock_free_queue&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> lock_free_queue&amp; other)=<span class="hljs-keyword">delete</span>;<br>    ~<span class="hljs-built_in">lock_free_queue</span>();<br><br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>        node* old_head=<span class="hljs-built_in">pop_head</span>();<br>        <span class="hljs-keyword">if</span>(!old_head) <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt;();<br>        <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-type">const</span> <span class="hljs-title">res</span><span class="hljs-params">(old_head-&gt;data)</span></span>;                     <span class="hljs-comment">// &lt;order&gt; 2 </span><br>        <span class="hljs-keyword">delete</span> old_head;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T new_value)</span></span>&#123;<br>        <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">new_data</span><span class="hljs-params">(std::make_shared&lt;T&gt;(new_value))</span></span>;<br>        node* p = <span class="hljs-keyword">new</span> node;                                               <span class="hljs-comment">// &lt;order&gt; 3</span><br>        node* <span class="hljs-type">const</span> old_tail = tail.<span class="hljs-built_in">load</span>();                               <span class="hljs-comment">// &lt;order&gt; 4</span><br>        old_tail-&gt;data.<span class="hljs-built_in">swap</span>(new_data);                                    <span class="hljs-comment">// &lt;order&gt; 5</span><br>        old_tail-&gt;next = p;                                               <span class="hljs-comment">// &lt;order&gt; 6</span><br>        tail.<span class="hljs-built_in">store</span>(p);                                                    <span class="hljs-comment">// &lt;order&gt; 7</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>本阶段仅仅列出 <code>rlottie</code> 接口相关的内容. </p><blockquote><p><strong>预备知识</strong> 和 <strong>简介</strong> 是理论和实践经验的陈述. 其中涉及的异步处理框架, 需要根据项目的业务场景和采用的设计模式 (MVC, MVVM) 进行定制. </p></blockquote><ul><li>parseLottie: <code>lottie</code> 初始化, 包括: Animation, Surface 对象的构造, 堆内存分配<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parseLottie</span><span class="hljs-params">(std::string lottie_file)</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-comment">// load data</span><br>     <span class="hljs-keyword">auto</span> lottieData = util::<span class="hljs-built_in">loadFromFile</span>(lottie_file); <span class="hljs-comment">// load lottie.json file from lottie_file</span><br>     <span class="hljs-comment">// parse lottie and contruct `Animation`</span><br>     lottieAnimation = Animation::<span class="hljs-built_in">loadFromData</span>(lottieData, lottie_file); <span class="hljs-comment">// ****key: lottie_file****</span><br>     <span class="hljs-comment">// alloc 1 frame buffer and construct `Surface`</span><br>     <span class="hljs-type">size_t</span> bytesPerLine = cols * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">unint32_t</span>); <span class="hljs-comment">// row bytes to iterate</span><br>     <span class="hljs-keyword">auto</span> lottieBuffer = (<span class="hljs-type">uint32_t</span>*)<span class="hljs-built_in">malloc</span>(bytesPerline * rows);<br>     lottieSurface = <span class="hljs-built_in">Surface</span>(lottieBuffer, cols, rows, bytesPerline);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>requestRender: 以 <code>lottie</code> 动画的帧率, 调用该接口完成 1 次异步渲染请求<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">requestRender</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> future = lottieAnimation-&gt;<span class="hljs-built_in">render</span>(currentFrame, lottieSurface, <span class="hljs-literal">true</span>);<br>    currentFrame = (currentFrame + <span class="hljs-number">1</span>) % lottieAnimation-&gt;<span class="hljs-built_in">totalFrame</span>();<br>    <span class="hljs-comment">// lock-free queue</span><br>    lottieQueue-&gt;<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">make_pair</span>(key_to_index, future));<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="插件集成-–-Windows"><a href="#插件集成-–-Windows" class="headerlink" title="插件集成 – Windows"></a>插件集成 – Windows</h1><ul><li><strong>Build rlottie</strong><ul><li>Install <a href="https://gnuwin32.sourceforge.net/packages/make.htm">make</a> on Windows: in case of <code>command not found</code> on <code>make -j 2</code></li><li>Build libs for Windows: no need to flow <a href="https://github.com/Samsung/rlottie">rlottie</a><ul><li>step 1: <code>cmake ..</code> produces Visual Studio Solution (default on Windows)</li><li>step 2: open <em>rlottie.sln</em> and build it with Visual Studio</li></ul></li></ul></li><li><strong>Integrate rlottie</strong><ul><li><p>Header Files:</p><ul><li>Visual Studio: setup <em>Additional Include Directories</em></li><li>CMakeLists  <table style="margin-bottom: 8px">  <tbody>  <tr style="border: none">      <td style="background: black; border: none; width: 100vw; border-radius: 4px">          <ol style="margin:0">              <li align="left"><b>                  <font size=2 color=steelblue>include_directories</font><font size=2 color=silver>&ensp;(</font>              </b></li>              <li align="left"><b>                  <font size=2 color=mediumseagreen>&emsp;&emsp;${CMAKE_SOURCE_DIR}</font><font size=2 color=silver>/rlottie/</font><font size=2 color=skyblue>include</font>              </b></li>              <li align="left"><b>                  <font size=2 color=silver>)</font>              </b></li>          </ol>      </td>  </tr>  </tbody>  </table></li></ul></li><li><p>Libs</p><ul><li>Visual Studio: setup <em>Additional Dependencies</em></li><li>CMakeLists  <table style="margin-bottom: 8px">  <tbody>  <tr style="border: none">      <td style="background: black; border: none; width: 100vw; border-radius: 4px">          <ol style="margin:0">              <li align="left"><b>                  <font size=2 color=steelblue>target_link_libraries</font><font size=2 color=silver>&ensp;(</font><font size=2 color=mediumseagreen>${PROJECT_NAME}</font>              </b></li>              <li align="left"><b>                  <font size=2 color=skyblue>PRIVATE</font>              </b></li>              <li align="left"><b>                  <font size=2 color=gainsboro>debug</font>              </b></li>              <li align="left"><b>                  <font size=2 color=mediumseagreen>${CMAKE_SOURCE_DIR}</font><font size=2 color=silver>/rlottie/sdk/debug/rlottie.lib</font>              </b></li>              <li align="left"><b>                  <font size=2 color=gainsboro>optimized</font>              </b></li>              <li align="left"><b>                  <font size=2 color=mediumseagreen>${CMAKE_SOURCE_DIR}</font><font size=2 color=silver>/rlottie/sdk/release/rlottie.lib</font>              </b></li>              <li align="left"><b>                  <font size=2 color=silver>)</font>              </b></li>          </ol>      </td>  </tr>  </tbody>  </table></li></ul></li><li><p>Dlls</p><ul><li>Visual Studio: copy them to <em>Output Directory</em></li><li>CMakeLists  <table style="margin-bottom: 8px">  <tbody>  <tr style="border: none">      <td style="background: black; border: none; width: 100vw; border-radius: 4px">          <ol style="margin:0">              <li align="left"><b>                  <font size=2 color=white>cmake_path(CONVERT</font>                  <font size=2 color=peru>&ensp;"</font>                  <font size=2 color=mediumseagreen>${CMAKE_SOURCE_DIR}</font>                  <font size=2 color=white>/rlottie/sdk/$<CONFIG>/*.dll TO_NATIVE_PATH_LIST rlottie_dll_path)</font>              </b></li>                  <li align="left"><b>                  <font size=2 color=white>cmake_path(CONVERT</font><font size=2 color=peru>&ensp;"</font><font size=2 color=mediumseagreen>${CMAKE_RUNTIME_OUTPUT_DIRECTORY}</font><font size=2 color=peru>/"</font><font size=2 color=white>&ensp;TO_NATIVE_PATH_LIST runtime_output_ path)</font>              </b></li>              <li align="left"><b>                  <font size=2 color=steelblue>add_custom_command</font><font size=2 color=white>(</font><font size=2 color=steelblue>TARGET</font><font size=2 color=mediumseagreen>${XXX_TARGET_NAME}</font><font size=2 color=white>&ensp;POST_BUILD</font>              </b></li>              <li align="left"><b>                  <font size=2 color=steelblue>&emsp;&emsp;&emsp;&emsp;COMMAND</font><font size=2 color=white>&ensp;xcopy</font><font size=2 color=peru>&ensp;"</font><font size=2 color=mediumseagreen>${rlottie_dll_path}</font><font size=2 color=peru>"&ensp;"</font><font size=2 color=mediumseagreen>${runtime_output_path}</font><font size=2 color=peru>"</font><font size=2 color=white>&ensp;/y</font>              </b></li>              <li align="left"><b>                  <font size=2 color=steelblue>&emsp;&emsp;&emsp;&emsp;WORKING_DIRECTORY</font><font size=2 color=mediumseagreen>${CMAKE_CURRENT_SOURCE_DIR}</font>              </b></li>              <li align="left"><b>                  <font size=2 color=steelblue>&emsp;&emsp;&emsp;&emsp;COMMAND</font><font size=2 color=peru>&ensp;"Copying thirdparty files"</font><font size=2 color=steelblue>&ensp;VERBATIM</font>              </b></li>              <li align="left"><b>                  <font size=2 color=white>&emsp;&emsp;&emsp;)</font>              </b></li>          </ol>      </td>  </tr>  </tbody>  </table></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>[杂项] Enum to String</title>
    <link href="/2023/01/23/CPP-Macro-Enum2String/"/>
    <url>/2023/01/23/CPP-Macro-Enum2String/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>来自开源库 <a href="https://github.com/jalencui/magic_enum">magic_enum</a> 的思考。</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><!--> block reference used head of paragragh, and can be nested.--><ul><li>Standard predefined identifier: 预定义标识符  <ul><li><code>__func__</code>: 返回所在函数闭包对应的函数名. 本质上是常量字符数组, 由编译器提供(ISO C99 &amp; ISO C++11), 格式: <code>const char __func__[]</code></li></ul></li><li>Standard predefined macro: 预定义宏<blockquote><p>MSVC supports the predefined preprocessor macros required by the ANSI&#x2F;ISO C99, C11, and C17 standards, and the ISO C++14, C++17, and C++20 standards. </p></blockquote><ul><li>可提供通用的辅助性信息<ul><li><code>__LINE__</code>: 提供当前函数所在的行号, 格式: 数字</li><li><code>__FILE__</code>: 当前函数所在的文件, 格式: 字符串</li><li><code>__DATE__</code>: 当前日期, 格式: <code>Jan 19 2023</code></li><li><code>__TIME__</code>: 当前时间信息, 格式: <code>22:35:41</code></li></ul></li><li>提供具体到函数调用的信息本文将利用 <code>__FUNCSIG__</code> 提供的信息, 模拟反射机制来将 enum 变量转为字符串 <ul><li><code>__FUNCTION__</code>: 提供所在闭包对应函数的函数名, 格式: 返回 <code>__func__</code> 的值</li><li><code>__FUNCDNAME__</code>: 提供函数修饰名, 格式: <code>?main@@YAHXZ</code> 或 <code>main</code> 或 <code>_main</code>（可理解为符号表中导出的符号）</li><li><code>__FUNCSIG__</code>: 提供函数的完整声明(同g++支持的宏:<code>__PRETTY_FUNCTION__</code>), 格式: <code>int __cdecl main(void)</code></li></ul></li></ul></li><li>编译方式: 导出符号的修饰规则, 会影响到部分预定义宏的返回结果<ul><li><code>extern &quot;C&quot;</code>: 不带修饰符. 此时, <code>__FUNCTION__</code> 与 <code>__FUNCDNAME__</code> 的值相同 </li><li>其他: 导出符号被修饰, 如: <code>?main@@YAHXZ</code>, 可拆分为 <code>?</code> + <code>main</code> + <code>@@</code> + <code>参数表代号</code><ul><li>修饰符: 用于函数重载</li><li>代号: XDEFHIJKMN_NU, 比如: @@YAHXZ可拆分为<ul><li>@@YA:起始位置, 也有@@YG, @@YI</li><li>H: 返回类型为 <code>int</code></li><li>X: 参数列表为空, 即 <code>void</code></li><li>Z: 结束位置, 也有@Z</li></ul></li></ul></li></ul></li><li>调用约定:   <ul><li><code>_cdecl</code>: C Declaration 的缩写, 即采用 C 语言的声明方式（C缺省调用方式）  <ul><li>参数从右—&gt;左依次入栈</li><li>手动清栈, 即由调用者来恢复堆栈</li></ul></li><li><code>_stdcall</code>: Standard Call 的缩写, 是 C++ 的标准调用方式. MSVC 宏有 <code>PASCAL</code>, <code>WINAPI</code>, <code>CALLBACK</code> <ul><li>参数从右—&gt;左依次入栈</li><li>自动清栈, 即由被调用函数来恢复堆栈</li></ul></li><li><code>_fastcall</code><ul><li>参数借由CPU寄存器(ecx, edx)和堆栈来处理参数信息, 从右—&gt;左依次入栈</li><li>自动清栈: 同<code>_stdcall</code>, 减轻调用者负担</li></ul></li></ul></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>业务开发过程中, 会遇到需要获取 <krd>Enum</krd> 的相关信息, 具体应用场景如下: </p><ul><li>配置信息: 枚举值本身在代码逻辑中用于归类; 枚举名在初始化阶段作为配置信息的索引</li><li>多语言: 完整的枚举名列表用于前端UI展示; 枚举值用于用户交互进行语言切换</li></ul><p>本文目标是模拟反射机制(c#, java), 获取对应枚举的相关信息. 由预备知识可知, <code>__FUNCSIG__</code> 可获取当前函数的完整声明信息(包括调用约定信息). 不由产生两个疑问: </p><ul><li><code>__FUNCSIG__</code> 是如何获得函数的完整声明?</li><li>函数的声明如何能获得任意类型的 <code>enum class</code> 的相关信息?</li></ul><p>好的问题远比答案重要: 在编译阶段, 模板函数会对所有的枚举类型进行实例化. 而实例化过程中, 传入的枚举类型及枚举值就是我们所需要的相关信息. 本文目标是提供操作枚举类型的工具函数, 如下:</p><ul><li><code>get_enum_name</code>: 通过枚举值, 获取对应名称</li><li><code>get_all_enum_names</code>: 获取枚举类型中所有值对应的名称列表</li><li><del><code>get_enum_value</code>: 通过名称, 获取对应枚举值</del></li><li><del><code>check_enum_valid</code>: 确认是否是有效的枚举(value or name)</del></li></ul><h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><p>考虑到兼顾不同编译器的情况, 需要对不同编译器提供的预定义宏进行适配. 个人比较喜欢 <code>__PRETTY_FUNCTION__</code>, 如下:   </p><ul><li><blockquote><p><a href="https://learn.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-170">msvc</a>: <code>__FUNCSIG__</code> Defined as a string literal that contains the signature of the enclosing function.</p></blockquote></li><li><blockquote><p><a href="https://gcc.gnu.org/onlinedocs/gcc/Function-Names.html">gcc</a>: In C, <code>__PRETTY_FUNCTION__</code> is yet another name for <code>__func__</code>, except that at file scope (or, in C++, namespace scope), it evaluates to the string “top level”. In addition, in C++, <code>__PRETTY_FUNCTION__</code> contains the signature of the function as well as its bare name.</p></blockquote></li></ul><table style="margin-bottom: 8px;">    <tbody>        <tr style="border: none">            <td style="background: black; border: none; width: 100vw; border-radius: 4px">                <ol style="margin:0;">                    <li align="left"><b>                        <font size=2 color=silver>#if&ensp;!defined(</font><font size=2 color=peru>__PRETTY_FUNCTION__</font><font size=2 color=silver>)&ensp;&&&ensp;!defined(</font><font size=2 color=gainsboro>__GNUC__</font><font size=2 color=silver>)</font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=silver>#&emsp;&emsp;define</font>                        <font size=2 color=mediumpurple>__PRETTY_FUNCTION__</font>                        <font size=2 color=peru>__FUNCSIG__</font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=silver>#endif</font>                    </b></li>                </ol>            </td>        </tr>    </tbody></table>  <p>同时, 提供工具函数用于遍历枚举类的所有枚举值: 根据阈值 <code>boundary</code>, 生成枚举值所在范围列表 [-boundary, boundary)  </p><table style="margin-top: 8px">    <tbody>        <tr style="border: none">            <td style="background: black; border: none; width: 100vw; border-radius: 4px">                <ol style="margin:0;">                        <li align="left"><b>                        <font size=2 color=steelblue>template</font><font size=2 color=silver>&ensp;<</font><font size=2 color=steelblue>int</font><font size=2 color=silver>...</font><font size=2 color=gainsboro>&ensp;sequence</font><font size=2 color=silver>></font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=steelblue>constexpr&ensp;auto</font><font size=2 color=lemonchiffon>&ensp;make_sequence_impl</font><font size=2 color=silver>(std::</font><font size=2 color=mediumseagreen>index_sequence</font><font size=2 color=silver><</font><font size=2 color=gainsboro>sequence</font><font size=2 color=silver>...>&ensp;seq)&ensp;{</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&ensp;return</font><font size=2 color=silver>&ensp;std::</font><font size=2 color=mediumseagreen>integer_sequence</font><font size=2 color=silver><</font><font size=2 color=steelblue>int</font><font size=2 color=silver>,&ensp;(</font><font size=2 color=gainsboro>sequence&ensp;-</font><font size=2 color=silver>&ensp;seq.</font><font size=2 color=gainsboro>size</font><font size=2 color=silver>())...,</font><font size=2 color=gainsboro>&ensp;sequence</font><font size=2 color=silver>...>();</font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=silver>}</font>                    </b></li>                                           <li align="left"><b>                        <font size=2 color=steelblue>template</font><font size=2 color=silver>&ensp;<</font><font size=2 color=steelblue>int</font><font size=2 color=gainsboro>&ensp;boundary</font><font size=2 color=silver>,</font><font size=2 color=steelblue>&ensp;typename</font><font size=2 color=mediumseagreen>&ensp;indices</font><font size=2 color=silver>&ensp;=&ensp;std::</font><font size=2 color=mediumseagreen>make_index_sequence</font><font size=2 color=silver><</font><font size=2 color=gainsboro>boundary</font><font size=2 color=silver>>></font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=steelblue>constexpr&ensp;auto</font><font size=2 color=lemonchiffon>&ensp;make_sequence</font><font size=2 color=silver>()&ensp;{</font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&ensp;return</font><font size=2 color=gainsboro>&ensp;make_sequence_impl</font><font size=2 color=silver>(</font><font size=2 color=mediumseagreen>indices</font><font size=2 color=silver>());</font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=silver>}</font>                    </b></li>                </ol>            </td>        </tr>    </tbody></table>  <h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li><code>get_enum_name</code>: 由于 <code>std::regex</code> 不支持 look behind, 此处藉由 <code>QRegualr</code> 实现对编译期常量<b><font color=gainsboro><code>V</code></font></b>和类型<b><font color=mediumseagreen><code>E</code></font></b>的捕获.</li></ul><table>    <tbody>        <tr style="border: none">            <td style="background: black; border: none; width: 100vw; border-radius: 4px">                <ol style="margin:0;">                    <li><b>                        <font size=2 color=steelblue>template</font><font size=2 color=silver>&ensp;<</font><font size=2 color=steelblue>typename</font><font size=2 color=MediumSeaGreen>&ensp;E</font><font size=2 color=silver>,</font><font size=2 color=MediumSeaGreen>&ensp;E</font><font size=2 color=gainsboro>&ensp;V</font><font size=2 color=silver>></font>                    </b></li>                    <li align="left"><b>                        <font size=2 color=steelblue>constexpr</font><font size=2 color=silver>&ensp;std::</font><font size=2 color=MediumSeaGreen>string</font><font size=2 color=LemonChiffon>&ensp;get_enum_name</font><font size=2 color=silver>()&ensp;{</font>                    </b></li>                    <b><li align="left">                        <font size=2 color=silver>&emsp;&emsp;&ensp;std::</font><font size=2 color=mediumseagreen>string</font><font size=2 color=skyblue>&ensp;name</font><font size=2 color=silver>(</font><font size=2 color=mediumpurple>__PRETTY_FUNCTION__</font><font size=2 color=silver>);</font>                    </b></li>                    <b><li align="left">                        <font size=2 color=mediumseagreen>&emsp;&emsp;&ensp;QRegularExpression</font><font size=2 color=skyblue>&ensp;reg</font><font size=2 color=silver>(</font><font size=2 color=peru>"(?<=::)[a-zA-Z_]+[</font><font size=2 color=navajowhite>\\</font><font size=2 color=peru>w]*(?=>)"</font><font size=2 color=silver>);</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumseagreen>&emsp;&emsp;&ensp;QRegularExpressionMatch</font><font size=2 color=skyblue>&ensp;match</font><font size=2 color=silver>&ensp;=</font><font size=2 color=skyblue>&ensp;reg</font><font size=2 color=silver>.</font><font size=2 color=lemonchiffon>match</font><font size=2 color=silver>(</font><font size=2 color=skyblue>name</font><font size=2 color=silver>.</font><font size=2 color=lemonchiffon>c_str</font><font size=2 color=silver>());</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumseagreen>&emsp;&emsp;&ensp;QString</font><font size=2 color=skyblue>&ensp;matched</font><font size=2 color=silver>&ensp;=</font><font size=2 color=lemonchiffon>&ensp;""</font><font size=2 color=silver>;</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&ensp;if</font>                        <font size=2 color=silver>(</font><font size=2 color=skyblue>match</font><font size=2 color=silver>.</font><font size=2 color=lemonchiffon>hasMatch</font><font size=2 color=silver>())&ensp;{</font>                    </b></li>                    <li><b>                        <font size=2 color=skyblue>&emsp;&emsp;&emsp;&emsp;matched</font><font size=2 color=silver>&ensp;=</font><font size=2 color=skyblue>&ensp;match</font><font size=2 color=silver>.</font><font size=2 color=lemonchiffon>captured</font><font size=2 color=silver>(</font><font size=2 color=powderblue>0</font><font size=2 color=silver>);</font>                    </b></li>                    <li><b>                        <font size=2 color=silver>&emsp;&emsp;&ensp;}</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&ensp;return</font><font size=2 color=skyblue>&ensp;matched</font><font size=2 color=silver>.</font><font size=2 color=lemonchiffon>size</font><font size=2 color=silver>()&ensp;></font><font size=2 color=powderblue>&ensp;0</font><font size=2 color=silver>&ensp;?</font><font size=2 color=skyblue>&ensp;matched</font><font size=2 color=silver>.</font><font size=2 color=lemonchiffon>toStdString</font><font size=2 color=silver>()&ensp;:</font><font size=2 color=burlywood>&ensp;""</font><font size=2 color=silver>;</font>                    </b></li>                    <li><b>                        <font size=2 colro=silver>}</font>                    </b></li>                </ol>            </td>        </tr>    </tbody></table>  <ul><li><code>get_all_enum_names</code>:</li></ul><table>    <tbody>        <tr style="border: none">            <td style="background: black; border: none; width: 100vw; border-radius: 4px">                <ol style="margin:0;">                    <li><b>                        <font size=2 color=steelblue>template</font><font size=2 color=silver>&ensp;<</font><font size=2 color=steelblue>typename</font><font size=2 color=mediumseagreen>&ensp;T</font><font size=2 color=silver>,</font><font size=2 color=steelblue>&ensp;int</font><font size=2 color=silver>...</font><font size=2 color=gainsboro>&ensp;Ints</font><font size=2 color=silver>></font>                    </b></li>                    <li><b>                        <font size =2 color=steelblue>constexpr&ensp;auto</font><font size =2 color=lemonchiffon>&ensp;get_all_enum_names</font><font size =2 color=silver>(std::</font><font size =2 color=mediumseagreen>integer_sequence</font><font size =2 color=silver><</font><font size =2 color=steelblue>int</font><font size=2 color=silver>,</font><font size=2 color=gainsboro>&ensp;Ints</font><font size=2 color=silver>...>)&ensp;{</font>                    </b></li>                    <li><b>                        <font size=2 color=silver>&emsp;&emsp;&ensp;std::</font><font size=2 color=mediumseagreen>array</font><font size=2 color=silver><</font><font size=2 color=silver>std::</font><font size=2 color=mediumseagreen>string</font><font size=2 color=silver>,</font><font size=2 color=steelblue>&ensp;sizeof</font><font size=2 color=silver>...(</font><font size=2 color=gainsboro>Ints</font><font size=2 color=silver>)></font><font size=2 color=skyblue>&ensp;names</font><font size=2 color=silver>{</font><font size=2 color=gainsboro>&nbsp;get_enum_name</font><font size=2 color=silver><</font><font size=2 color=mediumseagreen>T</font><font size=2 color=silver>,</font><font size=2 color=steelblue>&ensp;static_cast</font><font size=2 color=silver><</font><font size=2 color=mediumseagreen>T</font><font size=2 color=silver>>(</font><font size=2 color=gainsboro>Ints</font><font size=2 color=silver>)>()...&nbsp;};</font>                    </b></li>                    <li><b>                        <font size=2 color=silver>&emsp;&emsp;&ensp;std::</font><font size=2 color=mediumseagreen>vector</font><font size=2 color=silver><</font><font size=2 color=silver>std::</font><font size=2 color=mediumseagreen>string</font><font size=2 color=silver>></font><font size=2 color=skyblue>&ensp;valid</font><font size=2 color=silver>{};</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&ensp;for</font><font size=2 color=silver>&ensp;(</font><font size=2 color=steelblue>auto const</font><font size=2 color=silver>&</font><font size=2 color=skyblue>&ensp;name</font><font size=2 color=silver>&ensp;:</font><font size=2 color=skyblue>&ensp;names</font><font size=2 color=silver>)&emsp;{</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&emsp;&emsp;&ensp;if</font><font size=2 color=silver>&ensp;(</font><font size=2 color=skyblue>name</font><font size=2 color=silver>.</font><font size=2 color=gainsboro>size</font><font size=2 color=silver>()&ensp;==</font><font size=2 color=powderblue>&ensp;0</font><font size=2 color=silver>)</font><font size=2 color=mediumorchid>&ensp;continue</font><font size=2 color=silver>;</font>                    </b></li>                     <li><b>                        <font size=2 color=skyblue>&emsp;&emsp;&emsp;&emsp;&ensp;valid</font><font size=2 color=silver>.</font><font size=2 color=gainsboro>push_back</font><font size=2 color=silver>(</font><font size=2 color=skyblue>name</font><font size=2 color=silver>);</font>                    </b></li>                                   <li><b>                        <font size=2 color=silver>&emsp;&emsp;&ensp;}</font>                    </b></li>                    <li><b>                        <font size=2 color=mediumorchid>&emsp;&emsp;&ensp;return</font><font size=2 color=skyblue>&ensp;valid</font><font size=2 color=silver>;</font>                    </b></li>                    <li><b>                         <font size=2 color=silver>}</font>                   </b></li>                </ol>            </td>        </tr>    </tbody></table>  <h1 id="接口封装"><a href="#接口封装" class="headerlink" title="接口封装"></a>接口封装</h1><table>    <tbody>        <tr style="border: none">            <td style="background: black; border: none; width: 100vw; border-radius: 4px">                <ol style="margin:0;">                    <li><b>                        <font size=2 color=steelblue>template</font><font size=2 color=silver>&ensp;<</font><font size=2 color=steelblue>typename</font><font size=2 color=mediumseagreen>&ensp;T</font><font size=2 color=silver>,</font><font size=2 color=steelblue>&ensp;int</font><font size=2 color=gainsboro>&ensp;boundary</font><font size=2 color=silver>></font>                    </b></li>                    <li><b>                        <font size=2 color=steelblue>auto</font><font size=2 color=gainsboro>&ensp;enum_names</font><font size=2 color=silver>&ensp;=</font><font size =2 color=gainsboro>&ensp;get_all_enum_names</font><font size =2 color=silver><</font><font size =2 color=mediumseagreen>T</font><font size =2 color=silver>>(</font><font size=2 color=gainsboro>make_sequence</font><font size=2 color=silver><</font><font size=2 color=gainsboro>boundary</font><font size=2 color=silver>>());</font>                    </b></li>                </ol>            </td>        </tr>    </tbody></table>  ]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
